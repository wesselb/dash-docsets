<!-- This file is machine generated: DO NOT EDIT! -->
<h1 id="constants-sequences-and-random-values">Constants, Sequences, and Random Values</h1>
<p>Note: Functions taking <code>Tensor</code> arguments can also take anything accepted by <a href="framework.md#convert_to_tensor"><code>tf.convert_to_tensor</code></a>.</p>
<p>[TOC]</p>
<h2 id="constant-value-tensors">Constant Value Tensors</h2>
<p>TensorFlow provides several operations that you can use to generate constants.</p>
<hr />
<h3 id="tf.zerosshape-dtypetf.float32-namenone"><a name="//apple_ref/cpp/Function/zeros" class="dashAnchor"></a><code id="zeros">tf.zeros(shape, dtype=tf.float32, name=None)</code></h3>
<p>Creates a tensor with all elements set to zero.</p>
<p>This operation returns a tensor of type <code>dtype</code> with shape <code>shape</code> and all elements set to zero.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">tf.zeros([<span class="dv">3</span>, <span class="dv">4</span>], tf.int32) <span class="op">==&gt;</span> [[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]]</code></pre></div>
<h5 id="args">Args:</h5>
<ul>
<li><b><code>shape</code></b>: Either a list of integers, or a 1-D <code>Tensor</code> of type <code>int32</code>.</li>
<li><b><code>dtype</code></b>: The type of an element in the resulting <code>Tensor</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns">Returns:</h5>
<p>A <code>Tensor</code> with all elements set to zero.</p>
<hr />
<h3 id="tf.zeros_liketensor-dtypenone-namenone-optimizetrue"><a name="//apple_ref/cpp/Function/zeros_like" class="dashAnchor"></a><code id="zeros_like">tf.zeros_like(tensor, dtype=None, name=None, optimize=True)</code></h3>
<p>Creates a tensor with all elements set to zero.</p>
<p>Given a single tensor (<code>tensor</code>), this operation returns a tensor of the same type and shape as <code>tensor</code> with all elements set to zero. Optionally, you can use <code>dtype</code> to specify a new type for the returned tensor.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># &#39;tensor&#39; is [[1, 2, 3], [4, 5, 6]]</span>
tf.zeros_like(tensor) <span class="op">==&gt;</span> [[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]]</code></pre></div>
<h5 id="args-1">Args:</h5>
<ul>
<li><b><code>tensor</code></b>: A <code>Tensor</code>.</li>
<li><p><b><code>dtype</code></b>: A type for the returned <code>Tensor</code>. Must be <code>float32</code>, <code>float64</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>complex64</code>, or <code>complex128</code>.</p></li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
<li><p><b><code>optimize</code></b>: if true, attempt to statically determine the shape of 'tensor' and encode it as a constant.</p></li>
</ul>
<h5 id="returns-1">Returns:</h5>
<p>A <code>Tensor</code> with all elements set to zero.</p>
<hr />
<h3 id="tf.onesshape-dtypetf.float32-namenone"><a name="//apple_ref/cpp/Function/ones" class="dashAnchor"></a><code id="ones">tf.ones(shape, dtype=tf.float32, name=None)</code></h3>
<p>Creates a tensor with all elements set to 1.</p>
<p>This operation returns a tensor of type <code>dtype</code> with shape <code>shape</code> and all elements set to 1.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">tf.ones([<span class="dv">2</span>, <span class="dv">3</span>], tf.int32) <span class="op">==&gt;</span> [[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>]]</code></pre></div>
<h5 id="args-2">Args:</h5>
<ul>
<li><b><code>shape</code></b>: Either a list of integers, or a 1-D <code>Tensor</code> of type <code>int32</code>.</li>
<li><b><code>dtype</code></b>: The type of an element in the resulting <code>Tensor</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-2">Returns:</h5>
<p>A <code>Tensor</code> with all elements set to 1.</p>
<hr />
<h3 id="tf.ones_liketensor-dtypenone-namenone-optimizetrue"><a name="//apple_ref/cpp/Function/ones_like" class="dashAnchor"></a><code id="ones_like">tf.ones_like(tensor, dtype=None, name=None, optimize=True)</code></h3>
<p>Creates a tensor with all elements set to 1.</p>
<p>Given a single tensor (<code>tensor</code>), this operation returns a tensor of the same type and shape as <code>tensor</code> with all elements set to 1. Optionally, you can specify a new type (<code>dtype</code>) for the returned tensor.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># &#39;tensor&#39; is [[1, 2, 3], [4, 5, 6]]</span>
tf.ones_like(tensor) <span class="op">==&gt;</span> [[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>]]</code></pre></div>
<h5 id="args-3">Args:</h5>
<ul>
<li><b><code>tensor</code></b>: A <code>Tensor</code>.</li>
<li><b><code>dtype</code></b>: A type for the returned <code>Tensor</code>. Must be <code>float32</code>, <code>float64</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>complex64</code>, <code>complex128</code> or <code>bool</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
<li><b><code>optimize</code></b>: if true, attempt to statically determine the shape of 'tensor' and encode it as a constant.</li>
</ul>
<h5 id="returns-3">Returns:</h5>
<p>A <code>Tensor</code> with all elements set to 1.</p>
<hr />
<h3 id="tf.filldims-value-namenone"><a name="//apple_ref/cpp/Function/fill" class="dashAnchor"></a><code id="fill">tf.fill(dims, value, name=None)</code></h3>
<p>Creates a tensor filled with a scalar value.</p>
<p>This operation creates a tensor of shape <code>dims</code> and fills it with <code>value</code>.</p>
<p>For example:</p>
<pre class="prettyprint"><code># Output tensor has shape [2, 3].
fill([2, 3], 9) ==&gt; [[9, 9, 9]
                     [9, 9, 9]]</code></pre>
<h5 id="args-4">Args:</h5>
<ul>
<li><b><code>dims</code></b>: A <code>Tensor</code> of type <code>int32</code>. 1-D. Represents the shape of the output tensor.</li>
<li><p><b><code>value</code></b>: A <code>Tensor</code>. 0-D (scalar). Value to fill the returned tensor.</p>
<p><span class="citation">@compatibility</span>(numpy) Equivalent to np.full <span class="citation">@end_compatibility</span></p></li>
<li><p><b><code>name</code></b>: A name for the operation (optional).</p></li>
</ul>
<h5 id="returns-4">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>value</code>.</p>
<hr />
<h3 id="tf.constantvalue-dtypenone-shapenone-nameconst-verify_shapefalse"><a name="//apple_ref/cpp/Function/constant" class="dashAnchor"></a><code id="constant">tf.constant(value, dtype=None, shape=None, name='Const', verify_shape=False)</code></h3>
<p>Creates a constant tensor.</p>
<p>The resulting tensor is populated with values of type <code>dtype</code>, as specified by arguments <code>value</code> and (optionally) <code>shape</code> (see examples below).</p>
<p>The argument <code>value</code> can be a constant value, or a list of values of type <code>dtype</code>. If <code>value</code> is a list, then the length of the list must be less than or equal to the number of elements implied by the <code>shape</code> argument (if specified). In the case where the list length is less than the number of elements specified by <code>shape</code>, the last element in the list will be used to fill the remaining entries.</p>
<p>The argument <code>shape</code> is optional. If present, it specifies the dimensions of the resulting tensor. If not present, the shape of <code>value</code> is used.</p>
<p>If the argument <code>dtype</code> is not specified, then the type is inferred from the type of <code>value</code>.</p>
<p>For example:</p>
<p>```python # Constant 1-D Tensor populated with value list. tensor = tf.constant([1, 2, 3, 4, 5, 6, 7]) =&gt; [1 2 3 4 5 6 7]</p>
<p># Constant 2-D tensor populated with scalar value -1. tensor = tf.constant(-1.0, shape=[2, 3]) =&gt; [[-1. -1. -1.][-1. -1. -1.]] ```</p>
<h5 id="args-5">Args:</h5>
<ul>
<li><p><b><code>value</code></b>: A constant value (or list) of output type <code>dtype</code>.</p></li>
<li><p><b><code>dtype</code></b>: The type of the elements of the resulting tensor.</p></li>
<li><p><b><code>shape</code></b>: Optional dimensions of resulting tensor.</p></li>
<li><p><b><code>name</code></b>: Optional name for the tensor.</p></li>
<li><p><b><code>verify_shape</code></b>: Boolean that enables verification of a shape of values.</p></li>
</ul>
<h5 id="returns-5">Returns:</h5>
<p>A Constant Tensor.</p>
<h2 id="sequences">Sequences</h2>
<hr />
<h3 id="tf.linspacestart-stop-num-namenone"><a name="//apple_ref/cpp/Function/linspace" class="dashAnchor"></a><code id="linspace">tf.linspace(start, stop, num, name=None)</code></h3>
<p>Generates values in an interval.</p>
<p>A sequence of <code>num</code> evenly-spaced values are generated beginning at <code>start</code>. If <code>num &gt; 1</code>, the values in the sequence increase by <code>stop - start / num - 1</code>, so that the last one is exactly <code>stop</code>.</p>
<p>For example:</p>
<pre><code>tf.linspace(10.0, 12.0, 3, name=&quot;linspace&quot;) =&gt; [ 10.0  11.0  12.0]</code></pre>
<h5 id="args-6">Args:</h5>
<ul>
<li><b><code>start</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>. First entry in the range.</li>
<li><b><code>stop</code></b>: A <code>Tensor</code>. Must have the same type as <code>start</code>. Last entry in the range.</li>
<li><b><code>num</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>. Number of values to generate.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-6">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>start</code>. 1-D. The generated values.</p>
<hr />
<h3 id="tf.rangestart-limitnone-delta1-dtypenone-namerange"><a name="//apple_ref/cpp/Function/range" class="dashAnchor"></a><code id="range">tf.range(start, limit=None, delta=1, dtype=None, name='range')</code></h3>
<p>Creates a sequence of numbers.</p>
<p>Creates a sequence of numbers that begins at <code>start</code> and extends by increments of <code>delta</code> up to but not including <code>limit</code>.</p>
<p>The dtype of the resulting tensor is inferred from the inputs unless it is provided explicitly.</p>
<p>Like the Python builtin <code>range</code>, <code>start</code> defaults to 0, so that <code>range(n) = range(0, n)</code>.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># &#39;start&#39; is 3</span>
<span class="co"># &#39;limit&#39; is 18</span>
<span class="co"># &#39;delta&#39; is 3</span>
tf.<span class="bu">range</span>(start, limit, delta) <span class="op">==&gt;</span> [<span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">9</span>, <span class="dv">12</span>, <span class="dv">15</span>]

<span class="co"># &#39;start&#39; is 3</span>
<span class="co"># &#39;limit&#39; is 1</span>
<span class="co"># &#39;delta&#39; is -0.5</span>
tf.<span class="bu">range</span>(start, limit, delta) <span class="op">==&gt;</span> [<span class="dv">3</span>, <span class="fl">2.5</span>, <span class="dv">2</span>, <span class="fl">1.5</span>]

<span class="co"># &#39;limit&#39; is 5</span>
tf.<span class="bu">range</span>(limit) <span class="op">==&gt;</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</code></pre></div>
<h5 id="args-7">Args:</h5>
<ul>
<li><b><code>start</code></b>: A 0-D <code>Tensor</code> (scalar). Acts as first entry in the range if <code>limit</code> is not None; otherwise, acts as range limit and first entry defaults to 0.</li>
<li><b><code>limit</code></b>: A 0-D <code>Tensor</code> (scalar). Upper limit of sequence, exclusive. If None, defaults to the value of <code>start</code> while the first entry of the range defaults to 0.</li>
<li><b><code>delta</code></b>: A 0-D <code>Tensor</code> (scalar). Number that increments <code>start</code>. Defaults to 1.</li>
<li><b><code>dtype</code></b>: The type of the elements of the resulting tensor.</li>
<li><b><code>name</code></b>: A name for the operation. Defaults to &quot;range&quot;.</li>
</ul>
<h5 id="returns-7">Returns:</h5>
<p>An 1-D <code>Tensor</code> of type <code>dtype</code>.</p>
<p><span class="citation">@compatibility</span>(numpy) Equivalent to np.arange <span class="citation">@end_compatibility</span></p>
<h2 id="random-tensors">Random Tensors</h2>
<p>TensorFlow has several ops that create random tensors with different distributions. The random ops are stateful, and create new random values each time they are evaluated.</p>
<p>The <code>seed</code> keyword argument in these functions acts in conjunction with the graph-level random seed. Changing either the graph-level seed using <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a> or the op-level seed will change the underlying seed of these operations. Setting neither graph-level nor op-level seed, results in a random seed for all operations. See <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a> for details on the interaction between operation-level and graph-level random seeds.</p>
<h3 id="examples">Examples:</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Create a tensor of shape [2, 3] consisting of random normal values, with mean</span>
<span class="co"># -1 and standard deviation 4.</span>
norm <span class="op">=</span> tf.random_normal([<span class="dv">2</span>, <span class="dv">3</span>], mean<span class="op">=-</span><span class="dv">1</span>, stddev<span class="op">=</span><span class="dv">4</span>)

<span class="co"># Shuffle the first dimension of a tensor</span>
c <span class="op">=</span> tf.constant([[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">3</span>, <span class="dv">4</span>], [<span class="dv">5</span>, <span class="dv">6</span>]])
shuff <span class="op">=</span> tf.random_shuffle(c)

<span class="co"># Each time we run these ops, different results are generated</span>
sess <span class="op">=</span> tf.Session()
<span class="bu">print</span>(sess.run(norm))
<span class="bu">print</span>(sess.run(norm))

<span class="co"># Set an op-level seed to generate repeatable sequences across sessions.</span>
norm <span class="op">=</span> tf.random_normal([<span class="dv">2</span>, <span class="dv">3</span>], seed<span class="op">=</span><span class="dv">1234</span>)
sess <span class="op">=</span> tf.Session()
<span class="bu">print</span>(sess.run(norm))
<span class="bu">print</span>(sess.run(norm))
sess <span class="op">=</span> tf.Session()
<span class="bu">print</span>(sess.run(norm))
<span class="bu">print</span>(sess.run(norm))</code></pre></div>
<p>Another common use of random values is the initialization of variables. Also see the <a href="../../how_tos/variables/index.md">Variables How To</a>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Use random uniform values in [0, 1) as the initializer for a variable of shape</span>
<span class="co"># [2, 3]. The default type is float32.</span>
var <span class="op">=</span> tf.Variable(tf.random_uniform([<span class="dv">2</span>, <span class="dv">3</span>]), name<span class="op">=</span><span class="st">&quot;var&quot;</span>)
init <span class="op">=</span> tf.global_variables_initializer()

sess <span class="op">=</span> tf.Session()
sess.run(init)
<span class="bu">print</span>(sess.run(var))</code></pre></div>
<hr />
<h3 id="tf.random_normalshape-mean0.0-stddev1.0-dtypetf.float32-seednone-namenone"><a name="//apple_ref/cpp/Function/random_normal" class="dashAnchor"></a><code id="random_normal">tf.random_normal(shape, mean=0.0, stddev=1.0, dtype=tf.float32, seed=None, name=None)</code></h3>
<p>Outputs random values from a normal distribution.</p>
<h5 id="args-8">Args:</h5>
<ul>
<li><b><code>shape</code></b>: A 1-D integer Tensor or Python array. The shape of the output tensor.</li>
<li><b><code>mean</code></b>: A 0-D Tensor or Python value of type <code>dtype</code>. The mean of the normal distribution.</li>
<li><b><code>stddev</code></b>: A 0-D Tensor or Python value of type <code>dtype</code>. The standard deviation of the normal distribution.</li>
<li><b><code>dtype</code></b>: The type of the output.</li>
<li><b><code>seed</code></b>: A Python integer. Used to create a random seed for the distribution. See <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a> for behavior.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-8">Returns:</h5>
<p>A tensor of the specified shape filled with random normal values.</p>
<hr />
<h3 id="tf.truncated_normalshape-mean0.0-stddev1.0-dtypetf.float32-seednone-namenone"><a name="//apple_ref/cpp/Function/truncated_normal" class="dashAnchor"></a><code id="truncated_normal">tf.truncated_normal(shape, mean=0.0, stddev=1.0, dtype=tf.float32, seed=None, name=None)</code></h3>
<p>Outputs random values from a truncated normal distribution.</p>
<p>The generated values follow a normal distribution with specified mean and standard deviation, except that values whose magnitude is more than 2 standard deviations from the mean are dropped and re-picked.</p>
<h5 id="args-9">Args:</h5>
<ul>
<li><b><code>shape</code></b>: A 1-D integer Tensor or Python array. The shape of the output tensor.</li>
<li><b><code>mean</code></b>: A 0-D Tensor or Python value of type <code>dtype</code>. The mean of the truncated normal distribution.</li>
<li><b><code>stddev</code></b>: A 0-D Tensor or Python value of type <code>dtype</code>. The standard deviation of the truncated normal distribution.</li>
<li><b><code>dtype</code></b>: The type of the output.</li>
<li><b><code>seed</code></b>: A Python integer. Used to create a random seed for the distribution. See <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a> for behavior.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-9">Returns:</h5>
<p>A tensor of the specified shape filled with random truncated normal values.</p>
<hr />
<h3 id="tf.random_uniformshape-minval0-maxvalnone-dtypetf.float32-seednone-namenone"><a name="//apple_ref/cpp/Function/random_uniform" class="dashAnchor"></a><code id="random_uniform">tf.random_uniform(shape, minval=0, maxval=None, dtype=tf.float32, seed=None, name=None)</code></h3>
<p>Outputs random values from a uniform distribution.</p>
<p>The generated values follow a uniform distribution in the range <code>[minval, maxval)</code>. The lower bound <code>minval</code> is included in the range, while the upper bound <code>maxval</code> is excluded.</p>
<p>For floats, the default range is <code>[0, 1)</code>. For ints, at least <code>maxval</code> must be specified explicitly.</p>
<p>In the integer case, the random integers are slightly biased unless <code>maxval - minval</code> is an exact power of two. The bias is small for values of <code>maxval - minval</code> significantly smaller than the range of the output (either <code>2**32</code> or <code>2**64</code>).</p>
<h5 id="args-10">Args:</h5>
<ul>
<li><b><code>shape</code></b>: A 1-D integer Tensor or Python array. The shape of the output tensor.</li>
<li><b><code>minval</code></b>: A 0-D Tensor or Python value of type <code>dtype</code>. The lower bound on the range of random values to generate. Defaults to 0.</li>
<li><b><code>maxval</code></b>: A 0-D Tensor or Python value of type <code>dtype</code>. The upper bound on the range of random values to generate. Defaults to 1 if <code>dtype</code> is floating point.</li>
<li><b><code>dtype</code></b>: The type of the output: <code>float32</code>, <code>float64</code>, <code>int32</code>, or <code>int64</code>.</li>
<li><b><code>seed</code></b>: A Python integer. Used to create a random seed for the distribution. See <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a> for behavior.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-10">Returns:</h5>
<p>A tensor of the specified shape filled with random uniform values.</p>
<h5 id="raises">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If <code>dtype</code> is integral and <code>maxval</code> is not specified.</li>
</ul>
<hr />
<h3 id="tf.random_shufflevalue-seednone-namenone"><a name="//apple_ref/cpp/Function/random_shuffle" class="dashAnchor"></a><code id="random_shuffle">tf.random_shuffle(value, seed=None, name=None)</code></h3>
<p>Randomly shuffles a tensor along its first dimension.</p>
<p>The tensor is shuffled along dimension 0, such that each <code>value[j]</code> is mapped to one and only one <code>output[i]</code>. For example, a mapping that might occur for a 3x2 tensor is:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">[[<span class="dv">1</span>, <span class="dv">2</span>],       [[<span class="dv">5</span>, <span class="dv">6</span>],
 [<span class="dv">3</span>, <span class="dv">4</span>],  <span class="op">==&gt;</span>   [<span class="dv">1</span>, <span class="dv">2</span>],
 [<span class="dv">5</span>, <span class="dv">6</span>]]        [<span class="dv">3</span>, <span class="dv">4</span>]]</code></pre></div>
<h5 id="args-11">Args:</h5>
<ul>
<li><b><code>value</code></b>: A Tensor to be shuffled.</li>
<li><b><code>seed</code></b>: A Python integer. Used to create a random seed for the distribution. See <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a> for behavior.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-11">Returns:</h5>
<p>A tensor of same shape and type as <code>value</code>, shuffled along its first dimension.</p>
<hr />
<h3 id="tf.random_cropvalue-size-seednone-namenone"><a name="//apple_ref/cpp/Function/random_crop" class="dashAnchor"></a><code id="random_crop">tf.random_crop(value, size, seed=None, name=None)</code></h3>
<p>Randomly crops a tensor to a given size.</p>
<p>Slices a shape <code>size</code> portion out of <code>value</code> at a uniformly chosen offset. Requires <code>value.shape &gt;= size</code>.</p>
<p>If a dimension should not be cropped, pass the full size of that dimension. For example, RGB images can be cropped with <code>size = [crop_height, crop_width, 3]</code>.</p>
<h5 id="args-12">Args:</h5>
<ul>
<li><b><code>value</code></b>: Input tensor to crop.</li>
<li><b><code>size</code></b>: 1-D tensor with size the rank of <code>value</code>.</li>
<li><b><code>seed</code></b>: Python integer. Used to create a random seed. See <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a> for behavior.</li>
<li><b><code>name</code></b>: A name for this operation (optional).</li>
</ul>
<h5 id="returns-12">Returns:</h5>
<p>A cropped tensor of the same rank as <code>value</code> and shape <code>size</code>.</p>
<hr />
<h3 id="tf.multinomiallogits-num_samples-seednone-namenone"><a name="//apple_ref/cpp/Function/multinomial" class="dashAnchor"></a><code id="multinomial">tf.multinomial(logits, num_samples, seed=None, name=None)</code></h3>
<p>Draws samples from a multinomial distribution.</p>
<p>Example:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># samples has shape [1, 5], where each value is either 0 or 1 with equal</span>
<span class="co"># probability.</span>
samples <span class="op">=</span> tf.multinomial(tf.log([[<span class="dv">10</span>., <span class="dv">10</span>.]]), <span class="dv">5</span>)</code></pre></div>
<h5 id="args-13">Args:</h5>
<ul>
<li><b><code>logits</code></b>: 2-D Tensor with shape <code>[batch_size, num_classes]</code>. Each slice <code>[i, :]</code> represents the unnormalized log probabilities for all classes.</li>
<li><b><code>num_samples</code></b>: 0-D. Number of independent samples to draw for each row slice.</li>
<li><b><code>seed</code></b>: A Python integer. Used to create a random seed for the distribution. See <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a> for behavior.</li>
<li><b><code>name</code></b>: Optional name for the operation.</li>
</ul>
<h5 id="returns-13">Returns:</h5>
<p>The drawn samples of shape <code>[batch_size, num_samples]</code>.</p>
<hr />
<h3 id="tf.random_gammashape-alpha-betanone-dtypetf.float32-seednone-namenone"><a name="//apple_ref/cpp/Function/random_gamma" class="dashAnchor"></a><code id="random_gamma">tf.random_gamma(shape, alpha, beta=None, dtype=tf.float32, seed=None, name=None)</code></h3>
<p>Draws <code>shape</code> samples from each of the given Gamma distribution(s).</p>
<p><code>alpha</code> is the shape parameter describing the distribution(s), and <code>beta</code> is the inverse scale parameter(s).</p>
<p>Example:</p>
<p>samples = tf.random_gamma([10], [0.5, 1.5]) # samples has shape [10, 2], where each slice [:, 0] and [:, 1] represents # the samples drawn from each distribution</p>
<p>samples = tf.random_gamma([7, 5], [0.5, 1.5]) # samples has shape [7, 5, 2], where each slice [:, :, 0] and [:, :, 1] # represents the 7x5 samples drawn from each of the two distributions</p>
<p>samples = tf.random_gamma([30], [[1.],[3.],[5.]], beta=[[3., 4.]]) # samples has shape [30, 3, 2], with 30 samples each of 3x2 distributions.</p>
<p>Note that for small alpha values, there is a chance you will draw a value of exactly 0, which gets worse for lower-precision dtypes, even though zero is not in the support of the gamma distribution.</p>
<p>Relevant cdfs (~chance you will draw a exactly-0 value): <code>stats.gamma(.01).cdf(np.finfo(np.float16).tiny)         0.91269738769897879     stats.gamma(.01).cdf(np.finfo(np.float32).tiny)         0.41992668622045726     stats.gamma(.01).cdf(np.finfo(np.float64).tiny)         0.00084322740680686662     stats.gamma(.35).cdf(np.finfo(np.float16).tiny)         0.037583276135263931     stats.gamma(.35).cdf(np.finfo(np.float32).tiny)         5.9514895726818067e-14     stats.gamma(.35).cdf(np.finfo(np.float64).tiny)         2.3529843400647272e-108</code></p>
<h5 id="args-14">Args:</h5>
<ul>
<li><b><code>shape</code></b>: A 1-D integer Tensor or Python array. The shape of the output samples to be drawn per alpha/beta-parameterized distribution.</li>
<li><b><code>alpha</code></b>: A Tensor or Python value or N-D array of type <code>dtype</code>. <code>alpha</code> provides the shape parameter(s) describing the gamma distribution(s) to sample. Must be broadcastable with <code>beta</code>.</li>
<li><b><code>beta</code></b>: A Tensor or Python value or N-D array of type <code>dtype</code>. Defaults to 1. <code>beta</code> provides the inverse scale parameter(s) of the gamma distribution(s) to sample. Must be broadcastable with <code>alpha</code>.</li>
<li><b><code>dtype</code></b>: The type of alpha, beta, and the output: <code>float16</code>, <code>float32</code>, or <code>float64</code>.</li>
<li><b><code>seed</code></b>: A Python integer. Used to create a random seed for the distributions. See <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a> for behavior.</li>
<li><b><code>name</code></b>: Optional name for the operation.</li>
</ul>
<h5 id="returns-14">Returns:</h5>
<ul>
<li><b><code>samples</code></b>: a <code>Tensor</code> of shape <code>tf.concat(shape, tf.shape(alpha + beta))</code> with values of type <code>dtype</code>.</li>
</ul>
<hr />
<h3 id="tf.set_random_seedseed"><a name="//apple_ref/cpp/Function/set_random_seed" class="dashAnchor"></a><code id="set_random_seed">tf.set_random_seed(seed)</code></h3>
<p>Sets the graph-level random seed.</p>
<p>Operations that rely on a random seed actually derive it from two seeds: the graph-level and operation-level seeds. This sets the graph-level seed.</p>
<p>Its interactions with operation-level seeds is as follows:</p>
<ol style="list-style-type: decimal">
<li>If neither the graph-level nor the operation seed is set: A random seed is used for this op.</li>
<li>If the graph-level seed is set, but the operation seed is not: The system deterministically picks an operation seed in conjunction with the graph-level seed so that it gets a unique random sequence.</li>
<li>If the graph-level seed is not set, but the operation seed is set: A default graph-level seed and the specified operation seed are used to determine the random sequence.</li>
<li>If both the graph-level and the operation seed are set: Both seeds are used in conjunction to determine the random sequence.</li>
</ol>
<p>To illustrate the user-visible effects, consider these examples:</p>
<p>To generate different sequences across sessions, set neither graph-level nor op-level seeds:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">a <span class="op">=</span> tf.random_uniform([<span class="dv">1</span>])
b <span class="op">=</span> tf.random_normal([<span class="dv">1</span>])

<span class="bu">print</span>(<span class="st">&quot;Session 1&quot;</span>)
<span class="cf">with</span> tf.Session() <span class="im">as</span> sess1:
  <span class="bu">print</span>(sess1.run(a))  <span class="co"># generates &#39;A1&#39;</span>
  <span class="bu">print</span>(sess1.run(a))  <span class="co"># generates &#39;A2&#39;</span>
  <span class="bu">print</span>(sess1.run(b))  <span class="co"># generates &#39;B1&#39;</span>
  <span class="bu">print</span>(sess1.run(b))  <span class="co"># generates &#39;B2&#39;</span>

<span class="bu">print</span>(<span class="st">&quot;Session 2&quot;</span>)
<span class="cf">with</span> tf.Session() <span class="im">as</span> sess2:
  <span class="bu">print</span>(sess2.run(a))  <span class="co"># generates &#39;A3&#39;</span>
  <span class="bu">print</span>(sess2.run(a))  <span class="co"># generates &#39;A4&#39;</span>
  <span class="bu">print</span>(sess2.run(b))  <span class="co"># generates &#39;B3&#39;</span>
  <span class="bu">print</span>(sess2.run(b))  <span class="co"># generates &#39;B4&#39;</span></code></pre></div>
<p>To generate the same repeatable sequence for an op across sessions, set the seed for the op:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">a <span class="op">=</span> tf.random_uniform([<span class="dv">1</span>], seed<span class="op">=</span><span class="dv">1</span>)
b <span class="op">=</span> tf.random_normal([<span class="dv">1</span>])

<span class="co"># Repeatedly running this block with the same graph will generate the same</span>
<span class="co"># sequence of values for &#39;a&#39;, but different sequences of values for &#39;b&#39;.</span>
<span class="bu">print</span>(<span class="st">&quot;Session 1&quot;</span>)
<span class="cf">with</span> tf.Session() <span class="im">as</span> sess1:
  <span class="bu">print</span>(sess1.run(a))  <span class="co"># generates &#39;A1&#39;</span>
  <span class="bu">print</span>(sess1.run(a))  <span class="co"># generates &#39;A2&#39;</span>
  <span class="bu">print</span>(sess1.run(b))  <span class="co"># generates &#39;B1&#39;</span>
  <span class="bu">print</span>(sess1.run(b))  <span class="co"># generates &#39;B2&#39;</span>

<span class="bu">print</span>(<span class="st">&quot;Session 2&quot;</span>)
<span class="cf">with</span> tf.Session() <span class="im">as</span> sess2:
  <span class="bu">print</span>(sess2.run(a))  <span class="co"># generates &#39;A1&#39;</span>
  <span class="bu">print</span>(sess2.run(a))  <span class="co"># generates &#39;A2&#39;</span>
  <span class="bu">print</span>(sess2.run(b))  <span class="co"># generates &#39;B3&#39;</span>
  <span class="bu">print</span>(sess2.run(b))  <span class="co"># generates &#39;B4&#39;</span></code></pre></div>
<p>To make the random sequences generated by all ops be repeatable across sessions, set a graph-level seed:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">tf.set_random_seed(<span class="dv">1234</span>)
a <span class="op">=</span> tf.random_uniform([<span class="dv">1</span>])
b <span class="op">=</span> tf.random_normal([<span class="dv">1</span>])

<span class="co"># Repeatedly running this block with the same graph will generate different</span>
<span class="co"># sequences of &#39;a&#39; and &#39;b&#39;.</span>
<span class="bu">print</span>(<span class="st">&quot;Session 1&quot;</span>)
<span class="cf">with</span> tf.Session() <span class="im">as</span> sess1:
  <span class="bu">print</span>(sess1.run(a))  <span class="co"># generates &#39;A1&#39;</span>
  <span class="bu">print</span>(sess1.run(a))  <span class="co"># generates &#39;A2&#39;</span>
  <span class="bu">print</span>(sess1.run(b))  <span class="co"># generates &#39;B1&#39;</span>
  <span class="bu">print</span>(sess1.run(b))  <span class="co"># generates &#39;B2&#39;</span>

<span class="bu">print</span>(<span class="st">&quot;Session 2&quot;</span>)
<span class="cf">with</span> tf.Session() <span class="im">as</span> sess2:
  <span class="bu">print</span>(sess2.run(a))  <span class="co"># generates &#39;A1&#39;</span>
  <span class="bu">print</span>(sess2.run(a))  <span class="co"># generates &#39;A2&#39;</span>
  <span class="bu">print</span>(sess2.run(b))  <span class="co"># generates &#39;B1&#39;</span>
  <span class="bu">print</span>(sess2.run(b))  <span class="co"># generates &#39;B2&#39;</span></code></pre></div>
<h5 id="args-15">Args:</h5>
<ul>
<li><b><code>seed</code></b>: integer.</li>
</ul>
