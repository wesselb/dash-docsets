<div itemscope="" itemtype="http://developers.google.com/ReferenceObject">
<p><meta itemprop="name" content="tf.compat.v1.norm" /> <meta itemprop="path" content="Stable" /></p>
</div>
<a name="//apple_ref/cpp/Function/tf.compat.v1.norm" class="dashAnchor"></a><h1 id="tf.compat.v1.norm">tf.compat.v1.norm</h1>
<p>Computes the norm of vectors, matrices, and tensors. (deprecated arguments)</p>
<h3 id="aliases">Aliases:</h3>
<ul>
<li><code>tf.compat.v1.linalg.norm</code></li>
<li><code>tf.compat.v1.norm</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">tf.compat.v1.norm(
    tensor,
    <span class="bu">ord</span><span class="op">=</span><span class="st">&#39;euclidean&#39;</span>,
    axis<span class="op">=</span><span class="va">None</span>,
    keepdims<span class="op">=</span><span class="va">None</span>,
    name<span class="op">=</span><span class="va">None</span>,
    keep_dims<span class="op">=</span><span class="va">None</span>
)</code></pre></div>
<p>Defined in <a href="/code/stable/tensorflow/python/ops/linalg_ops.py"><code>python/ops/linalg_ops.py</code></a>.</p>
<!-- Placeholder for "Used in" -->
<p>Warning: SOME ARGUMENTS ARE DEPRECATED: <code>(keep_dims)</code>. They will be removed in a future version. Instructions for updating: keep_dims is deprecated, use keepdims instead</p>
<p>This function can compute several different vector norms (the 1-norm, the Euclidean or 2-norm, the inf-norm, and in general the p-norm for p &gt; 0) and matrix norms (Frobenius, 1-norm, 2-norm and inf-norm).</p>
<h4 id="args">Args:</h4>
<ul>
<li><b><code>tensor</code></b>: <code>Tensor</code> of types <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code></li>
<li><b><code>ord</code></b>: Order of the norm. Supported values are 'fro', 'euclidean', <code>1</code>, <code>2</code>, <code>np.inf</code> and any positive real number yielding the corresponding p-norm. Default is 'euclidean' which is equivalent to Frobenius norm if <code>tensor</code> is a matrix and equivalent to 2-norm for vectors. Some restrictions apply:
<ol style="list-style-type: lower-alpha">
<li>The Frobenius norm <code>fro</code> is not defined for vectors,</li>
<li>If axis is a 2-tuple (matrix norm), only 'euclidean', 'fro', <code>1</code>, <code>2</code>, <code>np.inf</code> are supported. See the description of <code>axis</code> on how to compute norms for a batch of vectors or matrices stored in a tensor.</li>
</ol></li>
<li><b><code>axis</code></b>: If <code>axis</code> is <code>None</code> (the default), the input is considered a vector and a single vector norm is computed over the entire set of values in the tensor, i.e. <code>norm(tensor, ord=ord)</code> is equivalent to <code>norm(reshape(tensor, [-1]), ord=ord)</code>. If <code>axis</code> is a Python integer, the input is considered a batch of vectors, and <code>axis</code> determines the axis in <code>tensor</code> over which to compute vector norms. If <code>axis</code> is a 2-tuple of Python integers it is considered a batch of matrices and <code>axis</code> determines the axes in <code>tensor</code> over which to compute a matrix norm. Negative indices are supported. Example: If you are passing a tensor that can be either a matrix or a batch of matrices at runtime, pass <code>axis=[-2,-1]</code> instead of <code>axis=None</code> to make sure that matrix norms are computed.</li>
<li><b><code>keepdims</code></b>: If True, the axis indicated in <code>axis</code> are kept with size 1. Otherwise, the dimensions in <code>axis</code> are removed from the output shape.</li>
<li><b><code>name</code></b>: The name of the op.</li>
<li><b><code>keep_dims</code></b>: Deprecated alias for <code>keepdims</code>.</li>
</ul>
<h4 id="returns">Returns:</h4>
<ul>
<li><b><code>output</code></b>: A <code>Tensor</code> of the same type as tensor, containing the vector or matrix norms. If <code>keepdims</code> is True then the rank of output is equal to the rank of <code>tensor</code>. Otherwise, if <code>axis</code> is none the output is a scalar, if <code>axis</code> is an integer, the rank of <code>output</code> is one less than the rank of <code>tensor</code>, if <code>axis</code> is a 2-tuple the rank of <code>output</code> is two less than the rank of <code>tensor</code>.</li>
</ul>
<h4 id="raises">Raises:</h4>
<ul>
<li><b><code>ValueError</code></b>: If <code>ord</code> or <code>axis</code> is invalid.</li>
</ul>
<h4 id="numpy-compatibility">Numpy Compatibility</h4>
<p>Mostly equivalent to numpy.linalg.norm. Not supported: ord &lt;= 0, 2-norm for matrices, nuclear norm. Other differences: a) If axis is <code>None</code>, treats the flattened <code>tensor</code> as a vector regardless of rank. b) Explicitly supports 'euclidean' norm as the default, including for higher order tensors.</p>
