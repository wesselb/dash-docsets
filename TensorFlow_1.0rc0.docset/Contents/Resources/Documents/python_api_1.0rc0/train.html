<!-- This file is machine generated: DO NOT EDIT! -->
<h1 id="training">Training</h1>
<p>[TOC]</p>
<p>This library provides a set of classes and functions that helps train models.</p>
<h2 id="optimizers">Optimizers</h2>
<p>The Optimizer base class provides methods to compute gradients for a loss and apply gradients to variables. A collection of subclasses implement classic optimization algorithms such as GradientDescent and Adagrad.</p>
<p>You never instantiate the Optimizer class itself, but instead instantiate one of the subclasses.</p>
<hr />
<h3 id="class-tf.train.optimizer"><a name="//apple_ref/cpp/Class/Optimizer" class="dashAnchor"></a><code id="Optimizer">class tf.train.Optimizer</code></h3>
<p>Base class for optimizers.</p>
<p>This class defines the API to add Ops to train a model. You never use this class directly, but instead instantiate one of its subclasses such as <code>GradientDescentOptimizer</code>, <code>AdagradOptimizer</code>, or <code>MomentumOptimizer</code>.</p>
<h3 id="usage">Usage</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Create an optimizer with the desired parameters.</span>
opt <span class="op">=</span> GradientDescentOptimizer(learning_rate<span class="op">=</span><span class="fl">0.1</span>)
<span class="co"># Add Ops to the graph to minimize a cost by updating a list of variables.</span>
<span class="co"># &quot;cost&quot; is a Tensor, and the list of variables contains tf.Variable</span>
<span class="co"># objects.</span>
opt_op <span class="op">=</span> opt.minimize(cost, var_list<span class="op">=&lt;</span><span class="bu">list</span> of variables<span class="op">&gt;</span>)</code></pre></div>
<p>In the training program you will just have to run the returned Op.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Execute opt_op to do one step of training:</span>
opt_op.run()</code></pre></div>
<h3 id="processing-gradients-before-applying-them.">Processing gradients before applying them.</h3>
<p>Calling <code>minimize()</code> takes care of both computing the gradients and applying them to the variables. If you want to process the gradients before applying them you can instead use the optimizer in three steps:</p>
<ol style="list-style-type: decimal">
<li>Compute the gradients with <code>compute_gradients()</code>.</li>
<li>Process the gradients as you wish.</li>
<li>Apply the processed gradients with <code>apply_gradients()</code>.</li>
</ol>
<p>Example:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Create an optimizer.</span>
opt <span class="op">=</span> GradientDescentOptimizer(learning_rate<span class="op">=</span><span class="fl">0.1</span>)

<span class="co"># Compute the gradients for a list of variables.</span>
grads_and_vars <span class="op">=</span> opt.compute_gradients(loss, <span class="op">&lt;</span><span class="bu">list</span> of variables<span class="op">&gt;</span>)

<span class="co"># grads_and_vars is a list of tuples (gradient, variable).  Do whatever you</span>
<span class="co"># need to the &#39;gradient&#39; part, for example cap them, etc.</span>
capped_grads_and_vars <span class="op">=</span> [(MyCapper(gv[<span class="dv">0</span>]), gv[<span class="dv">1</span>]) <span class="cf">for</span> gv <span class="op">in</span> grads_and_vars]

<span class="co"># Ask the optimizer to apply the capped gradients.</span>
opt.apply_gradients(capped_grads_and_vars)</code></pre></div>
<hr />
<h4 id="tf.train.optimizer.__init__use_locking-name"><code id="Optimizer.__init__">tf.train.Optimizer.__init__(use_locking, name)</code></h4>
<p>Create a new Optimizer.</p>
<p>This must be called by the constructors of subclasses.</p>
<h5 id="args">Args:</h5>
<ul>
<li><b><code>use_locking</code></b>: Bool. If True apply use locks to prevent concurrent updates to variables.</li>
<li><b><code>name</code></b>: A non-empty string. The name to use for accumulators created for the optimizer.</li>
</ul>
<h5 id="raises">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If name is malformed.</li>
</ul>
<hr />
<h4 id="tf.train.optimizer.minimizeloss-global_stepnone-var_listnone-gate_gradients1-aggregation_methodnone-colocate_gradients_with_opsfalse-namenone-grad_lossnone"><code id="Optimizer.minimize">tf.train.Optimizer.minimize(loss, global_step=None, var_list=None, gate_gradients=1, aggregation_method=None, colocate_gradients_with_ops=False, name=None, grad_loss=None)</code></h4>
<p>Add operations to minimize <code>loss</code> by updating <code>var_list</code>.</p>
<p>This method simply combines calls <code>compute_gradients()</code> and <code>apply_gradients()</code>. If you want to process the gradient before applying them call <code>compute_gradients()</code> and <code>apply_gradients()</code> explicitly instead of using this function.</p>
<h5 id="args-1">Args:</h5>
<ul>
<li><b><code>loss</code></b>: A <code>Tensor</code> containing the value to minimize.</li>
<li><b><code>global_step</code></b>: Optional <code>Variable</code> to increment by one after the variables have been updated.</li>
<li><b><code>var_list</code></b>: Optional list of <code>Variable</code> objects to update to minimize <code>loss</code>. Defaults to the list of variables collected in the graph under the key <code>GraphKeys.TRAINABLE_VARIABLES</code>.</li>
<li><b><code>gate_gradients</code></b>: How to gate the computation of gradients. Can be <code>GATE_NONE</code>, <code>GATE_OP</code>, or <code>GATE_GRAPH</code>.</li>
<li><b><code>aggregation_method</code></b>: Specifies the method used to combine gradient terms. Valid values are defined in the class <code>AggregationMethod</code>.</li>
<li><b><code>colocate_gradients_with_ops</code></b>: If True, try colocating gradients with the corresponding op.</li>
<li><b><code>name</code></b>: Optional name for the returned operation.</li>
<li><b><code>grad_loss</code></b>: Optional. A <code>Tensor</code> holding the gradient computed for <code>loss</code>.</li>
</ul>
<h5 id="returns">Returns:</h5>
<p>An Operation that updates the variables in <code>var_list</code>. If <code>global_step</code> was not <code>None</code>, that operation also increments <code>global_step</code>.</p>
<h5 id="raises-1">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If some of the variables are not <code>Variable</code> objects.</li>
</ul>
<hr />
<h4 id="tf.train.optimizer.compute_gradientsloss-var_listnone-gate_gradients1-aggregation_methodnone-colocate_gradients_with_opsfalse-grad_lossnone"><code id="Optimizer.compute_gradients">tf.train.Optimizer.compute_gradients(loss, var_list=None, gate_gradients=1, aggregation_method=None, colocate_gradients_with_ops=False, grad_loss=None)</code></h4>
<p>Compute gradients of <code>loss</code> for the variables in <code>var_list</code>.</p>
<p>This is the first part of <code>minimize()</code>. It returns a list of (gradient, variable) pairs where &quot;gradient&quot; is the gradient for &quot;variable&quot;. Note that &quot;gradient&quot; can be a <code>Tensor</code>, an <code>IndexedSlices</code>, or <code>None</code> if there is no gradient for the given variable.</p>
<h5 id="args-2">Args:</h5>
<ul>
<li><b><code>loss</code></b>: A Tensor containing the value to minimize.</li>
<li><b><code>var_list</code></b>: Optional list of <code>tf.Variable</code> to update to minimize <code>loss</code>. Defaults to the list of variables collected in the graph under the key <code>GraphKey.TRAINABLE_VARIABLES</code>.</li>
<li><b><code>gate_gradients</code></b>: How to gate the computation of gradients. Can be <code>GATE_NONE</code>, <code>GATE_OP</code>, or <code>GATE_GRAPH</code>.</li>
<li><b><code>aggregation_method</code></b>: Specifies the method used to combine gradient terms. Valid values are defined in the class <code>AggregationMethod</code>.</li>
<li><b><code>colocate_gradients_with_ops</code></b>: If True, try colocating gradients with the corresponding op.</li>
<li><b><code>grad_loss</code></b>: Optional. A <code>Tensor</code> holding the gradient computed for <code>loss</code>.</li>
</ul>
<h5 id="returns-1">Returns:</h5>
<p>A list of (gradient, variable) pairs. Variable is always present, but gradient can be <code>None</code>.</p>
<h5 id="raises-2">Raises:</h5>
<ul>
<li><b><code>TypeError</code></b>: If <code>var_list</code> contains anything else than <code>Variable</code> objects.</li>
<li><b><code>ValueError</code></b>: If some arguments are invalid.</li>
</ul>
<hr />
<h4 id="tf.train.optimizer.apply_gradientsgrads_and_vars-global_stepnone-namenone"><code id="Optimizer.apply_gradients">tf.train.Optimizer.apply_gradients(grads_and_vars, global_step=None, name=None)</code></h4>
<p>Apply gradients to variables.</p>
<p>This is the second part of <code>minimize()</code>. It returns an <code>Operation</code> that applies gradients.</p>
<h5 id="args-3">Args:</h5>
<ul>
<li><b><code>grads_and_vars</code></b>: List of (gradient, variable) pairs as returned by <code>compute_gradients()</code>.</li>
<li><b><code>global_step</code></b>: Optional <code>Variable</code> to increment by one after the variables have been updated.</li>
<li><b><code>name</code></b>: Optional name for the returned operation. Default to the name passed to the <code>Optimizer</code> constructor.</li>
</ul>
<h5 id="returns-2">Returns:</h5>
<p>An <code>Operation</code> that applies the specified gradients. If <code>global_step</code> was not None, that operation also increments <code>global_step</code>.</p>
<h5 id="raises-3">Raises:</h5>
<ul>
<li><b><code>TypeError</code></b>: If <code>grads_and_vars</code> is malformed.</li>
<li><b><code>ValueError</code></b>: If none of the variables have gradients.</li>
</ul>
<h3 id="gating-gradients">Gating Gradients</h3>
<p>Both <code>minimize()</code> and <code>compute_gradients()</code> accept a <code>gate_gradients</code> argument that controls the degree of parallelism during the application of the gradients.</p>
<p>The possible values are: <code>GATE_NONE</code>, <code>GATE_OP</code>, and <code>GATE_GRAPH</code>.</p>
<p><b><code>GATE_NONE</code></b>: Compute and apply gradients in parallel. This provides the maximum parallelism in execution, at the cost of some non-reproducibility in the results. For example the two gradients of <code>matmul</code> depend on the input values: With <code>GATE_NONE</code> one of the gradients could be applied to one of the inputs <em>before</em> the other gradient is computed resulting in non-reproducible results.</p>
<p><b><code>GATE_OP</code></b>: For each Op, make sure all gradients are computed before they are used. This prevents race conditions for Ops that generate gradients for multiple inputs where the gradients depend on the inputs.</p>
<p><b><code>GATE_GRAPH</code></b>: Make sure all gradients for all variables are computed before any one of them is used. This provides the least parallelism but can be useful if you want to process all gradients before applying any of them.</p>
<h3 id="slots">Slots</h3>
<p>Some optimizer subclasses, such as <code>MomentumOptimizer</code> and <code>AdagradOptimizer</code> allocate and manage additional variables associated with the variables to train. These are called <i>Slots</i>. Slots have names and you can ask the optimizer for the names of the slots that it uses. Once you have a slot name you can ask the optimizer for the variable it created to hold the slot value.</p>
<p>This can be useful if you want to log debug a training algorithm, report stats about the slots, etc.</p>
<hr />
<h4 id="tf.train.optimizer.get_slot_names"><code id="Optimizer.get_slot_names">tf.train.Optimizer.get_slot_names()</code></h4>
<p>Return a list of the names of slots created by the <code>Optimizer</code>.</p>
<p>See <code>get_slot()</code>.</p>
<h5 id="returns-3">Returns:</h5>
<p>A list of strings.</p>
<hr />
<h4 id="tf.train.optimizer.get_slotvar-name"><code id="Optimizer.get_slot">tf.train.Optimizer.get_slot(var, name)</code></h4>
<p>Return a slot named <code>name</code> created for <code>var</code> by the Optimizer.</p>
<p>Some <code>Optimizer</code> subclasses use additional variables. For example <code>Momentum</code> and <code>Adagrad</code> use variables to accumulate updates. This method gives access to these <code>Variable</code> objects if for some reason you need them.</p>
<p>Use <code>get_slot_names()</code> to get the list of slot names created by the <code>Optimizer</code>.</p>
<h5 id="args-4">Args:</h5>
<ul>
<li><b><code>var</code></b>: A variable passed to <code>minimize()</code> or <code>apply_gradients()</code>.</li>
<li><b><code>name</code></b>: A string.</li>
</ul>
<h5 id="returns-4">Returns:</h5>
<p>The <code>Variable</code> for the slot if it was created, <code>None</code> otherwise.</p>
<h4 id="other-methods">Other Methods</h4>
<hr />
<h4 id="tf.train.optimizer.get_name"><code id="Optimizer.get_name">tf.train.Optimizer.get_name()</code></h4>
<hr />
<h3 id="class-tf.train.gradientdescentoptimizer"><a name="//apple_ref/cpp/Class/GradientDescentOptimizer" class="dashAnchor"></a><code id="GradientDescentOptimizer">class tf.train.GradientDescentOptimizer</code></h3>
<p>Optimizer that implements the gradient descent algorithm.</p>
<hr />
<h4 id="tf.train.gradientdescentoptimizer.__init__learning_rate-use_lockingfalse-namegradientdescent"><code id="GradientDescentOptimizer.__init__">tf.train.GradientDescentOptimizer.__init__(learning_rate, use_locking=False, name='GradientDescent')</code></h4>
<p>Construct a new gradient descent optimizer.</p>
<h5 id="args-5">Args:</h5>
<ul>
<li><b><code>learning_rate</code></b>: A Tensor or a floating point value. The learning rate to use.</li>
<li><b><code>use_locking</code></b>: If True use locks for update operations.</li>
<li><b><code>name</code></b>: Optional name prefix for the operations created when applying gradients. Defaults to &quot;GradientDescent&quot;.</li>
</ul>
<hr />
<h3 id="class-tf.train.adadeltaoptimizer"><a name="//apple_ref/cpp/Class/AdadeltaOptimizer" class="dashAnchor"></a><code id="AdadeltaOptimizer">class tf.train.AdadeltaOptimizer</code></h3>
<p>Optimizer that implements the Adadelta algorithm.</p>
<p>See <a href="http://arxiv.org/abs/1212.5701">M. D. Zeiler</a> (<a href="http://arxiv.org/pdf/1212.5701v1.pdf">pdf</a>)</p>
<hr />
<h4 id="tf.train.adadeltaoptimizer.__init__learning_rate0.001-rho0.95-epsilon1e-08-use_lockingfalse-nameadadelta"><code id="AdadeltaOptimizer.__init__">tf.train.AdadeltaOptimizer.__init__(learning_rate=0.001, rho=0.95, epsilon=1e-08, use_locking=False, name='Adadelta')</code></h4>
<p>Construct a new Adadelta optimizer.</p>
<h5 id="args-6">Args:</h5>
<ul>
<li><b><code>learning_rate</code></b>: A <code>Tensor</code> or a floating point value. The learning rate.</li>
<li><b><code>rho</code></b>: A <code>Tensor</code> or a floating point value. The decay rate.</li>
<li><b><code>epsilon</code></b>: A <code>Tensor</code> or a floating point value. A constant epsilon used to better conditioning the grad update.</li>
<li><b><code>use_locking</code></b>: If <code>True</code> use locks for update operations.</li>
<li><b><code>name</code></b>: Optional name prefix for the operations created when applying gradients. Defaults to &quot;Adadelta&quot;.</li>
</ul>
<hr />
<h3 id="class-tf.train.adagradoptimizer"><a name="//apple_ref/cpp/Class/AdagradOptimizer" class="dashAnchor"></a><code id="AdagradOptimizer">class tf.train.AdagradOptimizer</code></h3>
<p>Optimizer that implements the Adagrad algorithm.</p>
<p>See this <a href="http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf">paper</a>.</p>
<hr />
<h4 id="tf.train.adagradoptimizer.__init__learning_rate-initial_accumulator_value0.1-use_lockingfalse-nameadagrad"><code id="AdagradOptimizer.__init__">tf.train.AdagradOptimizer.__init__(learning_rate, initial_accumulator_value=0.1, use_locking=False, name='Adagrad')</code></h4>
<p>Construct a new Adagrad optimizer.</p>
<h5 id="args-7">Args:</h5>
<ul>
<li><b><code>learning_rate</code></b>: A <code>Tensor</code> or a floating point value. The learning rate.</li>
<li><b><code>initial_accumulator_value</code></b>: A floating point value. Starting value for the accumulators, must be positive.</li>
<li><b><code>use_locking</code></b>: If <code>True</code> use locks for update operations.</li>
<li><b><code>name</code></b>: Optional name prefix for the operations created when applying gradients. Defaults to &quot;Adagrad&quot;.</li>
</ul>
<h5 id="raises-4">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If the <code>initial_accumulator_value</code> is invalid.</li>
</ul>
<hr />
<h3 id="class-tf.train.adagraddaoptimizer"><a name="//apple_ref/cpp/Class/AdagradDAOptimizer" class="dashAnchor"></a><code id="AdagradDAOptimizer">class tf.train.AdagradDAOptimizer</code></h3>
<p>Adagrad Dual Averaging algorithm for sparse linear models.</p>
<p>See this <a href="http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf">paper</a>.</p>
<p>This optimizer takes care of regularization of unseen features in a mini batch by updating them when they are seen with a closed form update rule that is equivalent to having updated them on every mini-batch.</p>
<p>AdagradDA is typically used when there is a need for large sparsity in the trained model. This optimizer only guarantees sparsity for linear models. Be careful when using AdagradDA for deep networks as it will require careful initialization of the gradient accumulators for it to train.</p>
<hr />
<h4 id="tf.train.adagraddaoptimizer.__init__learning_rate-global_step-initial_gradient_squared_accumulator_value0.1-l1_regularization_strength0.0-l2_regularization_strength0.0-use_lockingfalse-nameadagradda"><code id="AdagradDAOptimizer.__init__">tf.train.AdagradDAOptimizer.__init__(learning_rate, global_step, initial_gradient_squared_accumulator_value=0.1, l1_regularization_strength=0.0, l2_regularization_strength=0.0, use_locking=False, name='AdagradDA')</code></h4>
<p>Construct a new AdagradDA optimizer.</p>
<h5 id="args-8">Args:</h5>
<ul>
<li><b><code>learning_rate</code></b>: A <code>Tensor</code> or a floating point value. The learning rate.</li>
<li><b><code>global_step</code></b>: A <code>Tensor</code> containing the current training step number.</li>
<li><b><code>initial_gradient_squared_accumulator_value</code></b>: A floating point value. Starting value for the accumulators, must be positive.</li>
<li><b><code>l1_regularization_strength</code></b>: A float value, must be greater than or equal to zero.</li>
<li><b><code>l2_regularization_strength</code></b>: A float value, must be greater than or equal to zero.</li>
<li><b><code>use_locking</code></b>: If <code>True</code> use locks for update operations.</li>
<li><b><code>name</code></b>: Optional name prefix for the operations created when applying gradients. Defaults to &quot;AdagradDA&quot;.</li>
</ul>
<h5 id="raises-5">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If the <code>initial_gradient_squared_accumulator_value</code> is invalid.</li>
</ul>
<hr />
<h3 id="class-tf.train.momentumoptimizer"><a name="//apple_ref/cpp/Class/MomentumOptimizer" class="dashAnchor"></a><code id="MomentumOptimizer">class tf.train.MomentumOptimizer</code></h3>
<p>Optimizer that implements the Momentum algorithm.</p>
<hr />
<h4 id="tf.train.momentumoptimizer.__init__learning_rate-momentum-use_lockingfalse-namemomentum-use_nesterovfalse"><code id="MomentumOptimizer.__init__">tf.train.MomentumOptimizer.__init__(learning_rate, momentum, use_locking=False, name='Momentum', use_nesterov=False)</code></h4>
<p>Construct a new Momentum optimizer.</p>
<h5 id="args-9">Args:</h5>
<ul>
<li><b><code>learning_rate</code></b>: A <code>Tensor</code> or a floating point value. The learning rate.</li>
<li><b><code>momentum</code></b>: A <code>Tensor</code> or a floating point value. The momentum.</li>
<li><b><code>use_locking</code></b>: If <code>True</code> use locks for update operations.</li>
<li><b><code>name</code></b>: Optional name prefix for the operations created when applying gradients. Defaults to &quot;Momentum&quot;.</li>
<li><b><code>use_nesterov</code></b>: If <code>True</code> use Nesterov Momentum. See [Sutskever et. al., 2013](</li>
<li><b><code>http</code></b>: //jmlr.org/proceedings/papers/v28/sutskever13.pdf)</li>
</ul>
<hr />
<h3 id="class-tf.train.adamoptimizer"><a name="//apple_ref/cpp/Class/AdamOptimizer" class="dashAnchor"></a><code id="AdamOptimizer">class tf.train.AdamOptimizer</code></h3>
<p>Optimizer that implements the Adam algorithm.</p>
<p>See <a href="http://arxiv.org/abs/1412.6980">Kingma et. al., 2014</a> (<a href="http://arxiv.org/pdf/1412.6980.pdf">pdf</a>).</p>
<hr />
<h4 id="tf.train.adamoptimizer.__init__learning_rate0.001-beta10.9-beta20.999-epsilon1e-08-use_lockingfalse-nameadam"><code id="AdamOptimizer.__init__">tf.train.AdamOptimizer.__init__(learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-08, use_locking=False, name='Adam')</code></h4>
<p>Construct a new Adam optimizer.</p>
<p>Initialization:</p>
<pre><code>m_0 &lt;- 0 (Initialize initial 1st moment vector)
v_0 &lt;- 0 (Initialize initial 2nd moment vector)
t &lt;- 0 (Initialize timestep)</code></pre>
<p>The update rule for <code>variable</code> with gradient <code>g</code> uses an optimization described at the end of section2 of the paper:</p>
<pre><code>t &lt;- t + 1
lr_t &lt;- learning_rate * sqrt(1 - beta2^t) / (1 - beta1^t)

m_t &lt;- beta1 * m_{t-1} + (1 - beta1) * g
v_t &lt;- beta2 * v_{t-1} + (1 - beta2) * g * g
variable &lt;- variable - lr_t * m_t / (sqrt(v_t) + epsilon)</code></pre>
<p>The default value of 1e-8 for epsilon might not be a good default in general. For example, when training an Inception network on ImageNet a current good choice is 1.0 or 0.1.</p>
<p>Note that in dense implement of this algorithm, m_t, v_t and variable will update even if g is zero, but in sparse implement, m_t, v_t and variable will not update in iterations g is zero.</p>
<h5 id="args-10">Args:</h5>
<ul>
<li><b><code>learning_rate</code></b>: A Tensor or a floating point value. The learning rate.</li>
<li><b><code>beta1</code></b>: A float value or a constant float tensor. The exponential decay rate for the 1st moment estimates.</li>
<li><b><code>beta2</code></b>: A float value or a constant float tensor. The exponential decay rate for the 2nd moment estimates.</li>
<li><b><code>epsilon</code></b>: A small constant for numerical stability.</li>
<li><b><code>use_locking</code></b>: If True use locks for update operations.</li>
<li><b><code>name</code></b>: Optional name for the operations created when applying gradients. Defaults to &quot;Adam&quot;.</li>
</ul>
<hr />
<h3 id="class-tf.train.ftrloptimizer"><a name="//apple_ref/cpp/Class/FtrlOptimizer" class="dashAnchor"></a><code id="FtrlOptimizer">class tf.train.FtrlOptimizer</code></h3>
<p>Optimizer that implements the FTRL algorithm.</p>
<p>See this <a href="https://www.eecs.tufts.edu/~dsculley/papers/ad-click-prediction.pdf">paper</a>.</p>
<hr />
<h4 id="tf.train.ftrloptimizer.__init__learning_rate-learning_rate_power-0.5-initial_accumulator_value0.1-l1_regularization_strength0.0-l2_regularization_strength0.0-use_lockingfalse-nameftrl"><code id="FtrlOptimizer.__init__">tf.train.FtrlOptimizer.__init__(learning_rate, learning_rate_power=-0.5, initial_accumulator_value=0.1, l1_regularization_strength=0.0, l2_regularization_strength=0.0, use_locking=False, name='Ftrl')</code></h4>
<p>Construct a new FTRL optimizer.</p>
<h5 id="args-11">Args:</h5>
<ul>
<li><b><code>learning_rate</code></b>: A float value or a constant float <code>Tensor</code>.</li>
<li><b><code>learning_rate_power</code></b>: A float value, must be less or equal to zero.</li>
<li><b><code>initial_accumulator_value</code></b>: The starting value for accumulators. Only positive values are allowed.</li>
<li><b><code>l1_regularization_strength</code></b>: A float value, must be greater than or equal to zero.</li>
<li><b><code>l2_regularization_strength</code></b>: A float value, must be greater than or equal to zero.</li>
<li><b><code>use_locking</code></b>: If <code>True</code> use locks for update operations.</li>
<li><b><code>name</code></b>: Optional name prefix for the operations created when applying gradients. Defaults to &quot;Ftrl&quot;.</li>
</ul>
<h5 id="raises-6">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If one of the arguments is invalid.</li>
</ul>
<hr />
<h3 id="class-tf.train.proximalgradientdescentoptimizer"><a name="//apple_ref/cpp/Class/ProximalGradientDescentOptimizer" class="dashAnchor"></a><code id="ProximalGradientDescentOptimizer">class tf.train.ProximalGradientDescentOptimizer</code></h3>
<p>Optimizer that implements the proximal gradient descent algorithm.</p>
<p>See this <a href="http://papers.nips.cc/paper/3793-efficient-learning-using-forward-backward-splitting.pdf">paper</a>.</p>
<hr />
<h4 id="tf.train.proximalgradientdescentoptimizer.__init__learning_rate-l1_regularization_strength0.0-l2_regularization_strength0.0-use_lockingfalse-nameproximalgradientdescent"><code id="ProximalGradientDescentOptimizer.__init__">tf.train.ProximalGradientDescentOptimizer.__init__(learning_rate, l1_regularization_strength=0.0, l2_regularization_strength=0.0, use_locking=False, name='ProximalGradientDescent')</code></h4>
<p>Construct a new proximal gradient descent optimizer.</p>
<h5 id="args-12">Args:</h5>
<ul>
<li><b><code>learning_rate</code></b>: A Tensor or a floating point value. The learning rate to use.</li>
<li><b><code>l1_regularization_strength</code></b>: A float value, must be greater than or equal to zero.</li>
<li><b><code>l2_regularization_strength</code></b>: A float value, must be greater than or equal to zero.</li>
<li><b><code>use_locking</code></b>: If True use locks for update operations.</li>
<li><b><code>name</code></b>: Optional name prefix for the operations created when applying gradients. Defaults to &quot;GradientDescent&quot;.</li>
</ul>
<hr />
<h3 id="class-tf.train.proximaladagradoptimizer"><a name="//apple_ref/cpp/Class/ProximalAdagradOptimizer" class="dashAnchor"></a><code id="ProximalAdagradOptimizer">class tf.train.ProximalAdagradOptimizer</code></h3>
<p>Optimizer that implements the Proximal Adagrad algorithm.</p>
<p>See this <a href="http://papers.nips.cc/paper/3793-efficient-learning-using-forward-backward-splitting.pdf">paper</a>.</p>
<hr />
<h4 id="tf.train.proximaladagradoptimizer.__init__learning_rate-initial_accumulator_value0.1-l1_regularization_strength0.0-l2_regularization_strength0.0-use_lockingfalse-nameproximaladagrad"><code id="ProximalAdagradOptimizer.__init__">tf.train.ProximalAdagradOptimizer.__init__(learning_rate, initial_accumulator_value=0.1, l1_regularization_strength=0.0, l2_regularization_strength=0.0, use_locking=False, name='ProximalAdagrad')</code></h4>
<p>Construct a new ProximalAdagrad optimizer.</p>
<h5 id="args-13">Args:</h5>
<ul>
<li><b><code>learning_rate</code></b>: A <code>Tensor</code> or a floating point value. The learning rate.</li>
<li><b><code>initial_accumulator_value</code></b>: A floating point value. Starting value for the accumulators, must be positive.</li>
<li><b><code>l1_regularization_strength</code></b>: A float value, must be greater than or equal to zero.</li>
<li><b><code>l2_regularization_strength</code></b>: A float value, must be greater than or equal to zero.</li>
<li><b><code>use_locking</code></b>: If <code>True</code> use locks for update operations.</li>
<li><b><code>name</code></b>: Optional name prefix for the operations created when applying gradients. Defaults to &quot;Adagrad&quot;.</li>
</ul>
<h5 id="raises-7">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If the <code>initial_accumulator_value</code> is invalid.</li>
</ul>
<hr />
<h3 id="class-tf.train.rmspropoptimizer"><a name="//apple_ref/cpp/Class/RMSPropOptimizer" class="dashAnchor"></a><code id="RMSPropOptimizer">class tf.train.RMSPropOptimizer</code></h3>
<p>Optimizer that implements the RMSProp algorithm.</p>
<p>See the <a href="http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf">paper</a>.</p>
<hr />
<h4 id="tf.train.rmspropoptimizer.__init__learning_rate-decay0.9-momentum0.0-epsilon1e-10-use_lockingfalse-centeredfalse-namermsprop"><code id="RMSPropOptimizer.__init__">tf.train.RMSPropOptimizer.__init__(learning_rate, decay=0.9, momentum=0.0, epsilon=1e-10, use_locking=False, centered=False, name='RMSProp')</code></h4>
<p>Construct a new RMSProp optimizer.</p>
<p>Note that in dense implement of this algorithm, m_t and v_t will update even if g is zero, but in sparse implement, m_t and v_t will not update in iterations g is zero.</p>
<h5 id="args-14">Args:</h5>
<ul>
<li><b><code>learning_rate</code></b>: A Tensor or a floating point value. The learning rate.</li>
<li><b><code>decay</code></b>: Discounting factor for the history/coming gradient</li>
<li><b><code>momentum</code></b>: A scalar tensor.</li>
<li><b><code>epsilon</code></b>: Small value to avoid zero denominator.</li>
<li><b><code>use_locking</code></b>: If True use locks for update operation.</li>
<li><b><code>centered</code></b>: If True, gradients are normalized by the estimated variance of the gradient; if False, by the uncentered second moment. Setting this to True may help with training, but is slightly more expensive in terms of computation and memory. Defaults to False.</li>
<li><b><code>name</code></b>: Optional name prefix for the operations created when applying gradients. Defaults to &quot;RMSProp&quot;.</li>
</ul>
<h2 id="gradient-computation">Gradient Computation</h2>
<p>TensorFlow provides functions to compute the derivatives for a given TensorFlow computation graph, adding operations to the graph. The optimizer classes automatically compute derivatives on your graph, but creators of new Optimizers or expert users can call the lower-level functions below.</p>
<hr />
<h3 id="tf.gradientsys-xs-grad_ysnone-namegradients-colocate_gradients_with_opsfalse-gate_gradientsfalse-aggregation_methodnone"><a name="//apple_ref/cpp/Function/gradients" class="dashAnchor"></a><code id="gradients">tf.gradients(ys, xs, grad_ys=None, name='gradients', colocate_gradients_with_ops=False, gate_gradients=False, aggregation_method=None)</code></h3>
<p>Constructs symbolic partial derivatives of sum of <code>ys</code> w.r.t. x in <code>xs</code>.</p>
<p><code>ys</code> and <code>xs</code> are each a <code>Tensor</code> or a list of tensors. <code>grad_ys</code> is a list of <code>Tensor</code>, holding the gradients received by the <code>ys</code>. The list must be the same length as <code>ys</code>.</p>
<p><code>gradients()</code> adds ops to the graph to output the partial derivatives of <code>ys</code> with respect to <code>xs</code>. It returns a list of <code>Tensor</code> of length <code>len(xs)</code> where each tensor is the <code>sum(dy/dx)</code> for y in <code>ys</code>.</p>
<p><code>grad_ys</code> is a list of tensors of the same length as <code>ys</code> that holds the initial gradients for each y in <code>ys</code>. When <code>grad_ys</code> is None, we fill in a tensor of '1's of the shape of y for each y in <code>ys</code>. A user can provide their own initial <code>grad_ys</code> to compute the derivatives using a different initial gradient for each y (e.g., if one wanted to weight the gradient differently for each value in each y).</p>
<h5 id="args-15">Args:</h5>
<ul>
<li><b><code>ys</code></b>: A <code>Tensor</code> or list of tensors to be differentiated.</li>
<li><b><code>xs</code></b>: A <code>Tensor</code> or list of tensors to be used for differentiation.</li>
<li><b><code>grad_ys</code></b>: Optional. A <code>Tensor</code> or list of tensors the same size as <code>ys</code> and holding the gradients computed for each y in <code>ys</code>.</li>
<li><b><code>name</code></b>: Optional name to use for grouping all the gradient ops together. defaults to 'gradients'.</li>
<li><b><code>colocate_gradients_with_ops</code></b>: If True, try colocating gradients with the corresponding op.</li>
<li><b><code>gate_gradients</code></b>: If True, add a tuple around the gradients returned for an operations. This avoids some race conditions.</li>
<li><b><code>aggregation_method</code></b>: Specifies the method used to combine gradient terms. Accepted values are constants defined in the class <code>AggregationMethod</code>.</li>
</ul>
<h5 id="returns-5">Returns:</h5>
<p>A list of <code>sum(dy/dx)</code> for each x in <code>xs</code>.</p>
<h5 id="raises-8">Raises:</h5>
<ul>
<li><b><code>LookupError</code></b>: if one of the operations between <code>x</code> and <code>y</code> does not have a registered gradient function.</li>
<li><b><code>ValueError</code></b>: if the arguments are invalid.</li>
</ul>
<hr />
<h3 id="class-tf.aggregationmethod"><a name="//apple_ref/cpp/Class/AggregationMethod" class="dashAnchor"></a><code id="AggregationMethod">class tf.AggregationMethod</code></h3>
<p>A class listing aggregation methods used to combine gradients.</p>
<p>Computing partial derivatives can require aggregating gradient contributions. This class lists the various methods that can be used to combine gradients in the graph:</p>
<ul>
<li><code>ADD_N</code>: All of the gradient terms are summed as part of one operation using the &quot;AddN&quot; op. It has the property that all gradients must be ready before any aggregation is performed.</li>
<li><code>DEFAULT</code>: The system-chosen default aggregation method.</li>
</ul>
<hr />
<h3 id="tf.stop_gradientinput-namenone"><a name="//apple_ref/cpp/Function/stop_gradient" class="dashAnchor"></a><code id="stop_gradient">tf.stop_gradient(input, name=None)</code></h3>
<p>Stops gradient computation.</p>
<p>When executed in a graph, this op outputs its input tensor as-is.</p>
<p>When building ops to compute gradients, this op prevents the contribution of its inputs to be taken into account. Normally, the gradient generator adds ops to a graph to compute the derivatives of a specified 'loss' by recursively finding out inputs that contributed to its computation. If you insert this op in the graph it inputs are masked from the gradient generator. They are not taken into account for computing gradients.</p>
<p>This is useful any time you want to compute a value with TensorFlow but need to pretend that the value was a constant. Some examples include:</p>
<ul>
<li>The <em>EM</em> algorithm where the <em>M-step</em> should not involve backpropagation through the output of the <em>E-step</em>.</li>
<li>Contrastive divergence training of Boltzmann machines where, when differentiating the energy function, the training must not backpropagate through the graph that generated the samples from the model.</li>
<li>Adversarial training, where no backprop should happen through the adversarial example generation process.</li>
</ul>
<h5 id="args-16">Args:</h5>
<ul>
<li><b><code>input</code></b>: A <code>Tensor</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-6">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>input</code>.</p>
<hr />
<h3 id="tf.hessiansys-xs-namehessians-colocate_gradients_with_opsfalse-gate_gradientsfalse-aggregation_methodnone"><a name="//apple_ref/cpp/Function/hessians" class="dashAnchor"></a><code id="hessians">tf.hessians(ys, xs, name='hessians', colocate_gradients_with_ops=False, gate_gradients=False, aggregation_method=None)</code></h3>
<p>Constructs the Hessian of sum of <code>ys</code> with respect to <code>x</code> in <code>xs</code>.</p>
<p><code>hessians()</code> adds ops to the graph to output the Hessian matrix of <code>ys</code> with respect to <code>xs</code>. It returns a list of <code>Tensor</code> of length <code>len(xs)</code> where each tensor is the Hessian of <code>sum(ys)</code>. This function currently only supports evaluating the Hessian with respect to (a list of) one- dimensional tensors.</p>
<p>The Hessian is a matrix of second-order partial derivatives of a scalar tensor (see https://en.wikipedia.org/wiki/Hessian_matrix for more details).</p>
<h5 id="args-17">Args:</h5>
<ul>
<li><b><code>ys</code></b>: A <code>Tensor</code> or list of tensors to be differentiated.</li>
<li><b><code>xs</code></b>: A <code>Tensor</code> or list of tensors to be used for differentiation.</li>
<li><b><code>name</code></b>: Optional name to use for grouping all the gradient ops together. defaults to 'hessians'.</li>
<li><b><code>colocate_gradients_with_ops</code></b>: See <code>gradients()</code> documentation for details.</li>
<li><b><code>gate_gradients</code></b>: See <code>gradients()</code> documentation for details.</li>
<li><b><code>aggregation_method</code></b>: See <code>gradients()</code> documentation for details.</li>
</ul>
<h5 id="returns-7">Returns:</h5>
<p>A list of Hessian matrices of <code>sum(y)</code> for each <code>x</code> in <code>xs</code>.</p>
<h5 id="raises-9">Raises:</h5>
<ul>
<li><b><code>LookupError</code></b>: if one of the operations between <code>xs</code> and <code>ys</code> does not have a registered gradient function.</li>
<li><b><code>ValueError</code></b>: if the arguments are invalid or not supported. Currently, this function only supports one-dimensional <code>x</code> in <code>xs</code>.</li>
</ul>
<h2 id="gradient-clipping">Gradient Clipping</h2>
<p>TensorFlow provides several operations that you can use to add clipping functions to your graph. You can use these functions to perform general data clipping, but they're particularly useful for handling exploding or vanishing gradients.</p>
<hr />
<h3 id="tf.clip_by_valuet-clip_value_min-clip_value_max-namenone"><a name="//apple_ref/cpp/Function/clip_by_value" class="dashAnchor"></a><code id="clip_by_value">tf.clip_by_value(t, clip_value_min, clip_value_max, name=None)</code></h3>
<p>Clips tensor values to a specified min and max.</p>
<p>Given a tensor <code>t</code>, this operation returns a tensor of the same type and shape as <code>t</code> with its values clipped to <code>clip_value_min</code> and <code>clip_value_max</code>. Any values less than <code>clip_value_min</code> are set to <code>clip_value_min</code>. Any values greater than <code>clip_value_max</code> are set to <code>clip_value_max</code>.</p>
<h5 id="args-18">Args:</h5>
<ul>
<li><b><code>t</code></b>: A <code>Tensor</code>.</li>
<li><b><code>clip_value_min</code></b>: A 0-D (scalar) <code>Tensor</code>. The minimum value to clip by.</li>
<li><b><code>clip_value_max</code></b>: A 0-D (scalar) <code>Tensor</code>. The maximum value to clip by.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-8">Returns:</h5>
<p>A clipped <code>Tensor</code>.</p>
<hr />
<h3 id="tf.clip_by_normt-clip_norm-axesnone-namenone"><a name="//apple_ref/cpp/Function/clip_by_norm" class="dashAnchor"></a><code id="clip_by_norm">tf.clip_by_norm(t, clip_norm, axes=None, name=None)</code></h3>
<p>Clips tensor values to a maximum L2-norm.</p>
<p>Given a tensor <code>t</code>, and a maximum clip value <code>clip_norm</code>, this operation normalizes <code>t</code> so that its L2-norm is less than or equal to <code>clip_norm</code>, along the dimensions given in <code>axes</code>. Specifically, in the default case where all dimensions are used for calculation, if the L2-norm of <code>t</code> is already less than or equal to <code>clip_norm</code>, then <code>t</code> is not modified. If the L2-norm is greater than <code>clip_norm</code>, then this operation returns a tensor of the same type and shape as <code>t</code> with its values set to:</p>
<p><code>t * clip_norm / l2norm(t)</code></p>
<p>In this case, the L2-norm of the output tensor is <code>clip_norm</code>.</p>
<p>As another example, if <code>t</code> is a matrix and <code>axes == [1]</code>, then each row of the output will have L2-norm equal to <code>clip_norm</code>. If <code>axes == [0]</code> instead, each column of the output will be clipped.</p>
<p>This operation is typically used to clip gradients before applying them with an optimizer.</p>
<h5 id="args-19">Args:</h5>
<ul>
<li><b><code>t</code></b>: A <code>Tensor</code>.</li>
<li><b><code>clip_norm</code></b>: A 0-D (scalar) <code>Tensor</code> &gt; 0. A maximum clipping value.</li>
<li><b><code>axes</code></b>: A 1-D (vector) <code>Tensor</code> of type int32 containing the dimensions to use for computing the L2-norm. If <code>None</code> (the default), uses all dimensions.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-9">Returns:</h5>
<p>A clipped <code>Tensor</code>.</p>
<hr />
<h3 id="tf.clip_by_average_normt-clip_norm-namenone"><a name="//apple_ref/cpp/Function/clip_by_average_norm" class="dashAnchor"></a><code id="clip_by_average_norm">tf.clip_by_average_norm(t, clip_norm, name=None)</code></h3>
<p>Clips tensor values to a maximum average L2-norm.</p>
<p>Given a tensor <code>t</code>, and a maximum clip value <code>clip_norm</code>, this operation normalizes <code>t</code> so that its average L2-norm is less than or equal to <code>clip_norm</code>. Specifically, if the average L2-norm is already less than or equal to <code>clip_norm</code>, then <code>t</code> is not modified. If the average L2-norm is greater than <code>clip_norm</code>, then this operation returns a tensor of the same type and shape as <code>t</code> with its values set to:</p>
<p><code>t * clip_norm / l2norm_avg(t)</code></p>
<p>In this case, the average L2-norm of the output tensor is <code>clip_norm</code>.</p>
<p>This operation is typically used to clip gradients before applying them with an optimizer.</p>
<h5 id="args-20">Args:</h5>
<ul>
<li><b><code>t</code></b>: A <code>Tensor</code>.</li>
<li><b><code>clip_norm</code></b>: A 0-D (scalar) <code>Tensor</code> &gt; 0. A maximum clipping value.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-10">Returns:</h5>
<p>A clipped <code>Tensor</code>.</p>
<hr />
<h3 id="tf.clip_by_global_normt_list-clip_norm-use_normnone-namenone"><a name="//apple_ref/cpp/Function/clip_by_global_norm" class="dashAnchor"></a><code id="clip_by_global_norm">tf.clip_by_global_norm(t_list, clip_norm, use_norm=None, name=None)</code></h3>
<p>Clips values of multiple tensors by the ratio of the sum of their norms.</p>
<p>Given a tuple or list of tensors <code>t_list</code>, and a clipping ratio <code>clip_norm</code>, this operation returns a list of clipped tensors <code>list_clipped</code> and the global norm (<code>global_norm</code>) of all tensors in <code>t_list</code>. Optionally, if you've already computed the global norm for <code>t_list</code>, you can specify the global norm with <code>use_norm</code>.</p>
<p>To perform the clipping, the values <code>t_list[i]</code> are set to:</p>
<pre><code>t_list[i] * clip_norm / max(global_norm, clip_norm)</code></pre>
<p>where:</p>
<pre><code>global_norm = sqrt(sum([l2norm(t)**2 for t in t_list]))</code></pre>
<p>If <code>clip_norm &gt; global_norm</code> then the entries in <code>t_list</code> remain as they are, otherwise they're all shrunk by the global ratio.</p>
<p>Any of the entries of <code>t_list</code> that are of type <code>None</code> are ignored.</p>
<p>This is the correct way to perform gradient clipping (for example, see <a href="http://arxiv.org/abs/1211.5063">Pascanu et al., 2012</a> (<a href="http://arxiv.org/pdf/1211.5063.pdf">pdf</a>)).</p>
<p>However, it is slower than <code>clip_by_norm()</code> because all the parameters must be ready before the clipping operation can be performed.</p>
<h5 id="args-21">Args:</h5>
<ul>
<li><b><code>t_list</code></b>: A tuple or list of mixed <code>Tensors</code>, <code>IndexedSlices</code>, or None.</li>
<li><b><code>clip_norm</code></b>: A 0-D (scalar) <code>Tensor</code> &gt; 0. The clipping ratio.</li>
<li><b><code>use_norm</code></b>: A 0-D (scalar) <code>Tensor</code> of type <code>float</code> (optional). The global norm to use. If not provided, <code>global_norm()</code> is used to compute the norm.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-11">Returns:</h5>
<ul>
<li><b><code>list_clipped</code></b>: A list of <code>Tensors</code> of the same type as <code>list_t</code>.</li>
<li><b><code>global_norm</code></b>: A 0-D (scalar) <code>Tensor</code> representing the global norm.</li>
</ul>
<h5 id="raises-10">Raises:</h5>
<ul>
<li><b><code>TypeError</code></b>: If <code>t_list</code> is not a sequence.</li>
</ul>
<hr />
<h3 id="tf.global_normt_list-namenone"><a name="//apple_ref/cpp/Function/global_norm" class="dashAnchor"></a><code id="global_norm">tf.global_norm(t_list, name=None)</code></h3>
<p>Computes the global norm of multiple tensors.</p>
<p>Given a tuple or list of tensors <code>t_list</code>, this operation returns the global norm of the elements in all tensors in <code>t_list</code>. The global norm is computed as:</p>
<p><code>global_norm = sqrt(sum([l2norm(t)**2 for t in t_list]))</code></p>
<p>Any entries in <code>t_list</code> that are of type None are ignored.</p>
<h5 id="args-22">Args:</h5>
<ul>
<li><b><code>t_list</code></b>: A tuple or list of mixed <code>Tensors</code>, <code>IndexedSlices</code>, or None.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-12">Returns:</h5>
<p>A 0-D (scalar) <code>Tensor</code> of type <code>float</code>.</p>
<h5 id="raises-11">Raises:</h5>
<ul>
<li><b><code>TypeError</code></b>: If <code>t_list</code> is not a sequence.</li>
</ul>
<h2 id="decaying-the-learning-rate">Decaying the learning rate</h2>
<hr />
<h3 id="tf.train.exponential_decaylearning_rate-global_step-decay_steps-decay_rate-staircasefalse-namenone"><a name="//apple_ref/cpp/Function/exponential_decay" class="dashAnchor"></a><code id="exponential_decay">tf.train.exponential_decay(learning_rate, global_step, decay_steps, decay_rate, staircase=False, name=None)</code></h3>
<p>Applies exponential decay to the learning rate.</p>
<p>When training a model, it is often recommended to lower the learning rate as the training progresses. This function applies an exponential decay function to a provided initial learning rate. It requires a <code>global_step</code> value to compute the decayed learning rate. You can just pass a TensorFlow variable that you increment at each training step.</p>
<p>The function returns the decayed learning rate. It is computed as:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">decayed_learning_rate <span class="op">=</span> learning_rate <span class="op">*</span>
                        decay_rate <span class="op">^</span> (global_step <span class="op">/</span> decay_steps)</code></pre></div>
<p>If the argument <code>staircase</code> is <code>True</code>, then <code>global_step / decay_steps</code> is an integer division and the decayed learning rate follows a staircase function.</p>
<p>Example: decay every 100000 steps with a base of 0.96:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">...
global_step <span class="op">=</span> tf.Variable(<span class="dv">0</span>, trainable<span class="op">=</span><span class="va">False</span>)
starter_learning_rate <span class="op">=</span> <span class="fl">0.1</span>
learning_rate <span class="op">=</span> tf.train.exponential_decay(starter_learning_rate, global_step,
                                           <span class="dv">100000</span>, <span class="fl">0.96</span>, staircase<span class="op">=</span><span class="va">True</span>)
<span class="co"># Passing global_step to minimize() will increment it at each step.</span>
learning_step <span class="op">=</span> (
    tf.train.GradientDescentOptimizer(learning_rate)
    .minimize(...my loss..., global_step<span class="op">=</span>global_step)
)</code></pre></div>
<h5 id="args-23">Args:</h5>
<ul>
<li><b><code>learning_rate</code></b>: A scalar <code>float32</code> or <code>float64</code> <code>Tensor</code> or a Python number. The initial learning rate.</li>
<li><b><code>global_step</code></b>: A scalar <code>int32</code> or <code>int64</code> <code>Tensor</code> or a Python number. Global step to use for the decay computation. Must not be negative.</li>
<li><b><code>decay_steps</code></b>: A scalar <code>int32</code> or <code>int64</code> <code>Tensor</code> or a Python number. Must be positive. See the decay computation above.</li>
<li><b><code>decay_rate</code></b>: A scalar <code>float32</code> or <code>float64</code> <code>Tensor</code> or a Python number. The decay rate.</li>
<li><b><code>staircase</code></b>: Boolean. If <code>True</code> decay the learning rate at discrete intervals</li>
<li><b><code>name</code></b>: String. Optional name of the operation. Defaults to 'ExponentialDecay'.</li>
</ul>
<h5 id="returns-13">Returns:</h5>
<p>A scalar <code>Tensor</code> of the same type as <code>learning_rate</code>. The decayed learning rate.</p>
<h5 id="raises-12">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: if <code>global_step</code> is not supplied.</li>
</ul>
<hr />
<h3 id="tf.train.inverse_time_decaylearning_rate-global_step-decay_steps-decay_rate-staircasefalse-namenone"><a name="//apple_ref/cpp/Function/inverse_time_decay" class="dashAnchor"></a><code id="inverse_time_decay">tf.train.inverse_time_decay(learning_rate, global_step, decay_steps, decay_rate, staircase=False, name=None)</code></h3>
<p>Applies inverse time decay to the initial learning rate.</p>
<p>When training a model, it is often recommended to lower the learning rate as the training progresses. This function applies an inverse decay function to a provided initial learning rate. It requires an <code>global_step</code> value to compute the decayed learning rate. You can just pass a TensorFlow variable that you increment at each training step.</p>
<p>The function returns the decayed learning rate. It is computed as:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">decayed_learning_rate <span class="op">=</span> learning_rate <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> decay_rate <span class="op">*</span> t)</code></pre></div>
<p>Example: decay 1/t with a rate of 0.5:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">...
global_step <span class="op">=</span> tf.Variable(<span class="dv">0</span>, trainable<span class="op">=</span><span class="va">False</span>)
learning_rate <span class="op">=</span> <span class="fl">0.1</span>
k <span class="op">=</span> <span class="fl">0.5</span>
learning_rate <span class="op">=</span> tf.train.inverse_time_decay(learning_rate, global_step, k)

<span class="co"># Passing global_step to minimize() will increment it at each step.</span>
learning_step <span class="op">=</span> (
    tf.train.GradientDescentOptimizer(learning_rate)
    .minimize(...my loss..., global_step<span class="op">=</span>global_step)
)</code></pre></div>
<h5 id="args-24">Args:</h5>
<ul>
<li><b><code>learning_rate</code></b>: A scalar <code>float32</code> or <code>float64</code> <code>Tensor</code> or a Python number. The initial learning rate.</li>
<li><b><code>global_step</code></b>: A Python number. Global step to use for the decay computation. Must not be negative.</li>
<li><b><code>decay_steps</code></b>: How often to apply decay.</li>
<li><b><code>decay_rate</code></b>: A Python number. The decay rate.</li>
<li><b><code>staircase</code></b>: Whether to apply decay in a discrete staircase, as opposed to continuous, fashion.</li>
<li><b><code>name</code></b>: String. Optional name of the operation. Defaults to 'InverseTimeDecay'.</li>
</ul>
<h5 id="returns-14">Returns:</h5>
<p>A scalar <code>Tensor</code> of the same type as <code>learning_rate</code>. The decayed learning rate.</p>
<h5 id="raises-13">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: if <code>global_step</code> is not supplied.</li>
</ul>
<hr />
<h3 id="tf.train.natural_exp_decaylearning_rate-global_step-decay_steps-decay_rate-staircasefalse-namenone"><a name="//apple_ref/cpp/Function/natural_exp_decay" class="dashAnchor"></a><code id="natural_exp_decay">tf.train.natural_exp_decay(learning_rate, global_step, decay_steps, decay_rate, staircase=False, name=None)</code></h3>
<p>Applies natural exponential decay to the initial learning rate.</p>
<p>When training a model, it is often recommended to lower the learning rate as the training progresses. This function applies an exponential decay function to a provided initial learning rate. It requires an <code>global_step</code> value to compute the decayed learning rate. You can just pass a TensorFlow variable that you increment at each training step.</p>
<p>The function returns the decayed learning rate. It is computed as:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">decayed_learning_rate <span class="op">=</span> learning_rate <span class="op">*</span> exp(<span class="op">-</span>decay_rate <span class="op">*</span> global_step)</code></pre></div>
<p>Example: decay exponentially with a base of 0.96:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">...
global_step <span class="op">=</span> tf.Variable(<span class="dv">0</span>, trainable<span class="op">=</span><span class="va">False</span>)
learning_rate <span class="op">=</span> <span class="fl">0.1</span>
k <span class="op">=</span> <span class="fl">0.5</span>
learning_rate <span class="op">=</span> tf.train.exponential_time_decay(learning_rate, global_step, k)

<span class="co"># Passing global_step to minimize() will increment it at each step.</span>
learning_step <span class="op">=</span> (
    tf.train.GradientDescentOptimizer(learning_rate)
    .minimize(...my loss..., global_step<span class="op">=</span>global_step)
)</code></pre></div>
<h5 id="args-25">Args:</h5>
<ul>
<li><b><code>learning_rate</code></b>: A scalar <code>float32</code> or <code>float64</code> <code>Tensor</code> or a Python number. The initial learning rate.</li>
<li><b><code>global_step</code></b>: A Python number. Global step to use for the decay computation. Must not be negative.</li>
<li><b><code>decay_steps</code></b>: How often to apply decay.</li>
<li><b><code>decay_rate</code></b>: A Python number. The decay rate.</li>
<li><b><code>staircase</code></b>: Whether to apply decay in a discrete staircase, as opposed to continuous, fashion.</li>
<li><b><code>name</code></b>: String. Optional name of the operation. Defaults to 'ExponentialTimeDecay'.</li>
</ul>
<h5 id="returns-15">Returns:</h5>
<p>A scalar <code>Tensor</code> of the same type as <code>learning_rate</code>. The decayed learning rate.</p>
<h5 id="raises-14">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: if <code>global_step</code> is not supplied.</li>
</ul>
<hr />
<h3 id="tf.train.piecewise_constantx-boundaries-values-namenone"><a name="//apple_ref/cpp/Function/piecewise_constant" class="dashAnchor"></a><code id="piecewise_constant">tf.train.piecewise_constant(x, boundaries, values, name=None)</code></h3>
<p>Piecewise constant from boundaries and interval values.</p>
<p>Example: use a learning rate that's 1.0 for the first 100000 steps, 0.5 for steps 100001 to 110000, and 0.1 for any additional steps.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">global_step <span class="op">=</span> tf.Variable(<span class="dv">0</span>, trainable<span class="op">=</span><span class="va">False</span>)
boundaries <span class="op">=</span> [<span class="dv">100000</span>, <span class="dv">110000</span>]
values <span class="op">=</span> [<span class="fl">1.0</span>, <span class="fl">0.5</span>, <span class="fl">0.1</span>]
learning_rate <span class="op">=</span> tf.train.piecewise_constant(global_step, boundaries, values)

<span class="co"># Later, whenever we perform an optimization step, we increment global_step.</span></code></pre></div>
<h5 id="args-26">Args:</h5>
<ul>
<li><b><code>x</code></b>: A 0-D scalar <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>uint8</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>.</li>
<li><b><code>boundaries</code></b>: A list of <code>Tensor</code>s or <code>int</code>s or <code>float</code>s with strictly increasing entries, and with all elements having the same type as <code>x</code>.</li>
<li><b><code>values</code></b>: A list of <code>Tensor</code>s or float<code>s or</code>int<code>s that specifies the values for the intervals defined by</code>boundaries<code>. It should have one more element than</code>boundaries`, and all elements should have the same type.</li>
<li><b><code>name</code></b>: A string. Optional name of the operation. Defaults to 'PiecewiseConstant'.</li>
</ul>
<h5 id="returns-16">Returns:</h5>
<p>A 0-D Tensor. Its value is <code>values[0]</code> when <code>x &lt;= boundaries[0]</code>, <code>values[1]</code> when <code>x &gt; boundaries[0]</code> and <code>x &lt;= boundaries[1]</code>, ..., and values[-1] when <code>x &gt; boundaries[-1]</code>.</p>
<h5 id="raises-15">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: if types of <code>x</code> and <code>buondaries</code> do not match, or types of all <code>values</code> do not match.</li>
</ul>
<hr />
<h3 id="tf.train.polynomial_decaylearning_rate-global_step-decay_steps-end_learning_rate0.0001-power1.0-cyclefalse-namenone"><a name="//apple_ref/cpp/Function/polynomial_decay" class="dashAnchor"></a><code id="polynomial_decay">tf.train.polynomial_decay(learning_rate, global_step, decay_steps, end_learning_rate=0.0001, power=1.0, cycle=False, name=None)</code></h3>
<p>Applies a polynomial decay to the learning rate.</p>
<p>It is commonly observed that a monotonically decreasing learning rate, whose degree of change is carefully chosen, results in a better performing model. This function applies a polynomial decay function to a provided initial <code>learning_rate</code> to reach an <code>end_learning_rate</code> in the given <code>decay_steps</code>.</p>
<p>It requires a <code>global_step</code> value to compute the decayed learning rate. You can just pass a TensorFlow variable that you increment at each training step.</p>
<p>The function returns the decayed learning rate. It is computed as:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">global_step <span class="op">=</span> <span class="bu">min</span>(global_step, decay_steps)
decayed_learning_rate <span class="op">=</span> (learning_rate <span class="op">-</span> end_learning_rate) <span class="op">*</span>
                        (<span class="dv">1</span> <span class="op">-</span> global_step <span class="op">/</span> decay_steps) <span class="op">^</span> (power) <span class="op">+</span>
                        end_learning_rate</code></pre></div>
<p>If <code>cycle</code> is True then a multiple of <code>decay_steps</code> is used, the first one that is bigger than <code>global_steps</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">decay_steps <span class="op">=</span> decay_steps <span class="op">*</span> ceil(global_step <span class="op">/</span> decay_steps)
decayed_learning_rate <span class="op">=</span> (learning_rate <span class="op">-</span> end_learning_rate) <span class="op">*</span>
                        (<span class="dv">1</span> <span class="op">-</span> global_step <span class="op">/</span> decay_steps) <span class="op">^</span> (power) <span class="op">+</span>
                        end_learning_rate</code></pre></div>
<p>Example: decay from 0.1 to 0.01 in 10000 steps using sqrt (i.e. power=0.5):</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">...
global_step <span class="op">=</span> tf.Variable(<span class="dv">0</span>, trainable<span class="op">=</span><span class="va">False</span>)
starter_learning_rate <span class="op">=</span> <span class="fl">0.1</span>
end_learning_rate <span class="op">=</span> <span class="fl">0.01</span>
decay_steps <span class="op">=</span> <span class="dv">10000</span>
learning_rate <span class="op">=</span> tf.train.polynomial_decay(starter_learning_rate, global_step,
                                          decay_steps, end_learning_rate,
                                          power<span class="op">=</span><span class="fl">0.5</span>)
<span class="co"># Passing global_step to minimize() will increment it at each step.</span>
learning_step <span class="op">=</span> (
    tf.train.GradientDescentOptimizer(learning_rate)
    .minimize(...my loss..., global_step<span class="op">=</span>global_step)
)</code></pre></div>
<h5 id="args-27">Args:</h5>
<ul>
<li><b><code>learning_rate</code></b>: A scalar <code>float32</code> or <code>float64</code> <code>Tensor</code> or a Python number. The initial learning rate.</li>
<li><b><code>global_step</code></b>: A scalar <code>int32</code> or <code>int64</code> <code>Tensor</code> or a Python number. Global step to use for the decay computation. Must not be negative.</li>
<li><b><code>decay_steps</code></b>: A scalar <code>int32</code> or <code>int64</code> <code>Tensor</code> or a Python number. Must be positive. See the decay computation above.</li>
<li><b><code>end_learning_rate</code></b>: A scalar <code>float32</code> or <code>float64</code> <code>Tensor</code> or a Python number. The minimal end learning rate.</li>
<li><b><code>power</code></b>: A scalar <code>float32</code> or <code>float64</code> <code>Tensor</code> or a Python number. The power of the polynomial. Defaults to sqrt, i.e. 0.5.</li>
<li><b><code>cycle</code></b>: A boolean, whether or not it should cycle beyond decay_steps.</li>
<li><b><code>name</code></b>: String. Optional name of the operation. Defaults to 'PolynomialDecay'.</li>
</ul>
<h5 id="returns-17">Returns:</h5>
<p>A scalar <code>Tensor</code> of the same type as <code>learning_rate</code>. The decayed learning rate.</p>
<h5 id="raises-16">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: if <code>global_step</code> is not supplied.</li>
</ul>
<h2 id="moving-averages">Moving Averages</h2>
<p>Some training algorithms, such as GradientDescent and Momentum often benefit from maintaining a moving average of variables during optimization. Using the moving averages for evaluations often improve results significantly.</p>
<hr />
<h3 id="class-tf.train.exponentialmovingaverage"><a name="//apple_ref/cpp/Class/ExponentialMovingAverage" class="dashAnchor"></a><code id="ExponentialMovingAverage">class tf.train.ExponentialMovingAverage</code></h3>
<p>Maintains moving averages of variables by employing an exponential decay.</p>
<p>When training a model, it is often beneficial to maintain moving averages of the trained parameters. Evaluations that use averaged parameters sometimes produce significantly better results than the final trained values.</p>
<p>The <code>apply()</code> method adds shadow copies of trained variables and add ops that maintain a moving average of the trained variables in their shadow copies. It is used when building the training model. The ops that maintain moving averages are typically run after each training step. The <code>average()</code> and <code>average_name()</code> methods give access to the shadow variables and their names. They are useful when building an evaluation model, or when restoring a model from a checkpoint file. They help use the moving averages in place of the last trained values for evaluations.</p>
<p>The moving averages are computed using exponential decay. You specify the decay value when creating the <code>ExponentialMovingAverage</code> object. The shadow variables are initialized with the same initial values as the trained variables. When you run the ops to maintain the moving averages, each shadow variable is updated with the formula:</p>
<p><code>shadow_variable -= (1 - decay) * (shadow_variable - variable)</code></p>
<p>This is mathematically equivalent to the classic formula below, but the use of an <code>assign_sub</code> op (the <code>&quot;-=&quot;</code> in the formula) allows concurrent lockless updates to the variables:</p>
<p><code>shadow_variable = decay * shadow_variable + (1 - decay) * variable</code></p>
<p>Reasonable values for <code>decay</code> are close to 1.0, typically in the multiple-nines range: 0.999, 0.9999, etc.</p>
<p>Example usage when creating a training model:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Create variables.</span>
var0 <span class="op">=</span> tf.Variable(...)
var1 <span class="op">=</span> tf.Variable(...)
<span class="co"># ... use the variables to build a training model...</span>
...
<span class="co"># Create an op that applies the optimizer.  This is what we usually</span>
<span class="co"># would use as a training op.</span>
opt_op <span class="op">=</span> opt.minimize(my_loss, [var0, var1])

<span class="co"># Create an ExponentialMovingAverage object</span>
ema <span class="op">=</span> tf.train.ExponentialMovingAverage(decay<span class="op">=</span><span class="fl">0.9999</span>)

<span class="co"># Create the shadow variables, and add ops to maintain moving averages</span>
<span class="co"># of var0 and var1.</span>
maintain_averages_op <span class="op">=</span> ema.<span class="bu">apply</span>([var0, var1])

<span class="co"># Create an op that will update the moving averages after each training</span>
<span class="co"># step.  This is what we will use in place of the usual training op.</span>
<span class="cf">with</span> tf.control_dependencies([opt_op]):
    training_op <span class="op">=</span> tf.group(maintain_averages_op)

...train the model by running training_op...</code></pre></div>
<p>There are two ways to use the moving averages for evaluations:</p>
<ul>
<li>Build a model that uses the shadow variables instead of the variables. For this, use the <code>average()</code> method which returns the shadow variable for a given variable.</li>
<li>Build a model normally but load the checkpoint files to evaluate by using the shadow variable names. For this use the <code>average_name()</code> method. See the <a href="../../api_docs/python/train.md#Saver">Saver class</a> for more information on restoring saved variables.</li>
</ul>
<p>Example of restoring the shadow variable values:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Create a Saver that loads variables from their saved shadow values.</span>
shadow_var0_name <span class="op">=</span> ema.average_name(var0)
shadow_var1_name <span class="op">=</span> ema.average_name(var1)
saver <span class="op">=</span> tf.train.Saver({shadow_var0_name: var0, shadow_var1_name: var1})
saver.restore(...checkpoint filename...)
<span class="co"># var0 and var1 now hold the moving average values</span></code></pre></div>
<hr />
<h4 id="tf.train.exponentialmovingaverage.__init__decay-num_updatesnone-zero_debiasfalse-nameexponentialmovingaverage"><code id="ExponentialMovingAverage.__init__">tf.train.ExponentialMovingAverage.__init__(decay, num_updates=None, zero_debias=False, name='ExponentialMovingAverage')</code></h4>
<p>Creates a new ExponentialMovingAverage object.</p>
<p>The <code>apply()</code> method has to be called to create shadow variables and add ops to maintain moving averages.</p>
<p>The optional <code>num_updates</code> parameter allows one to tweak the decay rate dynamically. It is typical to pass the count of training steps, usually kept in a variable that is incremented at each step, in which case the decay rate is lower at the start of training. This makes moving averages move faster. If passed, the actual decay rate used is:</p>
<p><code>min(decay, (1 + num_updates) / (10 + num_updates))</code></p>
<h5 id="args-28">Args:</h5>
<ul>
<li><b><code>decay</code></b>: Float. The decay to use.</li>
<li><b><code>num_updates</code></b>: Optional count of number of updates applied to variables.</li>
<li><b><code>zero_debias</code></b>: If <code>True</code>, zero debias moving-averages that are initialized with tensors.</li>
<li><b><code>name</code></b>: String. Optional prefix name to use for the name of ops added in <code>apply()</code>.</li>
</ul>
<hr />
<h4 id="tf.train.exponentialmovingaverage.applyvar_listnone"><code id="ExponentialMovingAverage.apply">tf.train.ExponentialMovingAverage.apply(var_list=None)</code></h4>
<p>Maintains moving averages of variables.</p>
<p><code>var_list</code> must be a list of <code>Variable</code> or <code>Tensor</code> objects. This method creates shadow variables for all elements of <code>var_list</code>. Shadow variables for <code>Variable</code> objects are initialized to the variable's initial value. They will be added to the <code>GraphKeys.MOVING_AVERAGE_VARIABLES</code> collection. For <code>Tensor</code> objects, the shadow variables are initialized to 0 and zero debiased (see docstring in <code>assign_moving_average</code> for more details).</p>
<p>shadow variables are created with <code>trainable=False</code> and added to the <code>GraphKeys.ALL_VARIABLES</code> collection. They will be returned by calls to <code>tf.global_variables()</code>.</p>
<p>Returns an op that updates all shadow variables as described above.</p>
<p>Note that <code>apply()</code> can be called multiple times with different lists of variables.</p>
<h5 id="args-29">Args:</h5>
<ul>
<li><b><code>var_list</code></b>: A list of Variable or Tensor objects. The variables and Tensors must be of types float16, float32, or float64.</li>
</ul>
<h5 id="returns-18">Returns:</h5>
<p>An Operation that updates the moving averages.</p>
<h5 id="raises-17">Raises:</h5>
<ul>
<li><b><code>TypeError</code></b>: If the arguments are not all float16, float32, or float64.</li>
<li><b><code>ValueError</code></b>: If the moving average of one of the variables is already being computed.</li>
</ul>
<hr />
<h4 id="tf.train.exponentialmovingaverage.average_namevar"><code id="ExponentialMovingAverage.average_name">tf.train.ExponentialMovingAverage.average_name(var)</code></h4>
<p>Returns the name of the <code>Variable</code> holding the average for <code>var</code>.</p>
<p>The typical scenario for <code>ExponentialMovingAverage</code> is to compute moving averages of variables during training, and restore the variables from the computed moving averages during evaluations.</p>
<p>To restore variables, you have to know the name of the shadow variables. That name and the original variable can then be passed to a <code>Saver()</code> object to restore the variable from the moving average value with: <code>saver = tf.train.Saver({ema.average_name(var): var})</code></p>
<p><code>average_name()</code> can be called whether or not <code>apply()</code> has been called.</p>
<h5 id="args-30">Args:</h5>
<ul>
<li><b><code>var</code></b>: A <code>Variable</code> object.</li>
</ul>
<h5 id="returns-19">Returns:</h5>
<p>A string: The name of the variable that will be used or was used by the <code>ExponentialMovingAverage class</code> to hold the moving average of <code>var</code>.</p>
<hr />
<h4 id="tf.train.exponentialmovingaverage.averagevar"><code id="ExponentialMovingAverage.average">tf.train.ExponentialMovingAverage.average(var)</code></h4>
<p>Returns the <code>Variable</code> holding the average of <code>var</code>.</p>
<h5 id="args-31">Args:</h5>
<ul>
<li><b><code>var</code></b>: A <code>Variable</code> object.</li>
</ul>
<h5 id="returns-20">Returns:</h5>
<p>A <code>Variable</code> object or <code>None</code> if the moving average of <code>var</code> is not maintained.</p>
<hr />
<h4 id="tf.train.exponentialmovingaverage.variables_to_restoremoving_avg_variablesnone"><code id="ExponentialMovingAverage.variables_to_restore">tf.train.ExponentialMovingAverage.variables_to_restore(moving_avg_variables=None)</code></h4>
<p>Returns a map of names to <code>Variables</code> to restore.</p>
<p>If a variable has a moving average, use the moving average variable name as the restore name; otherwise, use the variable name.</p>
<p>For example,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">  variables_to_restore <span class="op">=</span> ema.variables_to_restore()
  saver <span class="op">=</span> tf.train.Saver(variables_to_restore)</code></pre></div>
<p>Below is an example of such mapping:</p>
<pre><code>  conv/batchnorm/gamma/ExponentialMovingAverage: conv/batchnorm/gamma,
  conv_4/conv2d_params/ExponentialMovingAverage: conv_4/conv2d_params,
  global_step: global_step</code></pre>
<h5 id="args-32">Args:</h5>
<ul>
<li><b><code>moving_avg_variables</code></b>: a list of variables that require to use of the moving variable name to be restored. If None, it will default to variables.moving_average_variables() + variables.trainable_variables()</li>
</ul>
<h5 id="returns-21">Returns:</h5>
<p>A map from restore_names to variables. The restore_name can be the moving_average version of the variable name if it exist, or the original variable name.</p>
<h2 id="coordinator-and-queuerunner">Coordinator and QueueRunner</h2>
<p>See <a href="../../how_tos/threading_and_queues/index.md">Threading and Queues</a> for how to use threads and queues. For documentation on the Queue API, see <a href="../../api_docs/python/io_ops.md#queues">Queues</a>.</p>
<hr />
<h3 id="class-tf.train.coordinator"><a name="//apple_ref/cpp/Class/Coordinator" class="dashAnchor"></a><code id="Coordinator">class tf.train.Coordinator</code></h3>
<p>A coordinator for threads.</p>
<p>This class implements a simple mechanism to coordinate the termination of a set of threads.</p>
<h4 id="usage-1">Usage:</h4>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Create a coordinator.</span>
coord <span class="op">=</span> Coordinator()
<span class="co"># Start a number of threads, passing the coordinator to each of them.</span>
...start thread <span class="dv">1</span>...(coord, ...)
...start thread N...(coord, ...)
<span class="co"># Wait for all the threads to terminate.</span>
coord.join(threads)</code></pre></div>
<p>Any of the threads can call <code>coord.request_stop()</code> to ask for all the threads to stop. To cooperate with the requests, each thread must check for <code>coord.should_stop()</code> on a regular basis. <code>coord.should_stop()</code> returns <code>True</code> as soon as <code>coord.request_stop()</code> has been called.</p>
<p>A typical thread running with a coordinator will do something like:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">while</span> <span class="op">not</span> coord.should_stop():
  ...do some work...</code></pre></div>
<h4 id="exception-handling">Exception handling:</h4>
<p>A thread can report an exception to the coordinator as part of the <code>should_stop()</code> call. The exception will be re-raised from the <code>coord.join()</code> call.</p>
<p>Thread code:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">try</span>:
  <span class="cf">while</span> <span class="op">not</span> coord.should_stop():
    ...do some work...
<span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:
  coord.request_stop(e)</code></pre></div>
<p>Main code:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">try</span>:
  ...
  coord <span class="op">=</span> Coordinator()
  <span class="co"># Start a number of threads, passing the coordinator to each of them.</span>
  ...start thread <span class="dv">1</span>...(coord, ...)
  ...start thread N...(coord, ...)
  <span class="co"># Wait for all the threads to terminate.</span>
  coord.join(threads)
<span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:
  ...exception that was passed to coord.request_stop()</code></pre></div>
<p>To simplify the thread implementation, the Coordinator provides a context handler <code>stop_on_exception()</code> that automatically requests a stop if an exception is raised. Using the context handler the thread code above can be written as:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">with</span> coord.stop_on_exception():
  <span class="cf">while</span> <span class="op">not</span> coord.should_stop():
    ...do some work...</code></pre></div>
<h4 id="grace-period-for-stopping">Grace period for stopping:</h4>
<p>After a thread has called <code>coord.request_stop()</code> the other threads have a fixed time to stop, this is called the 'stop grace period' and defaults to 2 minutes. If any of the threads is still alive after the grace period expires <code>coord.join()</code> raises a RuntimeException reporting the laggards.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">try</span>:
  ...
  coord <span class="op">=</span> Coordinator()
  <span class="co"># Start a number of threads, passing the coordinator to each of them.</span>
  ...start thread <span class="dv">1</span>...(coord, ...)
  ...start thread N...(coord, ...)
  <span class="co"># Wait for all the threads to terminate, give them 10s grace period</span>
  coord.join(threads, stop_grace_period_secs<span class="op">=</span><span class="dv">10</span>)
<span class="cf">except</span> RuntimeException:
  ...one of the threads took more than 10s to stop after request_stop()
  ...was called.
<span class="cf">except</span> <span class="pp">Exception</span>:
  ...exception that was passed to coord.request_stop()</code></pre></div>
<hr />
<h4 id="tf.train.coordinator.__init__clean_stop_exception_typesnone"><code id="Coordinator.__init__">tf.train.Coordinator.__init__(clean_stop_exception_types=None)</code></h4>
<p>Create a new Coordinator.</p>
<h5 id="args-33">Args:</h5>
<ul>
<li><b><code>clean_stop_exception_types</code></b>: Optional tuple of Exception types that should cause a clean stop of the coordinator. If an exception of one of these types is reported to <code>request_stop(ex)</code> the coordinator will behave as if <code>request_stop(None)</code> was called. Defaults to <code>(tf.errors.OutOfRangeError,)</code> which is used by input queues to signal the end of input. When feeding training data from a Python iterator it is common to add <code>StopIteration</code> to this list.</li>
</ul>
<hr />
<h4 id="tf.train.coordinator.clear_stop"><code id="Coordinator.clear_stop">tf.train.Coordinator.clear_stop()</code></h4>
<p>Clears the stop flag.</p>
<p>After this is called, calls to <code>should_stop()</code> will return <code>False</code>.</p>
<hr />
<h4 id="tf.train.coordinator.jointhreadsnone-stop_grace_period_secs120"><code id="Coordinator.join">tf.train.Coordinator.join(threads=None, stop_grace_period_secs=120)</code></h4>
<p>Wait for threads to terminate.</p>
<p>This call blocks until a set of threads have terminated. The set of thread is the union of the threads passed in the <code>threads</code> argument and the list of threads that registered with the coordinator by calling <code>Coordinator.register_thread()</code>.</p>
<p>After the threads stop, if an <code>exc_info</code> was passed to <code>request_stop</code>, that exception is re-raised.</p>
<p>Grace period handling: When <code>request_stop()</code> is called, threads are given 'stop_grace_period_secs' seconds to terminate. If any of them is still alive after that period expires, a <code>RuntimeError</code> is raised. Note that if an <code>exc_info</code> was passed to <code>request_stop()</code> then it is raised instead of that <code>RuntimeError</code>.</p>
<h5 id="args-34">Args:</h5>
<ul>
<li><b><code>threads</code></b>: List of <code>threading.Threads</code>. The started threads to join in addition to the registered threads.</li>
<li><b><code>stop_grace_period_secs</code></b>: Number of seconds given to threads to stop after <code>request_stop()</code> has been called.</li>
</ul>
<h5 id="raises-18">Raises:</h5>
<ul>
<li><b><code>RuntimeError</code></b>: If any thread is still alive after <code>request_stop()</code> is called and the grace period expires.</li>
</ul>
<hr />
<h4 id="tf.train.coordinator.joined"><code id="Coordinator.joined">tf.train.Coordinator.joined</code></h4>
<hr />
<h4 id="tf.train.coordinator.raise_requested_exception"><code id="Coordinator.raise_requested_exception">tf.train.Coordinator.raise_requested_exception()</code></h4>
<p>If an exception has been passed to <code>request_stop</code>, this raises it.</p>
<hr />
<h4 id="tf.train.coordinator.register_threadthread"><code id="Coordinator.register_thread">tf.train.Coordinator.register_thread(thread)</code></h4>
<p>Register a thread to join.</p>
<h5 id="args-35">Args:</h5>
<ul>
<li><b><code>thread</code></b>: A Python thread to join.</li>
</ul>
<hr />
<h4 id="tf.train.coordinator.request_stopexnone"><code id="Coordinator.request_stop">tf.train.Coordinator.request_stop(ex=None)</code></h4>
<p>Request that the threads stop.</p>
<p>After this is called, calls to <code>should_stop()</code> will return <code>True</code>.</p>
<p>Note: If an exception is being passed in, in must be in the context of handling the exception (i.e. <code>try: ... except Exception as ex: ...</code>) and not a newly created one.</p>
<h5 id="args-36">Args:</h5>
<ul>
<li><b><code>ex</code></b>: Optional <code>Exception</code>, or Python <code>exc_info</code> tuple as returned by <code>sys.exc_info()</code>. If this is the first call to <code>request_stop()</code> the corresponding exception is recorded and re-raised from <code>join()</code>.</li>
</ul>
<hr />
<h4 id="tf.train.coordinator.should_stop"><code id="Coordinator.should_stop">tf.train.Coordinator.should_stop()</code></h4>
<p>Check if stop was requested.</p>
<h5 id="returns-22">Returns:</h5>
<p>True if a stop was requested.</p>
<hr />
<h4 id="tf.train.coordinator.stop_on_exception"><code id="Coordinator.stop_on_exception">tf.train.Coordinator.stop_on_exception()</code></h4>
<p>Context manager to request stop when an Exception is raised.</p>
<p>Code that uses a coordinator must catch exceptions and pass them to the <code>request_stop()</code> method to stop the other threads managed by the coordinator.</p>
<p>This context handler simplifies the exception handling. Use it as follows:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">with</span> coord.stop_on_exception():
  <span class="co"># Any exception raised in the body of the with</span>
  <span class="co"># clause is reported to the coordinator before terminating</span>
  <span class="co"># the execution of the body.</span>
  ...body...</code></pre></div>
<p>This is completely equivalent to the slightly longer code:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">try</span>:
  ...body...
exception <span class="pp">Exception</span> <span class="im">as</span> ex:
  coord.request_stop(ex)</code></pre></div>
<h5 id="yields">Yields:</h5>
<p>nothing.</p>
<hr />
<h4 id="tf.train.coordinator.wait_for_stoptimeoutnone"><code id="Coordinator.wait_for_stop">tf.train.Coordinator.wait_for_stop(timeout=None)</code></h4>
<p>Wait till the Coordinator is told to stop.</p>
<h5 id="args-37">Args:</h5>
<ul>
<li><b><code>timeout</code></b>: Float. Sleep for up to that many seconds waiting for should_stop() to become True.</li>
</ul>
<h5 id="returns-23">Returns:</h5>
<p>True if the Coordinator is told stop, False if the timeout expired.</p>
<hr />
<h3 id="class-tf.train.queuerunner"><a name="//apple_ref/cpp/Class/QueueRunner" class="dashAnchor"></a><code id="QueueRunner">class tf.train.QueueRunner</code></h3>
<p>Holds a list of enqueue operations for a queue, each to be run in a thread.</p>
<p>Queues are a convenient TensorFlow mechanism to compute tensors asynchronously using multiple threads. For example in the canonical 'Input Reader' setup one set of threads generates filenames in a queue; a second set of threads read records from the files, processes them, and enqueues tensors on a second queue; a third set of threads dequeues these input records to construct batches and runs them through training operations.</p>
<p>There are several delicate issues when running multiple threads that way: closing the queues in sequence as the input is exhausted, correctly catching and reporting exceptions, etc.</p>
<p>The <code>QueueRunner</code>, combined with the <code>Coordinator</code>, helps handle these issues. - - -</p>
<h4 id="tf.train.queuerunner.__init__queuenone-enqueue_opsnone-close_opnone-cancel_opnone-queue_closed_exception_typesnone-queue_runner_defnone-import_scopenone"><code id="QueueRunner.__init__">tf.train.QueueRunner.__init__(queue=None, enqueue_ops=None, close_op=None, cancel_op=None, queue_closed_exception_types=None, queue_runner_def=None, import_scope=None)</code></h4>
<p>Create a QueueRunner.</p>
<p>On construction the <code>QueueRunner</code> adds an op to close the queue. That op will be run if the enqueue ops raise exceptions.</p>
<p>When you later call the <code>create_threads()</code> method, the <code>QueueRunner</code> will create one thread for each op in <code>enqueue_ops</code>. Each thread will run its enqueue op in parallel with the other threads. The enqueue ops do not have to all be the same op, but it is expected that they all enqueue tensors in <code>queue</code>.</p>
<h5 id="args-38">Args:</h5>
<ul>
<li><b><code>queue</code></b>: A <code>Queue</code>.</li>
<li><b><code>enqueue_ops</code></b>: List of enqueue ops to run in threads later.</li>
<li><b><code>close_op</code></b>: Op to close the queue. Pending enqueue ops are preserved.</li>
<li><b><code>cancel_op</code></b>: Op to close the queue and cancel pending enqueue ops.</li>
<li><b><code>queue_closed_exception_types</code></b>: Optional tuple of Exception types that indicate that the queue has been closed when raised during an enqueue operation. Defaults to <code>(tf.errors.OutOfRangeError,)</code>. Another common case includes <code>(tf.errors.OutOfRangeError, tf.errors.CancelledError)</code>, when some of the enqueue ops may dequeue from other Queues.</li>
<li><b><code>queue_runner_def</code></b>: Optional <code>QueueRunnerDef</code> protocol buffer. If specified, recreates the QueueRunner from its contents. <code>queue_runner_def</code> and the other arguments are mutually exclusive.</li>
<li><b><code>import_scope</code></b>: Optional <code>string</code>. Name scope to add. Only used when initializing from protocol buffer.</li>
</ul>
<h5 id="raises-19">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If both <code>queue_runner_def</code> and <code>queue</code> are both specified.</li>
<li><b><code>ValueError</code></b>: If <code>queue</code> or <code>enqueue_ops</code> are not provided when not restoring from <code>queue_runner_def</code>.</li>
</ul>
<hr />
<h4 id="tf.train.queuerunner.cancel_op"><code id="QueueRunner.cancel_op">tf.train.QueueRunner.cancel_op</code></h4>
<hr />
<h4 id="tf.train.queuerunner.close_op"><code id="QueueRunner.close_op">tf.train.QueueRunner.close_op</code></h4>
<hr />
<h4 id="tf.train.queuerunner.create_threadssess-coordnone-daemonfalse-startfalse"><code id="QueueRunner.create_threads">tf.train.QueueRunner.create_threads(sess, coord=None, daemon=False, start=False)</code></h4>
<p>Create threads to run the enqueue ops for the given session.</p>
<p>This method requires a session in which the graph was launched. It creates a list of threads, optionally starting them. There is one thread for each op passed in <code>enqueue_ops</code>.</p>
<p>The <code>coord</code> argument is an optional coordinator that the threads will use to terminate together and report exceptions. If a coordinator is given, this method starts an additional thread to close the queue when the coordinator requests a stop.</p>
<p>If previously created threads for the given session are still running, no new threads will be created.</p>
<h5 id="args-39">Args:</h5>
<ul>
<li><b><code>sess</code></b>: A <code>Session</code>.</li>
<li><b><code>coord</code></b>: Optional <code>Coordinator</code> object for reporting errors and checking stop conditions.</li>
<li><b><code>daemon</code></b>: Boolean. If <code>True</code> make the threads daemon threads.</li>
<li><b><code>start</code></b>: Boolean. If <code>True</code> starts the threads. If <code>False</code> the caller must call the <code>start()</code> method of the returned threads.</li>
</ul>
<h5 id="returns-24">Returns:</h5>
<p>A list of threads.</p>
<hr />
<h4 id="tf.train.queuerunner.enqueue_ops"><code id="QueueRunner.enqueue_ops">tf.train.QueueRunner.enqueue_ops</code></h4>
<hr />
<h4 id="tf.train.queuerunner.exceptions_raised"><code id="QueueRunner.exceptions_raised">tf.train.QueueRunner.exceptions_raised</code></h4>
<p>Exceptions raised but not handled by the <code>QueueRunner</code> threads.</p>
<p>Exceptions raised in queue runner threads are handled in one of two ways depending on whether or not a <code>Coordinator</code> was passed to <code>create_threads()</code>:</p>
<ul>
<li>With a <code>Coordinator</code>, exceptions are reported to the coordinator and forgotten by the <code>QueueRunner</code>.</li>
<li>Without a <code>Coordinator</code>, exceptions are captured by the <code>QueueRunner</code> and made available in this <code>exceptions_raised</code> property.</li>
</ul>
<h5 id="returns-25">Returns:</h5>
<p>A list of Python <code>Exception</code> objects. The list is empty if no exception was captured. (No exceptions are captured when using a Coordinator.)</p>
<hr />
<h4 id="tf.train.queuerunner.from_protoqueue_runner_def-import_scopenone"><code id="QueueRunner.from_proto">tf.train.QueueRunner.from_proto(queue_runner_def, import_scope=None)</code></h4>
<p>Returns a <code>QueueRunner</code> object created from <code>queue_runner_def</code>.</p>
<hr />
<h4 id="tf.train.queuerunner.name"><code id="QueueRunner.name">tf.train.QueueRunner.name</code></h4>
<p>The string name of the underlying Queue.</p>
<hr />
<h4 id="tf.train.queuerunner.queue"><code id="QueueRunner.queue">tf.train.QueueRunner.queue</code></h4>
<hr />
<h4 id="tf.train.queuerunner.queue_closed_exception_types"><code id="QueueRunner.queue_closed_exception_types">tf.train.QueueRunner.queue_closed_exception_types</code></h4>
<hr />
<h4 id="tf.train.queuerunner.to_protoexport_scopenone"><code id="QueueRunner.to_proto">tf.train.QueueRunner.to_proto(export_scope=None)</code></h4>
<p>Converts this <code>QueueRunner</code> to a <code>QueueRunnerDef</code> protocol buffer.</p>
<h5 id="args-40">Args:</h5>
<ul>
<li><b><code>export_scope</code></b>: Optional <code>string</code>. Name scope to remove.</li>
</ul>
<h5 id="returns-26">Returns:</h5>
<p>A <code>QueueRunnerDef</code> protocol buffer, or <code>None</code> if the <code>Variable</code> is not in the specified name scope.</p>
<hr />
<h3 id="tf.train.add_queue_runnerqr-collectionqueue_runners"><a name="//apple_ref/cpp/Function/add_queue_runner" class="dashAnchor"></a><code id="add_queue_runner">tf.train.add_queue_runner(qr, collection='queue_runners')</code></h3>
<p>Adds a <code>QueueRunner</code> to a collection in the graph.</p>
<p>When building a complex model that uses many queues it is often difficult to gather all the queue runners that need to be run. This convenience function allows you to add a queue runner to a well known collection in the graph.</p>
<p>The companion method <code>start_queue_runners()</code> can be used to start threads for all the collected queue runners.</p>
<h5 id="args-41">Args:</h5>
<ul>
<li><b><code>qr</code></b>: A <code>QueueRunner</code>.</li>
<li><b><code>collection</code></b>: A <code>GraphKey</code> specifying the graph collection to add the queue runner to. Defaults to <code>GraphKeys.QUEUE_RUNNERS</code>.</li>
</ul>
<hr />
<h3 id="tf.train.start_queue_runnerssessnone-coordnone-daemontrue-starttrue-collectionqueue_runners"><a name="//apple_ref/cpp/Function/start_queue_runners" class="dashAnchor"></a><code id="start_queue_runners">tf.train.start_queue_runners(sess=None, coord=None, daemon=True, start=True, collection='queue_runners')</code></h3>
<p>Starts all queue runners collected in the graph.</p>
<p>This is a companion method to <code>add_queue_runner()</code>. It just starts threads for all queue runners collected in the graph. It returns the list of all threads.</p>
<h5 id="args-42">Args:</h5>
<ul>
<li><b><code>sess</code></b>: <code>Session</code> used to run the queue ops. Defaults to the default session.</li>
<li><b><code>coord</code></b>: Optional <code>Coordinator</code> for coordinating the started threads.</li>
<li><b><code>daemon</code></b>: Whether the threads should be marked as <code>daemons</code>, meaning they don't block program exit.</li>
<li><b><code>start</code></b>: Set to <code>False</code> to only create the threads, not start them.</li>
<li><b><code>collection</code></b>: A <code>GraphKey</code> specifying the graph collection to get the queue runners from. Defaults to <code>GraphKeys.QUEUE_RUNNERS</code>.</li>
</ul>
<h5 id="returns-27">Returns:</h5>
<p>A list of threads.</p>
<h2 id="distributed-execution">Distributed execution</h2>
<p>See <a href="../../how_tos/distributed/index.md">Distributed TensorFlow</a> for more information about how to configure a distributed TensorFlow program.</p>
<hr />
<h3 id="class-tf.train.server"><a name="//apple_ref/cpp/Class/Server" class="dashAnchor"></a><code id="Server">class tf.train.Server</code></h3>
<p>An in-process TensorFlow server, for use in distributed training.</p>
<p>A <code>tf.train.Server</code> instance encapsulates a set of devices and a <a href="../../api_docs/python/client.md#Session"><code>tf.Session</code></a> target that can participate in distributed training. A server belongs to a cluster (specified by a <a href="#ClusterSpec"><code>tf.train.ClusterSpec</code></a>), and corresponds to a particular task in a named job. The server can communicate with any other server in the same cluster.</p>
<hr />
<h4 id="tf.train.server.__init__server_or_cluster_def-job_namenone-task_indexnone-protocolnone-confignone-starttrue"><code id="Server.__init__">tf.train.Server.__init__(server_or_cluster_def, job_name=None, task_index=None, protocol=None, config=None, start=True)</code></h4>
<p>Creates a new server with the given definition.</p>
<p>The <code>job_name</code>, <code>task_index</code>, and <code>protocol</code> arguments are optional, and override any information provided in <code>server_or_cluster_def</code>.</p>
<h5 id="args-43">Args:</h5>
<ul>
<li><b><code>server_or_cluster_def</code></b>: A <code>tf.train.ServerDef</code> or <code>tf.train.ClusterDef</code> protocol buffer, or a <code>tf.train.ClusterSpec</code> object, describing the server to be created and/or the cluster of which it is a member.</li>
<li><b><code>job_name</code></b>: (Optional.) Specifies the name of the job of which the server is a member. Defaults to the value in <code>server_or_cluster_def</code>, if specified.</li>
<li><b><code>task_index</code></b>: (Optional.) Specifies the task index of the server in its job. Defaults to the value in <code>server_or_cluster_def</code>, if specified. Otherwise defaults to 0 if the server's job has only one task.</li>
<li><b><code>protocol</code></b>: (Optional.) Specifies the protocol to be used by the server. Acceptable values include <code>&quot;grpc&quot;</code>. Defaults to the value in <code>server_or_cluster_def</code>, if specified. Otherwise defaults to <code>&quot;grpc&quot;</code>.</li>
<li><b><code>config</code></b>: (Options.) A <code>tf.ConfigProto</code> that specifies default configuration options for all sessions that run on this server.</li>
<li><b><code>start</code></b>: (Optional.) Boolean, indicating whether to start the server after creating it. Defaults to <code>True</code>.</li>
</ul>
<h5 id="raises-20">Raises:</h5>
<p>tf.errors.OpError: Or one of its subclasses if an error occurs while creating the TensorFlow server.</p>
<hr />
<h4 id="tf.train.server.create_local_serverconfignone-starttrue"><code id="Server.create_local_server">tf.train.Server.create_local_server(config=None, start=True)</code></h4>
<p>Creates a new single-process cluster running on the local host.</p>
<p>This method is a convenience wrapper for creating a <code>tf.train.Server</code> with a <code>tf.train.ServerDef</code> that specifies a single-process cluster containing a single task in a job called <code>&quot;local&quot;</code>.</p>
<h5 id="args-44">Args:</h5>
<ul>
<li><b><code>config</code></b>: (Options.) A <code>tf.ConfigProto</code> that specifies default configuration options for all sessions that run on this server.</li>
<li><b><code>start</code></b>: (Optional.) Boolean, indicating whether to start the server after creating it. Defaults to <code>True</code>.</li>
</ul>
<h5 id="returns-28">Returns:</h5>
<p>A local <code>tf.train.Server</code>.</p>
<hr />
<h4 id="tf.train.server.target"><code id="Server.target">tf.train.Server.target</code></h4>
<p>Returns the target for a <code>tf.Session</code> to connect to this server.</p>
<p>To create a <a href="../../api_docs/python/client.md#Session"><code>tf.Session</code></a> that connects to this server, use the following snippet:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">server <span class="op">=</span> tf.train.Server(...)
<span class="cf">with</span> tf.Session(server.target):
  <span class="co"># ...</span></code></pre></div>
<h5 id="returns-29">Returns:</h5>
<p>A string containing a session target for this server.</p>
<hr />
<h4 id="tf.train.server.server_def"><code id="Server.server_def">tf.train.Server.server_def</code></h4>
<p>Returns the <code>tf.train.ServerDef</code> for this server.</p>
<h5 id="returns-30">Returns:</h5>
<p>A <code>tf.train.ServerDef</code> protocol buffer that describes the configuration of this server.</p>
<hr />
<h4 id="tf.train.server.start"><code id="Server.start">tf.train.Server.start()</code></h4>
<p>Starts this server.</p>
<h5 id="raises-21">Raises:</h5>
<p>tf.errors.OpError: Or one of its subclasses if an error occurs while starting the TensorFlow server.</p>
<hr />
<h4 id="tf.train.server.join"><code id="Server.join">tf.train.Server.join()</code></h4>
<p>Blocks until the server has shut down.</p>
<p>This method currently blocks forever.</p>
<h5 id="raises-22">Raises:</h5>
<p>tf.errors.OpError: Or one of its subclasses if an error occurs while joining the TensorFlow server.</p>
<hr />
<h3 id="class-tf.train.supervisor"><a name="//apple_ref/cpp/Class/Supervisor" class="dashAnchor"></a><code id="Supervisor">class tf.train.Supervisor</code></h3>
<p>A training helper that checkpoints models and computes summaries.</p>
<p>The Supervisor is a small wrapper around a <code>Coordinator</code>, a <code>Saver</code>, and a <code>SessionManager</code> that takes care of common needs of TensorFlow training programs.</p>
<h4 id="use-for-a-single-program">Use for a single program</h4>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">with</span> tf.Graph().as_default():
  ...add operations to the graph...
  <span class="co"># Create a Supervisor that will checkpoint the model in &#39;/tmp/mydir&#39;.</span>
  sv <span class="op">=</span> Supervisor(logdir<span class="op">=</span><span class="st">&#39;/tmp/mydir&#39;</span>)
  <span class="co"># Get a TensorFlow session managed by the supervisor.</span>
  <span class="cf">with</span> sv.managed_session(FLAGS.master) <span class="im">as</span> sess:
    <span class="co"># Use the session to train the graph.</span>
    <span class="cf">while</span> <span class="op">not</span> sv.should_stop():
      sess.run(<span class="op">&lt;</span>my_train_op<span class="op">&gt;</span>)</code></pre></div>
<p>Within the <code>with sv.managed_session()</code> block all variables in the graph have been initialized. In addition, a few services have been started to checkpoint the model and add summaries to the event log.</p>
<p>If the program crashes and is restarted, the managed session automatically reinitialize variables from the most recent checkpoint.</p>
<p>The supervisor is notified of any exception raised by one of the services. After an exception is raised, <code>should_stop()</code> returns <code>True</code>. In that case the training loop should also stop. This is why the training loop has to check for <code>sv.should_stop()</code>.</p>
<p>Exceptions that indicate that the training inputs have been exhausted, <code>tf.errors.OutOfRangeError</code>, also cause <code>sv.should_stop()</code> to return <code>True</code> but are not re-raised from the <code>with</code> block: they indicate a normal termination.</p>
<h4 id="use-for-multiple-replicas">Use for multiple replicas</h4>
<p>To train with replicas you deploy the same program in a <code>Cluster</code>. One of the tasks must be identified as the <em>chief</em>: the task that handles initialization, checkpoints, summaries, and recovery. The other tasks depend on the <em>chief</em> for these services.</p>
<p>The only change you have to do to the single program code is to indicate if the program is running as the <em>chief</em>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Choose a task as the chief. This could be based on server_def.task_index,</span>
<span class="co"># or job_def.name, or job_def.tasks. It&#39;s entirely up to the end user.</span>
<span class="co"># But there can be only one *chief*.</span>
is_chief <span class="op">=</span> (server_def.task_index <span class="op">==</span> <span class="dv">0</span>)
server <span class="op">=</span> tf.train.Server(server_def)

<span class="cf">with</span> tf.Graph().as_default():
  ...add operations to the graph...
  <span class="co"># Create a Supervisor that uses log directory on a shared file system.</span>
  <span class="co"># Indicate if you are the &#39;chief&#39;</span>
  sv <span class="op">=</span> Supervisor(logdir<span class="op">=</span><span class="st">&#39;/shared_directory/...&#39;</span>, is_chief<span class="op">=</span>is_chief)
  <span class="co"># Get a Session in a TensorFlow server on the cluster.</span>
  <span class="cf">with</span> sv.managed_session(server.target) <span class="im">as</span> sess:
    <span class="co"># Use the session to train the graph.</span>
    <span class="cf">while</span> <span class="op">not</span> sv.should_stop():
      sess.run(<span class="op">&lt;</span>my_train_op<span class="op">&gt;</span>)</code></pre></div>
<p>In the <em>chief</em> task, the <code>Supervisor</code> works exactly as in the first example above. In the other tasks <code>sv.managed_session()</code> waits for the Model to have been initialized before returning a session to the training code. The non-chief tasks depend on the chief task for initializing the model.</p>
<p>If one of the tasks crashes and restarts, <code>managed_session()</code> checks if the Model is initialized. If yes, it just creates a session and returns it to the training code that proceeds normally. If the model needs to be initialized, the chief task takes care of reinitializing it; the other tasks just wait for the model to have been initialized.</p>
<p>NOTE: This modified program still works fine as a single program. The single program marks itself as the chief.</p>
<h4 id="what-master-string-to-use">What <code>master</code> string to use</h4>
<p>Whether you are running on your machine or in the cluster you can use the following values for the --master flag:</p>
<ul>
<li><p>Specifying <code>''</code> requests an in-process session that does not use RPC.</p></li>
<li><p>Specifying <code>'local'</code> requests a session that uses the RPC-based &quot;Master interface&quot; to run TensorFlow programs. See <a href="#Server.create_local_server"><code>tf.train.Server.create_local_server()</code></a> for details.</p></li>
<li><p>Specifying <code>'grpc://hostname:port'</code> requests a session that uses the RPC interface to a specific host, and also allows the in-process master to access remote tensorflow workers. Often, it is appropriate to pass <code>server.target</code> (for some <code>tf.train.Server</code> named `server).</p></li>
</ul>
<h4 id="advanced-use">Advanced use</h4>
<h5 id="launching-additional-services">Launching additional services</h5>
<p><code>managed_session()</code> launches the Checkpoint and Summary services (threads). If you need more services to run you can simply launch them in the block controlled by <code>managed_session()</code>.</p>
<p>Example: Start a thread to print losses. We want this thread to run every 60 seconds, so we launch it with <code>sv.loop()</code>.</p>
<p><code>python   ...   sv = Supervisor(logdir='/tmp/mydir')   with sv.managed_session(FLAGS.master) as sess:     sv.loop(60, print_loss, (sess, ))     while not sv.should_stop():       sess.run(my_train_op)</code></p>
<h5 id="launching-fewer-services">Launching fewer services</h5>
<p><code>managed_session()</code> launches the &quot;summary&quot; and &quot;checkpoint&quot; threads which use either the optionally <code>summary_op</code> and <code>saver</code> passed to the constructor, or default ones created automatically by the supervisor. If you want to run your own summary and checkpointing logic, disable these services by passing <code>None</code> to the <code>summary_op</code> and <code>saver</code> parameters.</p>
<p>Example: Create summaries manually every 100 steps in the chief.</p>
<p><code>python   # Create a Supervisor with no automatic summaries.   sv = Supervisor(logdir='/tmp/mydir', is_chief=is_chief, summary_op=None)   # As summary_op was None, managed_session() does not start the   # summary thread.   with sv.managed_session(FLAGS.master) as sess:     for step in xrange(1000000):       if sv.should_stop():         break       if is_chief and step % 100 == 0:         # Create the summary every 100 chief steps.         sv.summary_computed(sess, sess.run(my_summary_op))       else:         # Train normally         sess.run(my_train_op)</code></p>
<h5 id="custom-model-initialization">Custom model initialization</h5>
<p><code>managed_session()</code> only supports initializing the model by running an <code>init_op</code> or restoring from the latest checkpoint. If you have special initialization needs, see how to specify a <code>local_init_op</code> when creating the supervisor. You can also use the <code>SessionManager</code> directly to create a session and check if it could be initialized automatically.</p>
<hr />
<h4 id="tf.train.supervisor.__init__graphnone-ready_op0-ready_for_local_init_op0-is_chieftrue-init_op0-init_feed_dictnone-local_init_op0-logdirnone-summary_op0-saver0-global_step0-save_summaries_secs120-save_model_secs600-recovery_wait_secs30-stop_grace_secs120-checkpoint_basenamemodel.ckpt-session_managernone-summary_writer0-init_fnnone"><code id="Supervisor.__init__">tf.train.Supervisor.__init__(graph=None, ready_op=0, ready_for_local_init_op=0, is_chief=True, init_op=0, init_feed_dict=None, local_init_op=0, logdir=None, summary_op=0, saver=0, global_step=0, save_summaries_secs=120, save_model_secs=600, recovery_wait_secs=30, stop_grace_secs=120, checkpoint_basename='model.ckpt', session_manager=None, summary_writer=0, init_fn=None)</code></h4>
<p>Create a <code>Supervisor</code>.</p>
<h5 id="args-45">Args:</h5>
<ul>
<li><b><code>graph</code></b>: A <code>Graph</code>. The graph that the model will use. Defaults to the default <code>Graph</code>. The supervisor may add operations to the graph before creating a session, but the graph should not be modified by the caller after passing it to the supervisor.</li>
<li><b><code>ready_op</code></b>: 1-D string <code>Tensor</code>. This tensor is evaluated by supervisors in <code>prepare_or_wait_for_session()</code> to check if the model is ready to use. The model is considered ready if it returns an empty array. Defaults to the tensor returned from <code>tf.report_uninitialized_variables()</code> If <code>None</code>, the model is not checked for readiness.</li>
<li><b><code>ready_for_local_init_op</code></b>: 1-D string <code>Tensor</code>. This tensor is evaluated by supervisors in <code>prepare_or_wait_for_session()</code> to check if the model is ready to run the local_init_op. The model is considered ready if it returns an empty array. Defaults to the tensor returned from <code>tf.report_uninitialized_variables(tf.global_variables())</code>. If <code>None</code>, the model is not checked for readiness before running local_init_op.</li>
<li><b><code>is_chief</code></b>: If True, create a chief supervisor in charge of initializing and restoring the model. If False, create a supervisor that relies on a chief supervisor for inits and restore.</li>
<li><b><code>init_op</code></b>: <code>Operation</code>. Used by chief supervisors to initialize the model when it can not be recovered. Defaults to an <code>Operation</code> that initializes all variables. If <code>None</code>, no initialization is done automatically unless you pass a value for <code>init_fn</code>, see below.</li>
<li><b><code>init_feed_dict</code></b>: A dictionary that maps <code>Tensor</code> objects to feed values. This feed dictionary will be used when <code>init_op</code> is evaluated.</li>
<li><b><code>local_init_op</code></b>: <code>Operation</code>. Used by all supervisors to run initializations that should run for every new supervisor instance. By default these are table initializers and initializers for local variables. If <code>None</code>, no further per supervisor-instance initialization is done automatically.</li>
<li><b><code>logdir</code></b>: A string. Optional path to a directory where to checkpoint the model and log events for the visualizer. Used by chief supervisors. The directory will be created if it does not exist.</li>
<li><b><code>summary_op</code></b>: An <code>Operation</code> that returns a Summary for the event logs. Used by chief supervisors if a <code>logdir</code> was specified. Defaults to the operation returned from summary.merge_all(). If <code>None</code>, summaries are not computed automatically.</li>
<li><b><code>saver</code></b>: A Saver object. Used by chief supervisors if a <code>logdir</code> was specified. Defaults to the saved returned by Saver(). If <code>None</code>, the model is not saved automatically.</li>
<li><b><code>global_step</code></b>: An integer Tensor of size 1 that counts steps. The value from 'global_step' is used in summaries and checkpoint filenames. Default to the op named 'global_step' in the graph if it exists, is of rank 1, size 1, and of type tf.int32 or tf.int64. If <code>None</code> the global step is not recorded in summaries and checkpoint files. Used by chief supervisors if a <code>logdir</code> was specified.</li>
<li><b><code>save_summaries_secs</code></b>: Number of seconds between the computation of summaries for the event log. Defaults to 120 seconds. Pass 0 to disable summaries.</li>
<li><b><code>save_model_secs</code></b>: Number of seconds between the creation of model checkpoints. Defaults to 600 seconds. Pass 0 to disable checkpoints.</li>
<li><b><code>recovery_wait_secs</code></b>: Number of seconds between checks that the model is ready. Used by supervisors when waiting for a chief supervisor to initialize or restore the model. Defaults to 30 seconds.</li>
<li><b><code>stop_grace_secs</code></b>: Grace period, in seconds, given to running threads to stop when <code>stop()</code> is called. Defaults to 120 seconds.</li>
<li><b><code>checkpoint_basename</code></b>: The basename for checkpoint saving.</li>
<li><b><code>session_manager</code></b>: <code>SessionManager</code>, which manages Session creation and recovery. If it is <code>None</code>, a default <code>SessionManager</code> will be created with the set of arguments passed in for backwards compatibility.</li>
<li><b><code>summary_writer</code></b>: <code>SummaryWriter</code> to use or <code>USE_DEFAULT</code>. Can be <code>None</code> to indicate that no summaries should be written.</li>
<li><b><code>init_fn</code></b>: Optional callable used to initialize the model. Called after the optional <code>init_op</code> is called. The callable must accept one argument, the session being initialized.</li>
</ul>
<h5 id="returns-31">Returns:</h5>
<p>A <code>Supervisor</code>.</p>
<hr />
<h4 id="tf.train.supervisor.managed_sessionmaster-confignone-start_standard_servicestrue-close_summary_writertrue"><code id="Supervisor.managed_session">tf.train.Supervisor.managed_session(master='', config=None, start_standard_services=True, close_summary_writer=True)</code></h4>
<p>Returns a context manager for a managed session.</p>
<p>This context manager creates and automatically recovers a session. It optionally starts the standard services that handle checkpoints and summaries. It monitors exceptions raised from the <code>with</code> block or from the services and stops the supervisor as needed.</p>
<p>The context manager is typically used as follows:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> train():
  sv <span class="op">=</span> tf.train.Supervisor(...)
  <span class="cf">with</span> sv.managed_session(<span class="op">&lt;</span>master<span class="op">&gt;</span>) <span class="im">as</span> sess:
    <span class="cf">for</span> step <span class="op">in</span> <span class="bu">xrange</span>(..):
      <span class="cf">if</span> sv.should_stop():
        <span class="cf">break</span>
      sess.run(<span class="op">&lt;</span>my training op<span class="op">&gt;</span>)
      ...do other things needed at each training step...</code></pre></div>
<p>An exception raised from the <code>with</code> block or one of the service threads is raised again when the block exits. This is done after stopping all threads and closing the session. For example, an <code>AbortedError</code> exception, raised in case of preemption of one of the workers in a distributed model, is raised again when the block exits.</p>
<p>If you want to retry the training loop in case of preemption you can do it as follows:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> main(...):
  <span class="cf">while</span> <span class="va">True</span>
    <span class="cf">try</span>:
      train()
    <span class="cf">except</span> tf.errors.Aborted:
      <span class="cf">pass</span></code></pre></div>
<p>As a special case, exceptions used for control flow, such as <code>OutOfRangeError</code> which reports that input queues are exhausted, are not raised again from the <code>with</code> block: they indicate a clean termination of the training loop and are considered normal termination.</p>
<h5 id="args-46">Args:</h5>
<ul>
<li><b><code>master</code></b>: name of the TensorFlow master to use. See the <code>tf.Session</code> constructor for how this is interpreted.</li>
<li><b><code>config</code></b>: Optional <code>ConfigProto</code> proto used to configure the session. Passed as-is to create the session.</li>
<li><b><code>start_standard_services</code></b>: Whether to start the standard services, such as checkpoint, summary and step counter.</li>
<li><b><code>close_summary_writer</code></b>: Whether to close the summary writer when closing the session. Defaults to True.</li>
</ul>
<h5 id="returns-32">Returns:</h5>
<p>A context manager that yields a <code>Session</code> restored from the latest checkpoint or initialized from scratch if not checkpoint exists. The session is closed when the <code>with</code> block exits.</p>
<hr />
<h4 id="tf.train.supervisor.prepare_or_wait_for_sessionmaster-confignone-wait_for_checkpointfalse-max_wait_secs7200-start_standard_servicestrue"><code id="Supervisor.prepare_or_wait_for_session">tf.train.Supervisor.prepare_or_wait_for_session(master='', config=None, wait_for_checkpoint=False, max_wait_secs=7200, start_standard_services=True)</code></h4>
<p>Make sure the model is ready to be used.</p>
<p>Create a session on 'master', recovering or initializing the model as needed, or wait for a session to be ready. If running as the chief and <code>start_standard_service</code> is set to True, also call the session manager to start the standard services.</p>
<h5 id="args-47">Args:</h5>
<ul>
<li><b><code>master</code></b>: name of the TensorFlow master to use. See the <code>tf.Session</code> constructor for how this is interpreted.</li>
<li><b><code>config</code></b>: Optional ConfigProto proto used to configure the session, which is passed as-is to create the session.</li>
<li><b><code>wait_for_checkpoint</code></b>: Whether we should wait for the availability of a checkpoint before creating Session. Defaults to False.</li>
<li><b><code>max_wait_secs</code></b>: Maximum time to wait for the session to become available.</li>
<li><b><code>start_standard_services</code></b>: Whether to start the standard services and the queue runners.</li>
</ul>
<h5 id="returns-33">Returns:</h5>
<p>A Session object that can be used to drive the model.</p>
<hr />
<h4 id="tf.train.supervisor.start_standard_servicessess"><code id="Supervisor.start_standard_services">tf.train.Supervisor.start_standard_services(sess)</code></h4>
<p>Start the standard services for 'sess'.</p>
<p>This starts services in the background. The services started depend on the parameters to the constructor and may include:</p>
<ul>
<li>A Summary thread computing summaries every save_summaries_secs.</li>
<li>A Checkpoint thread saving the model every save_model_secs.</li>
<li>A StepCounter thread measure step time.</li>
</ul>
<h5 id="args-48">Args:</h5>
<ul>
<li><b><code>sess</code></b>: A Session.</li>
</ul>
<h5 id="returns-34">Returns:</h5>
<p>A list of threads that are running the standard services. You can use the Supervisor's Coordinator to join these threads with: sv.coord.Join(<list of threads>)</p>
<h5 id="raises-23">Raises:</h5>
<ul>
<li><b><code>RuntimeError</code></b>: If called with a non-chief Supervisor.</li>
<li><b><code>ValueError</code></b>: If not <code>logdir</code> was passed to the constructor as the services need a log directory.</li>
</ul>
<hr />
<h4 id="tf.train.supervisor.start_queue_runnerssess-queue_runnersnone"><code id="Supervisor.start_queue_runners">tf.train.Supervisor.start_queue_runners(sess, queue_runners=None)</code></h4>
<p>Start threads for <code>QueueRunners</code>.</p>
<p>Note that the queue runners collected in the graph key <code>QUEUE_RUNNERS</code> are already started automatically when you create a session with the supervisor, so unless you have non-collected queue runners to start you do not need to call this explicitly.</p>
<h5 id="args-49">Args:</h5>
<ul>
<li><b><code>sess</code></b>: A <code>Session</code>.</li>
<li><b><code>queue_runners</code></b>: A list of <code>QueueRunners</code>. If not specified, we'll use the list of queue runners gathered in the graph under the key <code>GraphKeys.QUEUE_RUNNERS</code>.</li>
</ul>
<h5 id="returns-35">Returns:</h5>
<p>The list of threads started for the <code>QueueRunners</code>.</p>
<hr />
<h4 id="tf.train.supervisor.summary_computedsess-summary-global_stepnone"><code id="Supervisor.summary_computed">tf.train.Supervisor.summary_computed(sess, summary, global_step=None)</code></h4>
<p>Indicate that a summary was computed.</p>
<h5 id="args-50">Args:</h5>
<ul>
<li><b><code>sess</code></b>: A <code>Session</code> object.</li>
<li><b><code>summary</code></b>: A Summary proto, or a string holding a serialized summary proto.</li>
<li><b><code>global_step</code></b>: Int. global step this summary is associated with. If <code>None</code>, it will try to fetch the current step.</li>
</ul>
<h5 id="raises-24">Raises:</h5>
<ul>
<li><b><code>TypeError</code></b>: if 'summary' is not a Summary proto or a string.</li>
<li><b><code>RuntimeError</code></b>: if the Supervisor was created without a <code>logdir</code>.</li>
</ul>
<hr />
<h4 id="tf.train.supervisor.stopthreadsnone-close_summary_writertrue"><code id="Supervisor.stop">tf.train.Supervisor.stop(threads=None, close_summary_writer=True)</code></h4>
<p>Stop the services and the coordinator.</p>
<p>This does not close the session.</p>
<h5 id="args-51">Args:</h5>
<ul>
<li><b><code>threads</code></b>: Optional list of threads to join with the coordinator. If <code>None</code>, defaults to the threads running the standard services, the threads started for <code>QueueRunners</code>, and the threads started by the <code>loop()</code> method. To wait on additional threads, pass the list in this parameter.</li>
<li><b><code>close_summary_writer</code></b>: Whether to close the <code>summary_writer</code>. Defaults to <code>True</code> if the summary writer was created by the supervisor, <code>False</code> otherwise.</li>
</ul>
<hr />
<h4 id="tf.train.supervisor.request_stopexnone"><code id="Supervisor.request_stop">tf.train.Supervisor.request_stop(ex=None)</code></h4>
<p>Request that the coordinator stop the threads.</p>
<p>See <code>Coordinator.request_stop()</code>.</p>
<h5 id="args-52">Args:</h5>
<ul>
<li><b><code>ex</code></b>: Optional <code>Exception</code>, or Python <code>exc_info</code> tuple as returned by <code>sys.exc_info()</code>. If this is the first call to <code>request_stop()</code> the corresponding exception is recorded and re-raised from <code>join()</code>.</li>
</ul>
<hr />
<h4 id="tf.train.supervisor.should_stop"><code id="Supervisor.should_stop">tf.train.Supervisor.should_stop()</code></h4>
<p>Check if the coordinator was told to stop.</p>
<p>See <code>Coordinator.should_stop()</code>.</p>
<h5 id="returns-36">Returns:</h5>
<p>True if the coordinator was told to stop, False otherwise.</p>
<hr />
<h4 id="tf.train.supervisor.stop_on_exception"><code id="Supervisor.stop_on_exception">tf.train.Supervisor.stop_on_exception()</code></h4>
<p>Context handler to stop the supervisor when an exception is raised.</p>
<p>See <code>Coordinator.stop_on_exception()</code>.</p>
<h5 id="returns-37">Returns:</h5>
<p>A context handler.</p>
<hr />
<h4 id="tf.train.supervisor.wait_for_stop"><code id="Supervisor.wait_for_stop">tf.train.Supervisor.wait_for_stop()</code></h4>
<p>Block waiting for the coordinator to stop.</p>
<h4 id="other-methods-1">Other Methods</h4>
<hr />
<h4 id="tf.train.supervisor.looptimer_interval_secs-target-argsnone-kwargsnone"><code id="Supervisor.Loop">tf.train.Supervisor.Loop(timer_interval_secs, target, args=None, kwargs=None)</code></h4>
<p>Start a LooperThread that calls a function periodically.</p>
<p>If <code>timer_interval_secs</code> is None the thread calls <code>target(*args, **kwargs)</code> repeatedly. Otherwise it calls it every <code>timer_interval_secs</code> seconds. The thread terminates when a stop is requested.</p>
<p>The started thread is added to the list of threads managed by the supervisor so it does not need to be passed to the <code>stop()</code> method.</p>
<h5 id="args-53">Args:</h5>
<ul>
<li><b><code>timer_interval_secs</code></b>: Number. Time boundaries at which to call <code>target</code>.</li>
<li><b><code>target</code></b>: A callable object.</li>
<li><b><code>args</code></b>: Optional arguments to pass to <code>target</code> when calling it.</li>
<li><b><code>kwargs</code></b>: Optional keyword arguments to pass to <code>target</code> when calling it.</li>
</ul>
<h5 id="returns-38">Returns:</h5>
<p>The started thread.</p>
<hr />
<h4 id="tf.train.supervisor.preparesessionmaster-confignone-wait_for_checkpointfalse-max_wait_secs7200-start_standard_servicestrue"><code id="Supervisor.PrepareSession">tf.train.Supervisor.PrepareSession(master='', config=None, wait_for_checkpoint=False, max_wait_secs=7200, start_standard_services=True)</code></h4>
<p>Make sure the model is ready to be used.</p>
<p>Create a session on 'master', recovering or initializing the model as needed, or wait for a session to be ready. If running as the chief and <code>start_standard_service</code> is set to True, also call the session manager to start the standard services.</p>
<h5 id="args-54">Args:</h5>
<ul>
<li><b><code>master</code></b>: name of the TensorFlow master to use. See the <code>tf.Session</code> constructor for how this is interpreted.</li>
<li><b><code>config</code></b>: Optional ConfigProto proto used to configure the session, which is passed as-is to create the session.</li>
<li><b><code>wait_for_checkpoint</code></b>: Whether we should wait for the availability of a checkpoint before creating Session. Defaults to False.</li>
<li><b><code>max_wait_secs</code></b>: Maximum time to wait for the session to become available.</li>
<li><b><code>start_standard_services</code></b>: Whether to start the standard services and the queue runners.</li>
</ul>
<h5 id="returns-39">Returns:</h5>
<p>A Session object that can be used to drive the model.</p>
<hr />
<h4 id="tf.train.supervisor.requeststopexnone"><code id="Supervisor.RequestStop">tf.train.Supervisor.RequestStop(ex=None)</code></h4>
<p>Request that the coordinator stop the threads.</p>
<p>See <code>Coordinator.request_stop()</code>.</p>
<h5 id="args-55">Args:</h5>
<ul>
<li><b><code>ex</code></b>: Optional <code>Exception</code>, or Python <code>exc_info</code> tuple as returned by <code>sys.exc_info()</code>. If this is the first call to <code>request_stop()</code> the corresponding exception is recorded and re-raised from <code>join()</code>.</li>
</ul>
<hr />
<h4 id="tf.train.supervisor.shouldstop"><code id="Supervisor.ShouldStop">tf.train.Supervisor.ShouldStop()</code></h4>
<p>Check if the coordinator was told to stop.</p>
<p>See <code>Coordinator.should_stop()</code>.</p>
<h5 id="returns-40">Returns:</h5>
<p>True if the coordinator was told to stop, False otherwise.</p>
<hr />
<h4 id="tf.train.supervisor.startqueuerunnerssess-queue_runnersnone"><code id="Supervisor.StartQueueRunners">tf.train.Supervisor.StartQueueRunners(sess, queue_runners=None)</code></h4>
<p>Start threads for <code>QueueRunners</code>.</p>
<p>Note that the queue runners collected in the graph key <code>QUEUE_RUNNERS</code> are already started automatically when you create a session with the supervisor, so unless you have non-collected queue runners to start you do not need to call this explicitly.</p>
<h5 id="args-56">Args:</h5>
<ul>
<li><b><code>sess</code></b>: A <code>Session</code>.</li>
<li><b><code>queue_runners</code></b>: A list of <code>QueueRunners</code>. If not specified, we'll use the list of queue runners gathered in the graph under the key <code>GraphKeys.QUEUE_RUNNERS</code>.</li>
</ul>
<h5 id="returns-41">Returns:</h5>
<p>The list of threads started for the <code>QueueRunners</code>.</p>
<hr />
<h4 id="tf.train.supervisor.startstandardservicessess"><code id="Supervisor.StartStandardServices">tf.train.Supervisor.StartStandardServices(sess)</code></h4>
<p>Start the standard services for 'sess'.</p>
<p>This starts services in the background. The services started depend on the parameters to the constructor and may include:</p>
<ul>
<li>A Summary thread computing summaries every save_summaries_secs.</li>
<li>A Checkpoint thread saving the model every save_model_secs.</li>
<li>A StepCounter thread measure step time.</li>
</ul>
<h5 id="args-57">Args:</h5>
<ul>
<li><b><code>sess</code></b>: A Session.</li>
</ul>
<h5 id="returns-42">Returns:</h5>
<p>A list of threads that are running the standard services. You can use the Supervisor's Coordinator to join these threads with: sv.coord.Join(<list of threads>)</p>
<h5 id="raises-25">Raises:</h5>
<ul>
<li><b><code>RuntimeError</code></b>: If called with a non-chief Supervisor.</li>
<li><b><code>ValueError</code></b>: If not <code>logdir</code> was passed to the constructor as the services need a log directory.</li>
</ul>
<hr />
<h4 id="tf.train.supervisor.stopthreadsnone-close_summary_writertrue-1"><code id="Supervisor.Stop">tf.train.Supervisor.Stop(threads=None, close_summary_writer=True)</code></h4>
<p>Stop the services and the coordinator.</p>
<p>This does not close the session.</p>
<h5 id="args-58">Args:</h5>
<ul>
<li><b><code>threads</code></b>: Optional list of threads to join with the coordinator. If <code>None</code>, defaults to the threads running the standard services, the threads started for <code>QueueRunners</code>, and the threads started by the <code>loop()</code> method. To wait on additional threads, pass the list in this parameter.</li>
<li><b><code>close_summary_writer</code></b>: Whether to close the <code>summary_writer</code>. Defaults to <code>True</code> if the summary writer was created by the supervisor, <code>False</code> otherwise.</li>
</ul>
<hr />
<h4 id="tf.train.supervisor.stoponexception"><code id="Supervisor.StopOnException">tf.train.Supervisor.StopOnException()</code></h4>
<p>Context handler to stop the supervisor when an exception is raised.</p>
<p>See <code>Coordinator.stop_on_exception()</code>.</p>
<h5 id="returns-43">Returns:</h5>
<p>A context handler.</p>
<hr />
<h4 id="tf.train.supervisor.summarycomputedsess-summary-global_stepnone"><code id="Supervisor.SummaryComputed">tf.train.Supervisor.SummaryComputed(sess, summary, global_step=None)</code></h4>
<p>Indicate that a summary was computed.</p>
<h5 id="args-59">Args:</h5>
<ul>
<li><b><code>sess</code></b>: A <code>Session</code> object.</li>
<li><b><code>summary</code></b>: A Summary proto, or a string holding a serialized summary proto.</li>
<li><b><code>global_step</code></b>: Int. global step this summary is associated with. If <code>None</code>, it will try to fetch the current step.</li>
</ul>
<h5 id="raises-26">Raises:</h5>
<ul>
<li><b><code>TypeError</code></b>: if 'summary' is not a Summary proto or a string.</li>
<li><b><code>RuntimeError</code></b>: if the Supervisor was created without a <code>logdir</code>.</li>
</ul>
<hr />
<h4 id="tf.train.supervisor.waitforstop"><code id="Supervisor.WaitForStop">tf.train.Supervisor.WaitForStop()</code></h4>
<p>Block waiting for the coordinator to stop.</p>
<hr />
<h4 id="tf.train.supervisor.coord"><code id="Supervisor.coord">tf.train.Supervisor.coord</code></h4>
<p>Return the Coordinator used by the Supervisor.</p>
<p>The Coordinator can be useful if you want to run multiple threads during your training.</p>
<h5 id="returns-44">Returns:</h5>
<p>A Coordinator object.</p>
<hr />
<h4 id="tf.train.supervisor.global_step"><code id="Supervisor.global_step">tf.train.Supervisor.global_step</code></h4>
<p>Return the global_step Tensor used by the supervisor.</p>
<h5 id="returns-45">Returns:</h5>
<p>An integer Tensor for the global_step.</p>
<hr />
<h4 id="tf.train.supervisor.init_feed_dict"><code id="Supervisor.init_feed_dict">tf.train.Supervisor.init_feed_dict</code></h4>
<p>Return the feed dictionary used when evaluating the <code>init_op</code>.</p>
<h5 id="returns-46">Returns:</h5>
<p>A feed dictionary or <code>None</code>.</p>
<hr />
<h4 id="tf.train.supervisor.init_op"><code id="Supervisor.init_op">tf.train.Supervisor.init_op</code></h4>
<p>Return the Init Op used by the supervisor.</p>
<h5 id="returns-47">Returns:</h5>
<p>An Op or <code>None</code>.</p>
<hr />
<h4 id="tf.train.supervisor.is_chief"><code id="Supervisor.is_chief">tf.train.Supervisor.is_chief</code></h4>
<p>Return True if this is a chief supervisor.</p>
<h5 id="returns-48">Returns:</h5>
<p>A bool.</p>
<hr />
<h4 id="tf.train.supervisor.looptimer_interval_secs-target-argsnone-kwargsnone-1"><code id="Supervisor.loop">tf.train.Supervisor.loop(timer_interval_secs, target, args=None, kwargs=None)</code></h4>
<p>Start a LooperThread that calls a function periodically.</p>
<p>If <code>timer_interval_secs</code> is None the thread calls <code>target(*args, **kwargs)</code> repeatedly. Otherwise it calls it every <code>timer_interval_secs</code> seconds. The thread terminates when a stop is requested.</p>
<p>The started thread is added to the list of threads managed by the supervisor so it does not need to be passed to the <code>stop()</code> method.</p>
<h5 id="args-60">Args:</h5>
<ul>
<li><b><code>timer_interval_secs</code></b>: Number. Time boundaries at which to call <code>target</code>.</li>
<li><b><code>target</code></b>: A callable object.</li>
<li><b><code>args</code></b>: Optional arguments to pass to <code>target</code> when calling it.</li>
<li><b><code>kwargs</code></b>: Optional keyword arguments to pass to <code>target</code> when calling it.</li>
</ul>
<h5 id="returns-49">Returns:</h5>
<p>The started thread.</p>
<hr />
<h4 id="tf.train.supervisor.ready_for_local_init_op"><code id="Supervisor.ready_for_local_init_op">tf.train.Supervisor.ready_for_local_init_op</code></h4>
<hr />
<h4 id="tf.train.supervisor.ready_op"><code id="Supervisor.ready_op">tf.train.Supervisor.ready_op</code></h4>
<p>Return the Ready Op used by the supervisor.</p>
<h5 id="returns-50">Returns:</h5>
<p>An Op or <code>None</code>.</p>
<hr />
<h4 id="tf.train.supervisor.save_model_secs"><code id="Supervisor.save_model_secs">tf.train.Supervisor.save_model_secs</code></h4>
<p>Return the delay between checkpoints.</p>
<h5 id="returns-51">Returns:</h5>
<p>A timestamp.</p>
<hr />
<h4 id="tf.train.supervisor.save_path"><code id="Supervisor.save_path">tf.train.Supervisor.save_path</code></h4>
<p>Return the save path used by the supervisor.</p>
<h5 id="returns-52">Returns:</h5>
<p>A string.</p>
<hr />
<h4 id="tf.train.supervisor.save_summaries_secs"><code id="Supervisor.save_summaries_secs">tf.train.Supervisor.save_summaries_secs</code></h4>
<p>Return the delay between summary computations.</p>
<h5 id="returns-53">Returns:</h5>
<p>A timestamp.</p>
<hr />
<h4 id="tf.train.supervisor.saver"><code id="Supervisor.saver">tf.train.Supervisor.saver</code></h4>
<p>Return the Saver used by the supervisor.</p>
<h5 id="returns-54">Returns:</h5>
<p>A Saver object.</p>
<hr />
<h4 id="tf.train.supervisor.session_manager"><code id="Supervisor.session_manager">tf.train.Supervisor.session_manager</code></h4>
<p>Return the SessionManager used by the Supervisor.</p>
<h5 id="returns-55">Returns:</h5>
<p>A SessionManager object.</p>
<hr />
<h4 id="tf.train.supervisor.summary_op"><code id="Supervisor.summary_op">tf.train.Supervisor.summary_op</code></h4>
<p>Return the Summary Tensor used by the chief supervisor.</p>
<h5 id="returns-56">Returns:</h5>
<p>A string Tensor for the summary or <code>None</code>.</p>
<hr />
<h4 id="tf.train.supervisor.summary_writer"><code id="Supervisor.summary_writer">tf.train.Supervisor.summary_writer</code></h4>
<p>Return the SummaryWriter used by the chief supervisor.</p>
<h5 id="returns-57">Returns:</h5>
<p>A SummaryWriter.</p>
<hr />
<h3 id="class-tf.train.sessionmanager"><a name="//apple_ref/cpp/Class/SessionManager" class="dashAnchor"></a><code id="SessionManager">class tf.train.SessionManager</code></h3>
<p>Training helper that restores from checkpoint and creates session.</p>
<p>This class is a small wrapper that takes care of session creation and checkpoint recovery. It also provides functions that to facilitate coordination among multiple training threads or processes.</p>
<ul>
<li>Checkpointing trained variables as the training progresses.</li>
<li>Initializing variables on startup, restoring them from the most recent checkpoint after a crash, or wait for checkpoints to become available.</li>
</ul>
<h3 id="usage-2">Usage:</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">with</span> tf.Graph().as_default():
   ...add operations to the graph...
  <span class="co"># Create a SessionManager that will checkpoint the model in &#39;/tmp/mydir&#39;.</span>
  sm <span class="op">=</span> SessionManager()
  sess <span class="op">=</span> sm.prepare_session(master, init_op, saver, checkpoint_dir)
  <span class="co"># Use the session to train the graph.</span>
  <span class="cf">while</span> <span class="va">True</span>:
    sess.run(<span class="op">&lt;</span>my_train_op<span class="op">&gt;</span>)</code></pre></div>
<p><code>prepare_session()</code> initializes or restores a model. It requires <code>init_op</code> and <code>saver</code> as an argument.</p>
<p>A second process could wait for the model to be ready by doing the following:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">with</span> tf.Graph().as_default():
   ...add operations to the graph...
  <span class="co"># Create a SessionManager that will wait for the model to become ready.</span>
  sm <span class="op">=</span> SessionManager()
  sess <span class="op">=</span> sm.wait_for_session(master)
  <span class="co"># Use the session to train the graph.</span>
  <span class="cf">while</span> <span class="va">True</span>:
    sess.run(<span class="op">&lt;</span>my_train_op<span class="op">&gt;</span>)</code></pre></div>
<p><code>wait_for_session()</code> waits for a model to be initialized by other processes. - - -</p>
<h4 id="tf.train.sessionmanager.__init__local_init_opnone-ready_opnone-ready_for_local_init_opnone-graphnone-recovery_wait_secs30"><code id="SessionManager.__init__">tf.train.SessionManager.__init__(local_init_op=None, ready_op=None, ready_for_local_init_op=None, graph=None, recovery_wait_secs=30)</code></h4>
<p>Creates a SessionManager.</p>
<p>The <code>local_init_op</code> is an <code>Operation</code> that is run always after a new session was created. If <code>None</code>, this step is skipped.</p>
<p>The <code>ready_op</code> is an <code>Operation</code> used to check if the model is ready. The model is considered ready if that operation returns an empty 1D string tensor. If the operation returns a non empty 1D string tensor, the elements are concatenated and used to indicate to the user why the model is not ready.</p>
<p>The <code>ready_for_local_init_op</code> is an <code>Operation</code> used to check if the model is ready to run local_init_op. The model is considered ready if that operation returns an empty 1D string tensor. If the operation returns a non empty 1D string tensor, the elements are concatenated and used to indicate to the user why the model is not ready.</p>
<p>If <code>ready_op</code> is <code>None</code>, the model is not checked for readiness.</p>
<p><code>recovery_wait_secs</code> is the number of seconds between checks that the model is ready. It is used by processes to wait for a model to be initialized or restored. Defaults to 30 seconds.</p>
<h5 id="args-61">Args:</h5>
<ul>
<li><b><code>local_init_op</code></b>: An <code>Operation</code> run immediately after session creation. Usually used to initialize tables and local variables.</li>
<li><b><code>ready_op</code></b>: An <code>Operation</code> to check if the model is initialized.</li>
<li><b><code>ready_for_local_init_op</code></b>: An <code>Operation</code> to check if the model is ready to run local_init_op.</li>
<li><b><code>graph</code></b>: The <code>Graph</code> that the model will use.</li>
<li><b><code>recovery_wait_secs</code></b>: Seconds between checks for the model to be ready.</li>
</ul>
<h5 id="raises-27">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If ready_for_local_init_op is not None but local_init_op is None</li>
</ul>
<hr />
<h4 id="tf.train.sessionmanager.prepare_sessionmaster-init_opnone-savernone-checkpoint_dirnone-checkpoint_filename_with_pathnone-wait_for_checkpointfalse-max_wait_secs7200-confignone-init_feed_dictnone-init_fnnone"><code id="SessionManager.prepare_session">tf.train.SessionManager.prepare_session(master, init_op=None, saver=None, checkpoint_dir=None, checkpoint_filename_with_path=None, wait_for_checkpoint=False, max_wait_secs=7200, config=None, init_feed_dict=None, init_fn=None)</code></h4>
<p>Creates a <code>Session</code>. Makes sure the model is ready to be used.</p>
<p>Creates a <code>Session</code> on 'master'. If a <code>saver</code> object is passed in, and <code>checkpoint_dir</code> points to a directory containing valid checkpoint files, then it will try to recover the model from checkpoint. If no checkpoint files are available, and <code>wait_for_checkpoint</code> is <code>True</code>, then the process would check every <code>recovery_wait_secs</code>, up to <code>max_wait_secs</code>, for recovery to succeed.</p>
<p>If the model cannot be recovered successfully then it is initialized by either running the provided <code>init_op</code>, or calling the provided <code>init_fn</code>. The local_init_op is also run after init_op and init_fn, regardless of whether the model was recovered successfully, but only if ready_for_local_init_op passes.</p>
<p>It is an error if the model cannot be recovered and no <code>init_op</code> or <code>init_fn</code> or <code>local_init_op</code> are passed.</p>
<h5 id="args-62">Args:</h5>
<ul>
<li><b><code>master</code></b>: <code>String</code> representation of the TensorFlow master to use.</li>
<li><b><code>init_op</code></b>: Optional <code>Operation</code> used to initialize the model.</li>
<li><b><code>saver</code></b>: A <code>Saver</code> object used to restore a model.</li>
<li><b><code>checkpoint_dir</code></b>: Path to the checkpoint files. The latest checkpoint in the dir will be used to restore.</li>
<li><b><code>checkpoint_filename_with_path</code></b>: Full file name path to the checkpoint file.</li>
<li><b><code>wait_for_checkpoint</code></b>: Whether to wait for checkpoint to become available.</li>
<li><b><code>max_wait_secs</code></b>: Maximum time to wait for checkpoints to become available.</li>
<li><b><code>config</code></b>: Optional <code>ConfigProto</code> proto used to configure the session.</li>
<li><b><code>init_feed_dict</code></b>: Optional dictionary that maps <code>Tensor</code> objects to feed values. This feed dictionary is passed to the session <code>run()</code> call when running the init op.</li>
<li><b><code>init_fn</code></b>: Optional callable used to initialize the model. Called after the optional <code>init_op</code> is called. The callable must accept one argument, the session being initialized.</li>
</ul>
<h5 id="returns-58">Returns:</h5>
<p>A <code>Session</code> object that can be used to drive the model.</p>
<h5 id="raises-28">Raises:</h5>
<ul>
<li><b><code>RuntimeError</code></b>: If the model cannot be initialized or recovered.</li>
</ul>
<h5 id="raises-29">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If both checkpoint_dir and checkpoint_filename_with_path are set.</li>
</ul>
<hr />
<h4 id="tf.train.sessionmanager.recover_sessionmaster-savernone-checkpoint_dirnone-checkpoint_filename_with_pathnone-wait_for_checkpointfalse-max_wait_secs7200-confignone"><code id="SessionManager.recover_session">tf.train.SessionManager.recover_session(master, saver=None, checkpoint_dir=None, checkpoint_filename_with_path=None, wait_for_checkpoint=False, max_wait_secs=7200, config=None)</code></h4>
<p>Creates a <code>Session</code>, recovering if possible.</p>
<p>Creates a new session on 'master'. If the session is not initialized and can be recovered from a checkpoint, recover it.</p>
<h5 id="args-63">Args:</h5>
<ul>
<li><b><code>master</code></b>: <code>String</code> representation of the TensorFlow master to use.</li>
<li><b><code>saver</code></b>: A <code>Saver</code> object used to restore a model.</li>
<li><b><code>checkpoint_dir</code></b>: Path to the checkpoint files. The latest checkpoint in the dir will be used to restore.</li>
<li><b><code>checkpoint_filename_with_path</code></b>: Full file name path to the checkpoint file.</li>
<li><b><code>wait_for_checkpoint</code></b>: Whether to wait for checkpoint to become available.</li>
<li><b><code>max_wait_secs</code></b>: Maximum time to wait for checkpoints to become available.</li>
<li><b><code>config</code></b>: Optional <code>ConfigProto</code> proto used to configure the session.</li>
</ul>
<h5 id="returns-59">Returns:</h5>
<p>A pair (sess, initialized) where 'initialized' is <code>True</code> if the session could be recovered and initialized, <code>False</code> otherwise.</p>
<h5 id="raises-30">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If both checkpoint_dir and checkpoint_filename_with_path are set.</li>
</ul>
<hr />
<h4 id="tf.train.sessionmanager.wait_for_sessionmaster-confignone-max_wait_secsinf"><code id="SessionManager.wait_for_session">tf.train.SessionManager.wait_for_session(master, config=None, max_wait_secs=inf)</code></h4>
<p>Creates a new <code>Session</code> and waits for model to be ready.</p>
<p>Creates a new <code>Session</code> on 'master'. Waits for the model to be initialized or recovered from a checkpoint. It's expected that another thread or process will make the model ready, and that this is intended to be used by threads/processes that participate in a distributed training configuration where a different thread/process is responsible for initializing or recovering the model being trained.</p>
<p>NB: The amount of time this method waits for the session is bounded by max_wait_secs. By default, this function will wait indefinitely.</p>
<h5 id="args-64">Args:</h5>
<ul>
<li><b><code>master</code></b>: <code>String</code> representation of the TensorFlow master to use.</li>
<li><b><code>config</code></b>: Optional ConfigProto proto used to configure the session.</li>
<li><b><code>max_wait_secs</code></b>: Maximum time to wait for the session to become available.</li>
</ul>
<h5 id="returns-60">Returns:</h5>
<p>A <code>Session</code>. May be None if the operation exceeds the timeout specified by config.operation_timeout_in_ms.</p>
<h5 id="raises-31">Raises:</h5>
<p>tf.DeadlineExceededError: if the session is not available after max_wait_secs.</p>
<hr />
<h3 id="class-tf.train.clusterspec"><a name="//apple_ref/cpp/Class/ClusterSpec" class="dashAnchor"></a><code id="ClusterSpec">class tf.train.ClusterSpec</code></h3>
<p>Represents a cluster as a set of &quot;tasks&quot;, organized into &quot;jobs&quot;.</p>
<p>A <code>tf.train.ClusterSpec</code> represents the set of processes that participate in a distributed TensorFlow computation. Every <a href="#Server"><code>tf.train.Server</code></a> is constructed in a particular cluster.</p>
<p>To create a cluster with two jobs and five tasks, you specify the mapping from job names to lists of network addresses (typically hostname-port pairs).</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">cluster <span class="op">=</span> tf.train.ClusterSpec({<span class="st">&quot;worker&quot;</span>: [<span class="st">&quot;worker0.example.com:2222&quot;</span>,
                                           <span class="st">&quot;worker1.example.com:2222&quot;</span>,
                                           <span class="co">&quot;worker2.example.com:2222&quot;</span>],
                                <span class="co">&quot;ps&quot;</span>: [<span class="st">&quot;ps0.example.com:2222&quot;</span>,
                                       <span class="co">&quot;ps1.example.com:2222&quot;</span>]})</code></pre></div>
<p>Each job may also be specified as a sparse mapping from task indices to network addresses. This enables a server to be configured without needing to know the identity of (for example) all other worker tasks:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">cluster <span class="op">=</span> tf.train.ClusterSpec({<span class="st">&quot;worker&quot;</span>: {<span class="dv">1</span>: <span class="st">&quot;worker1.example.com:2222&quot;</span>},
                                <span class="st">&quot;ps&quot;</span>: [<span class="st">&quot;ps0.example.com:2222&quot;</span>,
                                       <span class="co">&quot;ps1.example.com:2222&quot;</span>]})</code></pre></div>
<hr />
<h4 id="tf.train.clusterspec.as_cluster_def"><code id="ClusterSpec.as_cluster_def">tf.train.ClusterSpec.as_cluster_def()</code></h4>
<p>Returns a <code>tf.train.ClusterDef</code> protocol buffer based on this cluster.</p>
<hr />
<h4 id="tf.train.clusterspec.as_dict"><code id="ClusterSpec.as_dict">tf.train.ClusterSpec.as_dict()</code></h4>
<p>Returns a dictionary from job names to their tasks.</p>
<p>For each job, if the task index space is dense, the corresponding value will be a list of network addresses; otherwise it will be a dictionary mapping (sparse) task indices to the corresponding addresses.</p>
<h5 id="returns-61">Returns:</h5>
<p>A dictionary mapping job names to lists or dictionaries describing the tasks in those jobs.</p>
<h4 id="other-methods-2">Other Methods</h4>
<hr />
<h4 id="tf.train.clusterspec.__bool__"><code id="ClusterSpec.__bool__">tf.train.ClusterSpec.__bool__()</code></h4>
<hr />
<h4 id="tf.train.clusterspec.__eq__other"><code id="ClusterSpec.__eq__">tf.train.ClusterSpec.__eq__(other)</code></h4>
<hr />
<h4 id="tf.train.clusterspec.__init__cluster"><code id="ClusterSpec.__init__">tf.train.ClusterSpec.__init__(cluster)</code></h4>
<p>Creates a <code>ClusterSpec</code>.</p>
<h5 id="args-65">Args:</h5>
<ul>
<li><b><code>cluster</code></b>: A dictionary mapping one or more job names to (i) a list of network addresses, or (ii) a dictionary mapping integer task indices to network addresses; or a <code>tf.train.ClusterDef</code> protocol buffer.</li>
</ul>
<h5 id="raises-32">Raises:</h5>
<ul>
<li><b><code>TypeError</code></b>: If <code>cluster</code> is not a dictionary mapping strings to lists of strings, and not a <code>tf.train.ClusterDef</code> protobuf.</li>
</ul>
<hr />
<h4 id="tf.train.clusterspec.__ne__other"><code id="ClusterSpec.__ne__">tf.train.ClusterSpec.__ne__(other)</code></h4>
<hr />
<h4 id="tf.train.clusterspec.__nonzero__"><code id="ClusterSpec.__nonzero__">tf.train.ClusterSpec.__nonzero__()</code></h4>
<hr />
<h4 id="tf.train.clusterspec.job_tasksjob_name"><code id="ClusterSpec.job_tasks">tf.train.ClusterSpec.job_tasks(job_name)</code></h4>
<p>Returns a mapping from task ID to address in the given job.</p>
<p>NOTE: For backwards compatibility, this method returns a list. If the given job was defined with a sparse set of task indices, the length of this list may not reflect the number of tasks defined in this job. Use the <a href="#ClusterSpec.num_tasks"><code>num_tasks()</code></a> method to find the number of tasks defined in a particular job.</p>
<h5 id="args-66">Args:</h5>
<ul>
<li><b><code>job_name</code></b>: The string name of a job in this cluster.</li>
</ul>
<h5 id="returns-62">Returns:</h5>
<p>A list of task addresses, where the index in the list corresponds to the task index of each task. The list may contain <code>None</code> if the job was defined with a sparse set of task indices.</p>
<h5 id="raises-33">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If <code>job_name</code> does not name a job in this cluster.</li>
</ul>
<hr />
<h4 id="tf.train.clusterspec.jobs"><code id="ClusterSpec.jobs">tf.train.ClusterSpec.jobs</code></h4>
<p>Returns a list of job names in this cluster.</p>
<h5 id="returns-63">Returns:</h5>
<p>A list of strings, corresponding to the names of jobs in this cluster.</p>
<hr />
<h4 id="tf.train.clusterspec.num_tasksjob_name"><code id="ClusterSpec.num_tasks">tf.train.ClusterSpec.num_tasks(job_name)</code></h4>
<p>Returns the number of tasks defined in the given job.</p>
<h5 id="args-67">Args:</h5>
<ul>
<li><b><code>job_name</code></b>: The string name of a job in this cluster.</li>
</ul>
<h5 id="returns-64">Returns:</h5>
<p>The number of tasks defined in the given job.</p>
<h5 id="raises-34">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If <code>job_name</code> does not name a job in this cluster.</li>
</ul>
<hr />
<h4 id="tf.train.clusterspec.task_addressjob_name-task_index"><code id="ClusterSpec.task_address">tf.train.ClusterSpec.task_address(job_name, task_index)</code></h4>
<p>Returns the address of the given task in the given job.</p>
<h5 id="args-68">Args:</h5>
<ul>
<li><b><code>job_name</code></b>: The string name of a job in this cluster.</li>
<li><b><code>task_index</code></b>: A non-negative integer.</li>
</ul>
<h5 id="returns-65">Returns:</h5>
<p>The address of the given task in the given job.</p>
<h5 id="raises-35">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If <code>job_name</code> does not name a job in this cluster, or no task with index <code>task_index</code> is defined in that job.</li>
</ul>
<hr />
<h4 id="tf.train.clusterspec.task_indicesjob_name"><code id="ClusterSpec.task_indices">tf.train.ClusterSpec.task_indices(job_name)</code></h4>
<p>Returns a list of valid task indices in the given job.</p>
<h5 id="args-69">Args:</h5>
<ul>
<li><b><code>job_name</code></b>: The string name of a job in this cluster.</li>
</ul>
<h5 id="returns-66">Returns:</h5>
<p>A list of valid task indices in the given job.</p>
<h5 id="raises-36">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If <code>job_name</code> does not name a job in this cluster, or no task with index <code>task_index</code> is defined in that job.</li>
</ul>
<hr />
<h3 id="tf.train.replica_device_setterps_tasks0-ps_devicejobps-worker_devicejobworker-merge_devicestrue-clusternone-ps_opsnone-ps_strategynone"><a name="//apple_ref/cpp/Function/replica_device_setter" class="dashAnchor"></a><code id="replica_device_setter">tf.train.replica_device_setter(ps_tasks=0, ps_device='/job:ps', worker_device='/job:worker', merge_devices=True, cluster=None, ps_ops=None, ps_strategy=None)</code></h3>
<p>Return a <code>device function</code> to use when building a Graph for replicas.</p>
<p>Device Functions are used in <code>with tf.device(device_function):</code> statement to automatically assign devices to <code>Operation</code> objects as they are constructed, Device constraints are added from the inner-most context first, working outwards. The merging behavior adds constraints to fields that are yet unset by a more inner context. Currently the fields are (job, task, cpu/gpu).</p>
<p>If <code>cluster</code> is <code>None</code>, and <code>ps_tasks</code> is 0, the returned function is a no-op. Otherwise, the value of <code>ps_tasks</code> is derived from <code>cluster</code>.</p>
<p>By default, only Variable ops are placed on ps tasks, and the placement strategy is round-robin over all ps tasks. A custom <code>ps_strategy</code> may be used to do more intelligent placement, such as <code>tf.contrib.training.GreedyLoadBalancingStrategy</code>.</p>
<p>For example,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># To build a cluster with two ps jobs on hosts ps0 and ps1, and 3 worker</span>
<span class="co"># jobs on hosts worker0, worker1 and worker2.</span>
cluster_spec <span class="op">=</span> {
    <span class="st">&quot;ps&quot;</span>: [<span class="st">&quot;ps0:2222&quot;</span>, <span class="st">&quot;ps1:2222&quot;</span>],
    <span class="co">&quot;worker&quot;</span>: [<span class="st">&quot;worker0:2222&quot;</span>, <span class="st">&quot;worker1:2222&quot;</span>, <span class="st">&quot;worker2:2222&quot;</span>]}
<span class="cf">with</span> tf.device(tf.train.replica_device_setter(cluster<span class="op">=</span>cluster_spec)):
  <span class="co"># Build your graph</span>
  v1 <span class="op">=</span> tf.Variable(...)  <span class="co"># assigned to /job:ps/task:0</span>
  v2 <span class="op">=</span> tf.Variable(...)  <span class="co"># assigned to /job:ps/task:1</span>
  v3 <span class="op">=</span> tf.Variable(...)  <span class="co"># assigned to /job:ps/task:0</span>
<span class="co"># Run compute</span></code></pre></div>
<h5 id="args-70">Args:</h5>
<ul>
<li><b><code>ps_tasks</code></b>: Number of tasks in the <code>ps</code> job. Ignored if <code>cluster</code> is provided.</li>
<li><b><code>ps_device</code></b>: String. Device of the <code>ps</code> job. If empty no <code>ps</code> job is used. Defaults to <code>ps</code>.</li>
<li><b><code>worker_device</code></b>: String. Device of the <code>worker</code> job. If empty no <code>worker</code> job is used.</li>
<li><b><code>merge_devices</code></b>: <code>Boolean</code>. If <code>True</code>, merges or only sets a device if the device constraint is completely unset. merges device specification rather than overriding them.</li>
<li><b><code>cluster</code></b>: <code>ClusterDef</code> proto or <code>ClusterSpec</code>.</li>
<li><b><code>ps_ops</code></b>: List of strings representing <code>Operation</code> types that need to be placed on <code>ps</code> devices. If <code>None</code>, defaults to <code>[&quot;Variable&quot;]</code>.</li>
<li><b><code>ps_strategy</code></b>: A callable invoked for every ps <code>Operation</code> (i.e. matched by <code>ps_ops</code>), that takes the <code>Operation</code> and returns the ps task index to use. If <code>None</code>, defaults to a round-robin strategy across all <code>ps</code> devices.</li>
</ul>
<h5 id="returns-67">Returns:</h5>
<p>A function to pass to <code>tf.device()</code>.</p>
<h5 id="raises-37">Raises:</h5>
<p>TypeError if <code>cluster</code> is not a dictionary or <code>ClusterDef</code> protocol buffer, or if <code>ps_strategy</code> is provided but not a callable.</p>
<hr />
<h3 id="tf.train.monitoredtrainingsessionmaster-is_chieftrue-checkpoint_dirnone-scaffoldnone-hooksnone-chief_only_hooksnone-save_checkpoint_secs600-save_summaries_steps100-confignone"><a name="//apple_ref/cpp/Class/MonitoredTrainingSession" class="dashAnchor"></a><code id="MonitoredTrainingSession">tf.train.MonitoredTrainingSession(master='', is_chief=True, checkpoint_dir=None, scaffold=None, hooks=None, chief_only_hooks=None, save_checkpoint_secs=600, save_summaries_steps=100, config=None)</code></h3>
<p>Creates a <code>MonitoredSession</code> for training.</p>
<p>For a chief, this utility sets proper session initializer/restorer. It also creates hooks related to checkpoint and summary saving. For workers, this utility sets proper session creator which waits for the chief to inialize/restore.</p>
<h5 id="args-71">Args:</h5>
<ul>
<li><b><code>master</code></b>: <code>String</code> the TensorFlow master to use.</li>
<li><b><code>is_chief</code></b>: If <code>True</code>, it will take care of initialization and recovery the underlying TensorFlow session. If <code>False</code>, it will wait on a chief to initialize or recover the TensorFlow session.</li>
<li><b><code>checkpoint_dir</code></b>: A string. Optional path to a directory where to restore variables.</li>
<li><b><code>scaffold</code></b>: A <code>Scaffold</code> used for gathering or building supportive ops. If not specified, a default one is created. It's used to finalize the graph.</li>
<li><b><code>hooks</code></b>: Optional list of <code>SessionRunHook</code> objects.</li>
<li><b><code>chief_only_hooks</code></b>: list of <code>SessionRunHook</code> objects. Activate these hooks if <code>is_chief==True</code>, ignore otherwise.</li>
<li><b><code>save_checkpoint_secs</code></b>: The frequency, in seconds, that a checkpoint is saved using a default checkpoint saver. If <code>save_checkpoint_secs</code> is set to <code>None</code>, then the default checkpoint saver isn't used.</li>
<li><b><code>save_summaries_steps</code></b>: The frequency, in number of global steps, that the summaries are written to disk using a default summary saver. If <code>save_summaries_steps</code> is set to <code>None</code>, then the default summary saver isn't used.</li>
<li><b><code>config</code></b>: an instance of <code>tf.ConfigProto</code> proto used to configure the session. It's the <code>config</code> argument of constructor of <code>tf.Session</code>.</li>
</ul>
<h5 id="returns-68">Returns:</h5>
<p>A <code>MonitoredSession</code> object.</p>
<hr />
<h3 id="class-tf.train.monitoredsession"><a name="//apple_ref/cpp/Class/MonitoredSession" class="dashAnchor"></a><code id="MonitoredSession">class tf.train.MonitoredSession</code></h3>
<p>Session-like object that handles initialization, recovery and hooks.</p>
<p>Example usage:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">saver_hook <span class="op">=</span> CheckpointSaverHook(...)
summary_hook <span class="op">=</span> SummaryHook(...)
<span class="cf">with</span> MonitoredSession(session_creator<span class="op">=</span>ChiefSessionCreator(...),
                      hooks<span class="op">=</span>[saver_hook, summary_hook]) <span class="im">as</span> sess:
  <span class="cf">while</span> <span class="op">not</span> sess.should_stop():
    sess.run(train_op)</code></pre></div>
<p>Initialization: At creation time the monitored session does following things in given order:</p>
<ul>
<li>calls <code>hook.begin()</code> for each given hook</li>
<li>finalizes the graph via <code>scaffold.finalize()</code></li>
<li>create session</li>
<li>initializes the model via initialization ops provided by <code>Scaffold</code></li>
<li>restores variables if a checkpoint exists</li>
<li>launches queue runners</li>
</ul>
<p>Run: When <code>run()</code> is called, the monitored session does following things:</p>
<ul>
<li>calls <code>hook.before_run()</code></li>
<li>calls TensorFlow <code>session.run()</code> with merged fetches and feed_dict</li>
<li>calls <code>hook.after_run()</code></li>
<li>returns result of <code>session.run()</code> asked by user</li>
<li>if <code>AbortedError</code> occurs, it recovers or reinitializes the session before executing the run() call again</li>
</ul>
<p>Exit: At the <code>close()</code>, the monitored session does following things in order:</p>
<ul>
<li>calls <code>hook.end()</code></li>
<li>closes the queue runners and the session</li>
<li>suppresses <code>OutOfRange</code> error which indicates that all inputs have been processed if the monitored_session is used as a context</li>
</ul>
<p>How to set <code>tf.Session</code> arguments:</p>
<ul>
<li>In most cases you can set session arguments as follows:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">MonitoredSession(
  session_creator<span class="op">=</span>ChiefSessionCreator(master<span class="op">=</span>..., config<span class="op">=</span>...))</code></pre></div>
<ul>
<li>In distributed setting for a non-chief worker, you can use following:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">MonitoredSession(
  session_creator<span class="op">=</span>WorkerSessionCreator(master<span class="op">=</span>..., config<span class="op">=</span>...))</code></pre></div>
<p>See <code>MonitoredTrainingSession</code> for an example usage based on chief or worker.</p>
<p>Args: session_creator: A factory object to create session. Typically a <code>ChiefSessionCreator</code> which is the default one. hooks: An iterable of `SessionRunHook' objects.</p>
<p>Returns: A MonitoredSession object. - - -</p>
<h4 id="tf.train.monitoredsession.__enter__"><code id="MonitoredSession.__enter__">tf.train.MonitoredSession.__enter__()</code></h4>
<hr />
<h4 id="tf.train.monitoredsession.__exit__exception_type-exception_value-traceback"><code id="MonitoredSession.__exit__">tf.train.MonitoredSession.__exit__(exception_type, exception_value, traceback)</code></h4>
<hr />
<h4 id="tf.train.monitoredsession.__init__session_creatornone-hooksnone"><code id="MonitoredSession.__init__">tf.train.MonitoredSession.__init__(session_creator=None, hooks=None)</code></h4>
<hr />
<h4 id="tf.train.monitoredsession.close"><code id="MonitoredSession.close">tf.train.MonitoredSession.close()</code></h4>
<hr />
<h4 id="tf.train.monitoredsession.graph"><code id="MonitoredSession.graph">tf.train.MonitoredSession.graph</code></h4>
<p>The graph that was launched in this session.</p>
<hr />
<h4 id="tf.train.monitoredsession.runfetches-feed_dictnone-optionsnone-run_metadatanone"><code id="MonitoredSession.run">tf.train.MonitoredSession.run(fetches, feed_dict=None, options=None, run_metadata=None)</code></h4>
<p>Run ops in the monitored session.</p>
<p>This method is completely compatible with the <code>tf.Session.run()</code> method.</p>
<h5 id="args-72">Args:</h5>
<ul>
<li><b><code>fetches</code></b>: Same as <code>tf.Session.run()</code>.</li>
<li><b><code>feed_dict</code></b>: Same as <code>tf.Session.run()</code>.</li>
<li><b><code>options</code></b>: Same as <code>tf.Session.run()</code>.</li>
<li><b><code>run_metadata</code></b>: Same as <code>tf.Session.run()</code>.</li>
</ul>
<h5 id="returns-69">Returns:</h5>
<p>Same as <code>tf.Session.run()</code>.</p>
<hr />
<h4 id="tf.train.monitoredsession.should_stop"><code id="MonitoredSession.should_stop">tf.train.MonitoredSession.should_stop()</code></h4>
<hr />
<h3 id="class-tf.train.singularmonitoredsession"><a name="//apple_ref/cpp/Class/SingularMonitoredSession" class="dashAnchor"></a><code id="SingularMonitoredSession">class tf.train.SingularMonitoredSession</code></h3>
<p>Session-like object that handles initialization, restoring, and hooks.</p>
<p>Please note that this utility is not recommended for distributed settings. For distributed settings, please use <code>tf.train.MonitoredSession</code>. The differences between <code>MonitoredSession</code> and <code>SingularMonitoredSession</code> are: * <code>MonitoredSession</code> handles <code>AbortedError</code> for distributed settings, but <code>SingularMonitoredSession</code> does not. * <code>MonitoredSession</code> can be created in <code>chief</code> or <code>worker</code> modes. <code>SingularMonitoredSession</code> is always created as <code>chief</code>. * You can access the raw <code>tf.Session</code> object used by <code>SingularMonitoredSession</code>, whereas in MonitoredSession the raw session is private. This can be used: - To <code>run</code> without hooks. - To save and restore. * All other functionality is identical.</p>
<p>Example usage:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">saver_hook <span class="op">=</span> CheckpointSaverHook(...)
summary_hook <span class="op">=</span> SummaryHook(...)
<span class="cf">with</span> SingularMonitoredSession(hooks<span class="op">=</span>[saver_hook, summary_hook]) <span class="im">as</span> sess:
  <span class="cf">while</span> <span class="op">not</span> sess.should_stop():
    sess.run(train_op)</code></pre></div>
<p>Initialization: At creation time the hooked session does following things in given order:</p>
<ul>
<li>calls <code>hook.begin()</code> for each given hook</li>
<li>finalizes the graph via <code>scaffold.finalize()</code></li>
<li>create session</li>
<li>initializes the model via initialization ops provided by <code>Scaffold</code></li>
<li>restores variables if a checkpoint exists</li>
<li>launches queue runners</li>
</ul>
<p>Run: When <code>run()</code> is called, the hooked session does following things:</p>
<ul>
<li>calls <code>hook.before_run()</code></li>
<li>calls TensorFlow <code>session.run()</code> with merged fetches and feed_dict</li>
<li>calls <code>hook.after_run()</code></li>
<li>returns result of <code>session.run()</code> asked by user</li>
</ul>
<p>Exit: At the <code>close()</code>, the hooked session does following things in order:</p>
<ul>
<li>calls <code>hook.end()</code></li>
<li>closes the queue runners and the session</li>
<li>surpresses <code>OutOfRange</code> error which indicates that all inputs have been processed if the <code>SingularMonitoredSession</code> is used as a context. - - -</li>
</ul>
<h4 id="tf.train.singularmonitoredsession.__enter__"><code id="SingularMonitoredSession.__enter__">tf.train.SingularMonitoredSession.__enter__()</code></h4>
<hr />
<h4 id="tf.train.singularmonitoredsession.__exit__exception_type-exception_value-traceback"><code id="SingularMonitoredSession.__exit__">tf.train.SingularMonitoredSession.__exit__(exception_type, exception_value, traceback)</code></h4>
<hr />
<h4 id="tf.train.singularmonitoredsession.__init__hooksnone-scaffoldnone-master-confignone-checkpoint_dirnone"><code id="SingularMonitoredSession.__init__">tf.train.SingularMonitoredSession.__init__(hooks=None, scaffold=None, master='', config=None, checkpoint_dir=None)</code></h4>
<p>Creates a SingularMonitoredSession.</p>
<h5 id="args-73">Args:</h5>
<ul>
<li><b><code>hooks</code></b>: An iterable of `SessionRunHook' objects.</li>
<li><b><code>scaffold</code></b>: A <code>Scaffold</code> used for gathering or building supportive ops. If not specified a default one is created. It's used to finalize the graph.</li>
<li><b><code>master</code></b>: <code>String</code> representation of the TensorFlow master to use.</li>
<li><b><code>config</code></b>: <code>ConfigProto</code> proto used to configure the session.</li>
<li><b><code>checkpoint_dir</code></b>: A string. Optional path to a directory where to restore variables.</li>
</ul>
<hr />
<h4 id="tf.train.singularmonitoredsession.close"><code id="SingularMonitoredSession.close">tf.train.SingularMonitoredSession.close()</code></h4>
<hr />
<h4 id="tf.train.singularmonitoredsession.graph"><code id="SingularMonitoredSession.graph">tf.train.SingularMonitoredSession.graph</code></h4>
<p>The graph that was launched in this session.</p>
<hr />
<h4 id="tf.train.singularmonitoredsession.raw_session"><code id="SingularMonitoredSession.raw_session">tf.train.SingularMonitoredSession.raw_session()</code></h4>
<p>Returns underlying <code>TensorFlow.Session</code> object.</p>
<hr />
<h4 id="tf.train.singularmonitoredsession.runfetches-feed_dictnone-optionsnone-run_metadatanone"><code id="SingularMonitoredSession.run">tf.train.SingularMonitoredSession.run(fetches, feed_dict=None, options=None, run_metadata=None)</code></h4>
<p>Run ops in the monitored session.</p>
<p>This method is completely compatible with the <code>tf.Session.run()</code> method.</p>
<h5 id="args-74">Args:</h5>
<ul>
<li><b><code>fetches</code></b>: Same as <code>tf.Session.run()</code>.</li>
<li><b><code>feed_dict</code></b>: Same as <code>tf.Session.run()</code>.</li>
<li><b><code>options</code></b>: Same as <code>tf.Session.run()</code>.</li>
<li><b><code>run_metadata</code></b>: Same as <code>tf.Session.run()</code>.</li>
</ul>
<h5 id="returns-70">Returns:</h5>
<p>Same as <code>tf.Session.run()</code>.</p>
<hr />
<h4 id="tf.train.singularmonitoredsession.should_stop"><code id="SingularMonitoredSession.should_stop">tf.train.SingularMonitoredSession.should_stop()</code></h4>
<hr />
<h3 id="class-tf.train.scaffold"><a name="//apple_ref/cpp/Class/Scaffold" class="dashAnchor"></a><code id="Scaffold">class tf.train.Scaffold</code></h3>
<p>Structure to create or gather pieces commonly needed to train a model.</p>
<p>When you build a model for training you usually need ops to initialize variables, a <code>Saver</code> to checkpoint them, an op to collect summaries for the visualizer, and so on.</p>
<p>Various libraries built on top of the core TensorFlow library take care of creating some or all of these pieces and storing them in well known collections in the graph. The <code>Scaffold</code> class helps pick these pieces from the graph collections, creating and adding them to the collections if needed.</p>
<p>If you call the scaffold constructor without any arguments, it will pick pieces from the collections, creating default ones if needed when <code>scaffold.finalize()</code> is called. You can pass arguments to the constructor to provide your own pieces. Pieces that you pass to the constructor are not added to the graph collections.</p>
<p>The following pieces are directly accessible as attributes of the <code>Scaffold</code> object:</p>
<ul>
<li><code>saver</code>: A <code>tf.Saver</code> object taking care of saving the variables. Picked from and stored into the <code>SAVERS</code> collection in the graph by default.</li>
<li><code>init_op</code>: An op to run to initialize the variables. Picked from and stored into the <code>INIT_OP</code> collection in the graph by default.</li>
<li><code>ready_op</code>: An op to verify that the variables are initialized. Picked from and stored into the <code>READY_OP</code> collection in the graph by default.</li>
<li><code>ready_for_local_init_op</code>: An op to verify that global state has been initialized and it is alright to run <code>local_init_op</code>. Picked from and stored into the <code>READY_FOR_LOCAL_INIT_OP</code> collection in the graph by default. This is needed when the initialization of local variables depends on the values of global variables.</li>
<li><code>local_init_op</code>: An op to initialize the local variables. Picked from and stored into the <code>LOCAL_INIT_OP</code> collection in the graph by default.</li>
<li><code>summary_op</code>: An op to run and merge the summaries in the graph. Picked from and stored into the <code>SUMMARY_OP</code> collection in the graph by default.</li>
<li><code>global_step</code>: A tensor containing the global step counter. Picked from and stored into the <code>GLOBAL_STEP</code> collection in the graph by default.</li>
</ul>
<p>You can also pass the following additional pieces to the constructor:</p>
<ul>
<li><code>init_feed_dict</code>: A sessionn feed dictionary that should be used when running the init op.</li>
<li><code>init_fn</code>: A callable to run run after the init op to perform additional initializations. The callable will be called as <code>init_fn(scaffold, session)</code>. - - -</li>
</ul>
<h4 id="tf.train.scaffold.__init__init_opnone-init_feed_dictnone-init_fnnone-ready_opnone-ready_for_local_init_opnone-local_init_opnone-summary_opnone-savernone"><code id="Scaffold.__init__">tf.train.Scaffold.__init__(init_op=None, init_feed_dict=None, init_fn=None, ready_op=None, ready_for_local_init_op=None, local_init_op=None, summary_op=None, saver=None)</code></h4>
<p>Create a scaffold.</p>
<h5 id="args-75">Args:</h5>
<ul>
<li><b><code>init_op</code></b>: Optional op for initializing variables.</li>
<li><b><code>init_feed_dict</code></b>: Optional session feed dictionary to use when running the init_op.</li>
<li><b><code>init_fn</code></b>: Optional function to use to initialize the model after running the init_op. Will be called as <code>init_fn(scaffold, session)</code>.</li>
<li><b><code>ready_op</code></b>: Optional op to verify that the variables are initialized. Must return an empty 1D string tensor when the variables are initialized, or a non-empty 1D string tensor listing the names of the non-initialized variables.</li>
<li><b><code>ready_for_local_init_op</code></b>: Optional op to verify that the global variables are initialized and <code>local_init_op</code> can be run. Must return an empty 1D string tensor when the global variables are initialized, or a non-empty 1D string tensor listing the names of the non-initialized global variables.</li>
<li><b><code>local_init_op</code></b>: Optional op to initialize local variables.</li>
<li><b><code>summary_op</code></b>: Optional op to gather all summaries. Must return a scalar string tensor containing a serialized <code>Summary</code> proto.</li>
<li><b><code>saver</code></b>: Optional <code>tf.Saver</code> object to use to save and restore variables.</li>
</ul>
<hr />
<h4 id="tf.train.scaffold.finalize"><code id="Scaffold.finalize">tf.train.Scaffold.finalize()</code></h4>
<p>Creates operations if needed and finalizes the graph.</p>
<hr />
<h4 id="tf.train.scaffold.get_or_defaultarg_name-collection_key-default_constructor"><code id="Scaffold.get_or_default">tf.train.Scaffold.get_or_default(arg_name, collection_key, default_constructor)</code></h4>
<p>Get from cache or create a default operation.</p>
<hr />
<h4 id="tf.train.scaffold.init_feed_dict"><code id="Scaffold.init_feed_dict">tf.train.Scaffold.init_feed_dict</code></h4>
<hr />
<h4 id="tf.train.scaffold.init_fn"><code id="Scaffold.init_fn">tf.train.Scaffold.init_fn</code></h4>
<hr />
<h4 id="tf.train.scaffold.init_op"><code id="Scaffold.init_op">tf.train.Scaffold.init_op</code></h4>
<hr />
<h4 id="tf.train.scaffold.local_init_op"><code id="Scaffold.local_init_op">tf.train.Scaffold.local_init_op</code></h4>
<hr />
<h4 id="tf.train.scaffold.ready_for_local_init_op"><code id="Scaffold.ready_for_local_init_op">tf.train.Scaffold.ready_for_local_init_op</code></h4>
<hr />
<h4 id="tf.train.scaffold.ready_op"><code id="Scaffold.ready_op">tf.train.Scaffold.ready_op</code></h4>
<hr />
<h4 id="tf.train.scaffold.saver"><code id="Scaffold.saver">tf.train.Scaffold.saver</code></h4>
<hr />
<h4 id="tf.train.scaffold.summary_op"><code id="Scaffold.summary_op">tf.train.Scaffold.summary_op</code></h4>
<hr />
<h3 id="class-tf.train.sessioncreator"><a name="//apple_ref/cpp/Class/SessionCreator" class="dashAnchor"></a><code id="SessionCreator">class tf.train.SessionCreator</code></h3>
<p>A factory for tf.Session. - - -</p>
<h4 id="tf.train.sessioncreator.create_session"><code id="SessionCreator.create_session">tf.train.SessionCreator.create_session()</code></h4>
<hr />
<h3 id="class-tf.train.chiefsessioncreator"><a name="//apple_ref/cpp/Class/ChiefSessionCreator" class="dashAnchor"></a><code id="ChiefSessionCreator">class tf.train.ChiefSessionCreator</code></h3>
<p>Creates a tf.Session for a chief. - - -</p>
<h4 id="tf.train.chiefsessioncreator.__init__scaffoldnone-master-confignone-checkpoint_dirnone-checkpoint_filename_with_pathnone"><code id="ChiefSessionCreator.__init__">tf.train.ChiefSessionCreator.__init__(scaffold=None, master='', config=None, checkpoint_dir=None, checkpoint_filename_with_path=None)</code></h4>
<p>Initializes a chief session creator.</p>
<h5 id="args-76">Args:</h5>
<ul>
<li><b><code>scaffold</code></b>: A <code>Scaffold</code> used for gathering or building supportive ops. If not specified a default one is created. It's used to finalize the graph.</li>
<li><b><code>master</code></b>: <code>String</code> representation of the TensorFlow master to use.</li>
<li><b><code>config</code></b>: <code>ConfigProto</code> proto used to configure the session.</li>
<li><b><code>checkpoint_dir</code></b>: A string. Optional path to a directory where to restore variables.</li>
<li><b><code>checkpoint_filename_with_path</code></b>: Full file name path to the checkpoint file.</li>
</ul>
<hr />
<h4 id="tf.train.chiefsessioncreator.create_session"><code id="ChiefSessionCreator.create_session">tf.train.ChiefSessionCreator.create_session()</code></h4>
<hr />
<h3 id="class-tf.train.workersessioncreator"><a name="//apple_ref/cpp/Class/WorkerSessionCreator" class="dashAnchor"></a><code id="WorkerSessionCreator">class tf.train.WorkerSessionCreator</code></h3>
<p>Creates a tf.Session for a worker. - - -</p>
<h4 id="tf.train.workersessioncreator.__init__scaffoldnone-master-confignone"><code id="WorkerSessionCreator.__init__">tf.train.WorkerSessionCreator.__init__(scaffold=None, master='', config=None)</code></h4>
<p>Initializes a worker session creator.</p>
<h5 id="args-77">Args:</h5>
<ul>
<li><b><code>scaffold</code></b>: A <code>Scaffold</code> used for gathering or building supportive ops. If not specified a default one is created. It's used to finalize the graph.</li>
<li><b><code>master</code></b>: <code>String</code> representation of the TensorFlow master to use.</li>
<li><b><code>config</code></b>: <code>ConfigProto</code> proto used to configure the session.</li>
</ul>
<hr />
<h4 id="tf.train.workersessioncreator.create_session"><code id="WorkerSessionCreator.create_session">tf.train.WorkerSessionCreator.create_session()</code></h4>
<h2 id="reading-summaries-from-event-files">Reading Summaries from Event Files</h2>
<p>See <a href="../../how_tos/summaries_and_tensorboard/index.md">Summaries and TensorBoard</a> for an overview of summaries, event files, and visualization in TensorBoard.</p>
<hr />
<h3 id="tf.train.summary_iteratorpath"><a name="//apple_ref/cpp/Function/summary_iterator" class="dashAnchor"></a><code id="summary_iterator">tf.train.summary_iterator(path)</code></h3>
<p>An iterator for reading <code>Event</code> protocol buffers from an event file.</p>
<p>You can use this function to read events written to an event file. It returns a Python iterator that yields <code>Event</code> protocol buffers.</p>
<p>Example: Print the contents of an events file.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">for</span> e <span class="op">in</span> tf.train.summary_iterator(path to events <span class="bu">file</span>):
    <span class="bu">print</span>(e)</code></pre></div>
<p>Example: Print selected summary values.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># This example supposes that the events file contains summaries with a</span>
<span class="co"># summary value tag &#39;loss&#39;.  These could have been added by calling</span>
<span class="co"># `add_summary()`, passing the output of a scalar summary op created with</span>
<span class="co"># with: `tf.summary.scalar(&#39;loss&#39;, loss_tensor)`.</span>
<span class="cf">for</span> e <span class="op">in</span> tf.train.summary_iterator(path to events <span class="bu">file</span>):
    <span class="cf">for</span> v <span class="op">in</span> e.summary.value:
        <span class="cf">if</span> v.tag <span class="op">==</span> <span class="st">&#39;loss&#39;</span>:
            <span class="bu">print</span>(v.simple_value)</code></pre></div>
<p>See the protocol buffer definitions of <a href="https://www.tensorflow.org/code/tensorflow/core/util/event.proto">Event</a> and <a href="https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto">Summary</a> for more information about their attributes.</p>
<h5 id="args-78">Args:</h5>
<ul>
<li><b><code>path</code></b>: The path to an event file created by a <code>SummaryWriter</code>.</li>
</ul>
<h5 id="yields-1">Yields:</h5>
<p><code>Event</code> protocol buffers.</p>
<h2 id="training-utilities">Training Utilities</h2>
<hr />
<h3 id="tf.train.global_stepsess-global_step_tensor"><a name="//apple_ref/cpp/Function/global_step" class="dashAnchor"></a><code id="global_step">tf.train.global_step(sess, global_step_tensor)</code></h3>
<p>Small helper to get the global step.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Creates a variable to hold the global_step.</span>
global_step_tensor <span class="op">=</span> tf.Variable(<span class="dv">10</span>, trainable<span class="op">=</span><span class="va">False</span>, name<span class="op">=</span><span class="st">&#39;global_step&#39;</span>)
<span class="co"># Creates a session.</span>
sess <span class="op">=</span> tf.Session()
<span class="co"># Initializes the variable.</span>
<span class="bu">print</span>(<span class="st">&#39;global_step: </span><span class="sc">%s</span><span class="st">&#39;</span> <span class="op">%</span> tf.train.global_step(sess, global_step_tensor))

global_step: <span class="dv">10</span></code></pre></div>
<h5 id="args-79">Args:</h5>
<ul>
<li><b><code>sess</code></b>: A TensorFlow <code>Session</code> object.</li>
<li><b><code>global_step_tensor</code></b>: <code>Tensor</code> or the <code>name</code> of the operation that contains the global step.</li>
</ul>
<h5 id="returns-71">Returns:</h5>
<p>The global step value.</p>
<hr />
<h3 id="tf.train.basic_train_loopsupervisor-train_step_fn-argsnone-kwargsnone-master"><a name="//apple_ref/cpp/Function/basic_train_loop" class="dashAnchor"></a><code id="basic_train_loop">tf.train.basic_train_loop(supervisor, train_step_fn, args=None, kwargs=None, master='')</code></h3>
<p>Basic loop to train a model.</p>
<p>Calls <code>train_step_fn</code> in a loop to train a model. The function is called as:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">train_step_fn(session, <span class="op">*</span>args, <span class="op">**</span>kwargs)</code></pre></div>
<p>It is passed a <code>tf.Session</code> in addition to <code>args</code> and <code>kwargs</code>. The function typically runs one training step in the session.</p>
<h5 id="args-80">Args:</h5>
<ul>
<li><b><code>supervisor</code></b>: <code>tf.Supervisor</code> to run the training services.</li>
<li><b><code>train_step_fn</code></b>: Callable to execute one training step. Called repeatedly as <code>train_step_fn(session, *args **kwargs)</code>.</li>
<li><b><code>args</code></b>: Optional positional arguments passed to <code>train_step_fn</code>.</li>
<li><b><code>kwargs</code></b>: Optional keyword arguments passed to <code>train_step_fn</code>.</li>
<li><b><code>master</code></b>: Master to use to create the training session. Defaults to <code>&quot;&quot;</code> which causes the session to be created in the local process.</li>
</ul>
<hr />
<h3 id="tf.train.get_global_stepgraphnone"><a name="//apple_ref/cpp/Function/get_global_step" class="dashAnchor"></a><code id="get_global_step">tf.train.get_global_step(graph=None)</code></h3>
<p>Get the global step tensor.</p>
<p>The global step tensor must be an integer variable. We first try to find it in the collection <code>GLOBAL_STEP</code>, or by name <code>global_step:0</code>.</p>
<h5 id="args-81">Args:</h5>
<ul>
<li><b><code>graph</code></b>: The graph to find the global step in. If missing, use default graph.</li>
</ul>
<h5 id="returns-72">Returns:</h5>
<p>The global step variable, or <code>None</code> if none was found.</p>
<h5 id="raises-38">Raises:</h5>
<ul>
<li><b><code>TypeError</code></b>: If the global step tensor has a non-integer type, or if it is not a <code>Variable</code>.</li>
</ul>
<hr />
<h3 id="tf.train.assert_global_stepglobal_step_tensor"><a name="//apple_ref/cpp/Function/assert_global_step" class="dashAnchor"></a><code id="assert_global_step">tf.train.assert_global_step(global_step_tensor)</code></h3>
<p>Asserts <code>global_step_tensor</code> is a scalar int <code>Variable</code> or <code>Tensor</code>.</p>
<h5 id="args-82">Args:</h5>
<ul>
<li><b><code>global_step_tensor</code></b>: <code>Tensor</code> to test.</li>
</ul>
<hr />
<h3 id="tf.train.write_graphgraph_or_graph_def-logdir-name-as_texttrue"><a name="//apple_ref/cpp/Function/write_graph" class="dashAnchor"></a><code id="write_graph">tf.train.write_graph(graph_or_graph_def, logdir, name, as_text=True)</code></h3>
<p>Writes a graph proto to a file.</p>
<p>The graph is written as a binary proto unless <code>as_text</code> is <code>True</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">v <span class="op">=</span> tf.Variable(<span class="dv">0</span>, name<span class="op">=</span><span class="st">&#39;my_variable&#39;</span>)
sess <span class="op">=</span> tf.Session()
tf.train.write_graph(sess.graph_def, <span class="st">&#39;/tmp/my-model&#39;</span>, <span class="st">&#39;train.pbtxt&#39;</span>)</code></pre></div>
<p>or</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">v <span class="op">=</span> tf.Variable(<span class="dv">0</span>, name<span class="op">=</span><span class="st">&#39;my_variable&#39;</span>)
sess <span class="op">=</span> tf.Session()
tf.train.write_graph(sess.graph, <span class="st">&#39;/tmp/my-model&#39;</span>, <span class="st">&#39;train.pbtxt&#39;</span>)</code></pre></div>
<h5 id="args-83">Args:</h5>
<ul>
<li><b><code>graph_or_graph_def</code></b>: A <code>Graph</code> or a <code>GraphDef</code> protocol buffer.</li>
<li><b><code>logdir</code></b>: Directory where to write the graph. This can refer to remote filesystems, such as Google Cloud Storage (GCS).</li>
<li><b><code>name</code></b>: Filename for the graph.</li>
<li><b><code>as_text</code></b>: If <code>True</code>, writes the graph as an ASCII proto.</li>
</ul>
<h5 id="returns-73">Returns:</h5>
<p>The path of the output proto file.</p>
<hr />
<h3 id="class-tf.train.sessionrunhook"><a name="//apple_ref/cpp/Class/SessionRunHook" class="dashAnchor"></a><code id="SessionRunHook">class tf.train.SessionRunHook</code></h3>
<p>Hook to extend calls to MonitoredSession.run(). - - -</p>
<h4 id="tf.train.sessionrunhook.after_create_sessionsession-coord"><code id="SessionRunHook.after_create_session">tf.train.SessionRunHook.after_create_session(session, coord)</code></h4>
<p>Called when new TensorFlow session is created.</p>
<p>This is called to signal the hooks that a new session has been created. This has two essential differences with the situation in which <code>begin</code> is called:</p>
<ul>
<li>When this is called, the graph is finalized and ops can no longer be added to the graph.</li>
<li>This method will also be called as a result of recovering a wrapped session, not only at the beginning of the overall session.</li>
</ul>
<h5 id="args-84">Args:</h5>
<ul>
<li><b><code>session</code></b>: A TensorFlow Session that has been created.</li>
<li><b><code>coord</code></b>: A Coordinator object which keeps track of all threads.</li>
</ul>
<hr />
<h4 id="tf.train.sessionrunhook.after_runrun_context-run_values"><code id="SessionRunHook.after_run">tf.train.SessionRunHook.after_run(run_context, run_values)</code></h4>
<p>Called after each call to run().</p>
<p>The <code>run_values</code> argument contains results of requested ops/tensors by <code>before_run()</code>.</p>
<p>The <code>run_context</code> argument is the same one send to <code>before_run</code> call. <code>run_context.request_stop()</code> can be called to stop the iteration.</p>
<h5 id="args-85">Args:</h5>
<ul>
<li><b><code>run_context</code></b>: A <code>SessionRunContext</code> object.</li>
<li><b><code>run_values</code></b>: A SessionRunValues object.</li>
</ul>
<hr />
<h4 id="tf.train.sessionrunhook.before_runrun_context"><code id="SessionRunHook.before_run">tf.train.SessionRunHook.before_run(run_context)</code></h4>
<p>Called before each call to run().</p>
<p>You can return from this call a <code>SessionRunArgs</code> object indicating ops or tensors to add to the upcoming <code>run()</code> call. These ops/tensors will be run together with the ops/tensors originally passed to the original run() call. The run args you return can also contain feeds to be added to the run() call.</p>
<p>The <code>run_context</code> argument is a <code>SessionRunContext</code> that provides information about the upcoming <code>run()</code> call: the originally requested op/tensors, the TensorFlow Session.</p>
<p>At this point graph is finalized and you can not add ops.</p>
<h5 id="args-86">Args:</h5>
<ul>
<li><b><code>run_context</code></b>: A <code>SessionRunContext</code> object.</li>
</ul>
<h5 id="returns-74">Returns:</h5>
<p>None or a <code>SessionRunArgs</code> object.</p>
<hr />
<h4 id="tf.train.sessionrunhook.begin"><code id="SessionRunHook.begin">tf.train.SessionRunHook.begin()</code></h4>
<p>Called once before using the session.</p>
<p>When called, the default graph is the one that will be launched in the session. The hook can modify the graph by adding new operations to it. After the <code>begin()</code> call the graph will be finalized and the other callbacks can not modify the graph anymore. Second call of <code>begin()</code> on the same graph, should not change the graph.</p>
<hr />
<h4 id="tf.train.sessionrunhook.endsession"><code id="SessionRunHook.end">tf.train.SessionRunHook.end(session)</code></h4>
<p>Called at the end of session.</p>
<p>The <code>session</code> argument can be used in case the hook wants to run final ops, such as saving a last checkpoint.</p>
<h5 id="args-87">Args:</h5>
<ul>
<li><b><code>session</code></b>: A TensorFlow Session that will be soon closed.</li>
</ul>
<hr />
<h3 id="class-tf.train.loggingtensorhook"><a name="//apple_ref/cpp/Class/LoggingTensorHook" class="dashAnchor"></a><code id="LoggingTensorHook">class tf.train.LoggingTensorHook</code></h3>
<p>Prints the given tensors once every N local steps or once every N seconds.</p>
<p>The tensors will be printed to the log, with <code>INFO</code> severity. - - -</p>
<h4 id="tf.train.loggingtensorhook.__init__tensors-every_n_iternone-every_n_secsnone"><code id="LoggingTensorHook.__init__">tf.train.LoggingTensorHook.__init__(tensors, every_n_iter=None, every_n_secs=None)</code></h4>
<p>Initializes a LoggingHook monitor.</p>
<h5 id="args-88">Args:</h5>
<ul>
<li><b><code>tensors</code></b>: <code>dict</code> that maps string-valued tags to tensors/tensor names, or <code>iterable</code> of tensors/tensor names.</li>
<li><b><code>every_n_iter</code></b>: <code>int</code>, print the values of <code>tensors</code> once every N local steps taken on the current worker.</li>
<li><b><code>every_n_secs</code></b>: <code>int</code> or <code>float</code>, print the values of <code>tensors</code> once every N seconds. Exactly one of <code>every_n_iter</code> and <code>every_n_secs</code> should be provided.</li>
</ul>
<h5 id="raises-39">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: if <code>every_n_iter</code> is non-positive.</li>
</ul>
<hr />
<h4 id="tf.train.loggingtensorhook.after_create_sessionsession-coord"><code id="LoggingTensorHook.after_create_session">tf.train.LoggingTensorHook.after_create_session(session, coord)</code></h4>
<p>Called when new TensorFlow session is created.</p>
<p>This is called to signal the hooks that a new session has been created. This has two essential differences with the situation in which <code>begin</code> is called:</p>
<ul>
<li>When this is called, the graph is finalized and ops can no longer be added to the graph.</li>
<li>This method will also be called as a result of recovering a wrapped session, not only at the beginning of the overall session.</li>
</ul>
<h5 id="args-89">Args:</h5>
<ul>
<li><b><code>session</code></b>: A TensorFlow Session that has been created.</li>
<li><b><code>coord</code></b>: A Coordinator object which keeps track of all threads.</li>
</ul>
<hr />
<h4 id="tf.train.loggingtensorhook.after_runrun_context-run_values"><code id="LoggingTensorHook.after_run">tf.train.LoggingTensorHook.after_run(run_context, run_values)</code></h4>
<hr />
<h4 id="tf.train.loggingtensorhook.before_runrun_context"><code id="LoggingTensorHook.before_run">tf.train.LoggingTensorHook.before_run(run_context)</code></h4>
<hr />
<h4 id="tf.train.loggingtensorhook.begin"><code id="LoggingTensorHook.begin">tf.train.LoggingTensorHook.begin()</code></h4>
<hr />
<h4 id="tf.train.loggingtensorhook.endsession"><code id="LoggingTensorHook.end">tf.train.LoggingTensorHook.end(session)</code></h4>
<p>Called at the end of session.</p>
<p>The <code>session</code> argument can be used in case the hook wants to run final ops, such as saving a last checkpoint.</p>
<h5 id="args-90">Args:</h5>
<ul>
<li><b><code>session</code></b>: A TensorFlow Session that will be soon closed.</li>
</ul>
<hr />
<h3 id="class-tf.train.stopatstephook"><a name="//apple_ref/cpp/Class/StopAtStepHook" class="dashAnchor"></a><code id="StopAtStepHook">class tf.train.StopAtStepHook</code></h3>
<p>Monitor to request stop at a specified step. - - -</p>
<h4 id="tf.train.stopatstephook.__init__num_stepsnone-last_stepnone"><code id="StopAtStepHook.__init__">tf.train.StopAtStepHook.__init__(num_steps=None, last_step=None)</code></h4>
<p>Create a StopAtStep Hook.</p>
<p>This hook requests stop after either a number of steps have been executed or a last step has been reached. Only of the two options can be specified.</p>
<p>if <code>num_steps</code> is specified, it indicates the number of steps to execute after <code>begin()</code> is called. If instead <code>last_step</code> is specified, it indicates the last step we want to execute, as passed to the <code>after_run()</code> call.</p>
<h5 id="args-91">Args:</h5>
<ul>
<li><b><code>num_steps</code></b>: Number of steps to execute.</li>
<li><b><code>last_step</code></b>: Step after which to stop.</li>
</ul>
<h5 id="raises-40">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If one of the arguments is invalid.</li>
</ul>
<hr />
<h4 id="tf.train.stopatstephook.after_create_sessionsession-coord"><code id="StopAtStepHook.after_create_session">tf.train.StopAtStepHook.after_create_session(session, coord)</code></h4>
<p>Called when new TensorFlow session is created.</p>
<p>This is called to signal the hooks that a new session has been created. This has two essential differences with the situation in which <code>begin</code> is called:</p>
<ul>
<li>When this is called, the graph is finalized and ops can no longer be added to the graph.</li>
<li>This method will also be called as a result of recovering a wrapped session, not only at the beginning of the overall session.</li>
</ul>
<h5 id="args-92">Args:</h5>
<ul>
<li><b><code>session</code></b>: A TensorFlow Session that has been created.</li>
<li><b><code>coord</code></b>: A Coordinator object which keeps track of all threads.</li>
</ul>
<hr />
<h4 id="tf.train.stopatstephook.after_runrun_context-run_values"><code id="StopAtStepHook.after_run">tf.train.StopAtStepHook.after_run(run_context, run_values)</code></h4>
<hr />
<h4 id="tf.train.stopatstephook.before_runrun_context"><code id="StopAtStepHook.before_run">tf.train.StopAtStepHook.before_run(run_context)</code></h4>
<hr />
<h4 id="tf.train.stopatstephook.begin"><code id="StopAtStepHook.begin">tf.train.StopAtStepHook.begin()</code></h4>
<hr />
<h4 id="tf.train.stopatstephook.endsession"><code id="StopAtStepHook.end">tf.train.StopAtStepHook.end(session)</code></h4>
<p>Called at the end of session.</p>
<p>The <code>session</code> argument can be used in case the hook wants to run final ops, such as saving a last checkpoint.</p>
<h5 id="args-93">Args:</h5>
<ul>
<li><b><code>session</code></b>: A TensorFlow Session that will be soon closed.</li>
</ul>
<hr />
<h3 id="class-tf.train.checkpointsaverhook"><a name="//apple_ref/cpp/Class/CheckpointSaverHook" class="dashAnchor"></a><code id="CheckpointSaverHook">class tf.train.CheckpointSaverHook</code></h3>
<p>Saves checkpoints every N steps or seconds. - - -</p>
<h4 id="tf.train.checkpointsaverhook.__init__checkpoint_dir-save_secsnone-save_stepsnone-savernone-checkpoint_basenamemodel.ckpt-scaffoldnone-listenersnone"><code id="CheckpointSaverHook.__init__">tf.train.CheckpointSaverHook.__init__(checkpoint_dir, save_secs=None, save_steps=None, saver=None, checkpoint_basename='model.ckpt', scaffold=None, listeners=None)</code></h4>
<p>Initialize CheckpointSaverHook monitor.</p>
<h5 id="args-94">Args:</h5>
<ul>
<li><b><code>checkpoint_dir</code></b>: <code>str</code>, base directory for the checkpoint files.</li>
<li><b><code>save_secs</code></b>: <code>int</code>, save every N secs.</li>
<li><b><code>save_steps</code></b>: <code>int</code>, save every N steps.</li>
<li><b><code>saver</code></b>: <code>Saver</code> object, used for saving.</li>
<li><b><code>checkpoint_basename</code></b>: <code>str</code>, base name for the checkpoint files.</li>
<li><b><code>scaffold</code></b>: <code>Scaffold</code>, use to get saver object.</li>
<li><b><code>listeners</code></b>: List of <code>CheckpointSaverListener</code> subclass instances. Used for callbacks that run immediately after the corresponding CheckpointSaverHook callbacks, only in steps where the CheckpointSaverHook was triggered.</li>
</ul>
<h5 id="raises-41">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: One of <code>save_steps</code> or <code>save_secs</code> should be set.</li>
<li><b><code>ValueError</code></b>: Exactly one of saver or scaffold should be set.</li>
</ul>
<hr />
<h4 id="tf.train.checkpointsaverhook.after_create_sessionsession-coord"><code id="CheckpointSaverHook.after_create_session">tf.train.CheckpointSaverHook.after_create_session(session, coord)</code></h4>
<p>Called when new TensorFlow session is created.</p>
<p>This is called to signal the hooks that a new session has been created. This has two essential differences with the situation in which <code>begin</code> is called:</p>
<ul>
<li>When this is called, the graph is finalized and ops can no longer be added to the graph.</li>
<li>This method will also be called as a result of recovering a wrapped session, not only at the beginning of the overall session.</li>
</ul>
<h5 id="args-95">Args:</h5>
<ul>
<li><b><code>session</code></b>: A TensorFlow Session that has been created.</li>
<li><b><code>coord</code></b>: A Coordinator object which keeps track of all threads.</li>
</ul>
<hr />
<h4 id="tf.train.checkpointsaverhook.after_runrun_context-run_values"><code id="CheckpointSaverHook.after_run">tf.train.CheckpointSaverHook.after_run(run_context, run_values)</code></h4>
<hr />
<h4 id="tf.train.checkpointsaverhook.before_runrun_context"><code id="CheckpointSaverHook.before_run">tf.train.CheckpointSaverHook.before_run(run_context)</code></h4>
<hr />
<h4 id="tf.train.checkpointsaverhook.begin"><code id="CheckpointSaverHook.begin">tf.train.CheckpointSaverHook.begin()</code></h4>
<hr />
<h4 id="tf.train.checkpointsaverhook.endsession"><code id="CheckpointSaverHook.end">tf.train.CheckpointSaverHook.end(session)</code></h4>
<hr />
<h3 id="tf.train.newcheckpointreaderfilepattern"><a name="//apple_ref/cpp/Class/NewCheckpointReader" class="dashAnchor"></a><code id="NewCheckpointReader">tf.train.NewCheckpointReader(filepattern)</code></h3>
<hr />
<h3 id="class-tf.train.stepcounterhook"><a name="//apple_ref/cpp/Class/StepCounterHook" class="dashAnchor"></a><code id="StepCounterHook">class tf.train.StepCounterHook</code></h3>
<p>Steps per second monitor. - - -</p>
<h4 id="tf.train.stepcounterhook.__init__every_n_steps100-every_n_secsnone-output_dirnone-summary_writernone"><code id="StepCounterHook.__init__">tf.train.StepCounterHook.__init__(every_n_steps=100, every_n_secs=None, output_dir=None, summary_writer=None)</code></h4>
<hr />
<h4 id="tf.train.stepcounterhook.after_create_sessionsession-coord"><code id="StepCounterHook.after_create_session">tf.train.StepCounterHook.after_create_session(session, coord)</code></h4>
<p>Called when new TensorFlow session is created.</p>
<p>This is called to signal the hooks that a new session has been created. This has two essential differences with the situation in which <code>begin</code> is called:</p>
<ul>
<li>When this is called, the graph is finalized and ops can no longer be added to the graph.</li>
<li>This method will also be called as a result of recovering a wrapped session, not only at the beginning of the overall session.</li>
</ul>
<h5 id="args-96">Args:</h5>
<ul>
<li><b><code>session</code></b>: A TensorFlow Session that has been created.</li>
<li><b><code>coord</code></b>: A Coordinator object which keeps track of all threads.</li>
</ul>
<hr />
<h4 id="tf.train.stepcounterhook.after_runrun_context-run_values"><code id="StepCounterHook.after_run">tf.train.StepCounterHook.after_run(run_context, run_values)</code></h4>
<hr />
<h4 id="tf.train.stepcounterhook.before_runrun_context"><code id="StepCounterHook.before_run">tf.train.StepCounterHook.before_run(run_context)</code></h4>
<hr />
<h4 id="tf.train.stepcounterhook.begin"><code id="StepCounterHook.begin">tf.train.StepCounterHook.begin()</code></h4>
<hr />
<h4 id="tf.train.stepcounterhook.endsession"><code id="StepCounterHook.end">tf.train.StepCounterHook.end(session)</code></h4>
<p>Called at the end of session.</p>
<p>The <code>session</code> argument can be used in case the hook wants to run final ops, such as saving a last checkpoint.</p>
<h5 id="args-97">Args:</h5>
<ul>
<li><b><code>session</code></b>: A TensorFlow Session that will be soon closed.</li>
</ul>
<hr />
<h3 id="class-tf.train.nanlossduringtrainingerror"><a name="//apple_ref/cpp/Class/NanLossDuringTrainingError" class="dashAnchor"></a><code id="NanLossDuringTrainingError">class tf.train.NanLossDuringTrainingError</code></h3>
<hr />
<h4 id="tf.train.nanlossduringtrainingerror.__str__"><code id="NanLossDuringTrainingError.__str__">tf.train.NanLossDuringTrainingError.__str__()</code></h4>
<hr />
<h3 id="class-tf.train.nantensorhook"><a name="//apple_ref/cpp/Class/NanTensorHook" class="dashAnchor"></a><code id="NanTensorHook">class tf.train.NanTensorHook</code></h3>
<p>NaN Loss monitor.</p>
<p>Monitors loss and stops training if loss is NaN. Can either fail with exception or just stop training. - - -</p>
<h4 id="tf.train.nantensorhook.__init__loss_tensor-fail_on_nan_losstrue"><code id="NanTensorHook.__init__">tf.train.NanTensorHook.__init__(loss_tensor, fail_on_nan_loss=True)</code></h4>
<p>Initializes NanLoss monitor.</p>
<h5 id="args-98">Args:</h5>
<ul>
<li><b><code>loss_tensor</code></b>: <code>Tensor</code>, the loss tensor.</li>
<li><b><code>fail_on_nan_loss</code></b>: <code>bool</code>, whether to raise exception when loss is NaN.</li>
</ul>
<hr />
<h4 id="tf.train.nantensorhook.after_create_sessionsession-coord"><code id="NanTensorHook.after_create_session">tf.train.NanTensorHook.after_create_session(session, coord)</code></h4>
<p>Called when new TensorFlow session is created.</p>
<p>This is called to signal the hooks that a new session has been created. This has two essential differences with the situation in which <code>begin</code> is called:</p>
<ul>
<li>When this is called, the graph is finalized and ops can no longer be added to the graph.</li>
<li>This method will also be called as a result of recovering a wrapped session, not only at the beginning of the overall session.</li>
</ul>
<h5 id="args-99">Args:</h5>
<ul>
<li><b><code>session</code></b>: A TensorFlow Session that has been created.</li>
<li><b><code>coord</code></b>: A Coordinator object which keeps track of all threads.</li>
</ul>
<hr />
<h4 id="tf.train.nantensorhook.after_runrun_context-run_values"><code id="NanTensorHook.after_run">tf.train.NanTensorHook.after_run(run_context, run_values)</code></h4>
<hr />
<h4 id="tf.train.nantensorhook.before_runrun_context"><code id="NanTensorHook.before_run">tf.train.NanTensorHook.before_run(run_context)</code></h4>
<hr />
<h4 id="tf.train.nantensorhook.begin"><code id="NanTensorHook.begin">tf.train.NanTensorHook.begin()</code></h4>
<p>Called once before using the session.</p>
<p>When called, the default graph is the one that will be launched in the session. The hook can modify the graph by adding new operations to it. After the <code>begin()</code> call the graph will be finalized and the other callbacks can not modify the graph anymore. Second call of <code>begin()</code> on the same graph, should not change the graph.</p>
<hr />
<h4 id="tf.train.nantensorhook.endsession"><code id="NanTensorHook.end">tf.train.NanTensorHook.end(session)</code></h4>
<p>Called at the end of session.</p>
<p>The <code>session</code> argument can be used in case the hook wants to run final ops, such as saving a last checkpoint.</p>
<h5 id="args-100">Args:</h5>
<ul>
<li><b><code>session</code></b>: A TensorFlow Session that will be soon closed.</li>
</ul>
<hr />
<h3 id="class-tf.train.summarysaverhook"><a name="//apple_ref/cpp/Class/SummarySaverHook" class="dashAnchor"></a><code id="SummarySaverHook">class tf.train.SummarySaverHook</code></h3>
<p>Saves summaries every N steps. - - -</p>
<h4 id="tf.train.summarysaverhook.__init__save_stepsnone-save_secsnone-output_dirnone-summary_writernone-scaffoldnone-summary_opnone"><code id="SummarySaverHook.__init__">tf.train.SummarySaverHook.__init__(save_steps=None, save_secs=None, output_dir=None, summary_writer=None, scaffold=None, summary_op=None)</code></h4>
<p>Initializes a <code>SummarySaver</code> monitor.</p>
<h5 id="args-101">Args:</h5>
<ul>
<li><b><code>save_steps</code></b>: <code>int</code>, save summaries every N steps. Exactly one of <code>save_secs</code> and <code>save_steps</code> should be set.</li>
<li><b><code>save_secs</code></b>: <code>int</code>, save summaries every N seconds.</li>
<li><b><code>output_dir</code></b>: <code>string</code>, the directory to save the summaries to. Only used if no <code>summary_writer</code> is supplied.</li>
<li><b><code>summary_writer</code></b>: <code>SummaryWriter</code>. If <code>None</code> and an <code>output_dir</code> was passed, one will be created accordingly.</li>
<li><b><code>scaffold</code></b>: <code>Scaffold</code> to get summary_op if it's not provided.</li>
<li><b><code>summary_op</code></b>: <code>Tensor</code> of type <code>string</code> containing the serialized <code>Summary</code> protocol buffer or a list of <code>Tensor</code>. They are most likely an output by TF summary methods like <code>tf.summary.scalar</code> or <code>tf.summary.merge_all</code>. It can be passed in as one tensor; if more than one, they must be passed in as a list.</li>
</ul>
<h5 id="raises-42">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: Exactly one of scaffold or summary_op should be set.</li>
</ul>
<hr />
<h4 id="tf.train.summarysaverhook.after_create_sessionsession-coord"><code id="SummarySaverHook.after_create_session">tf.train.SummarySaverHook.after_create_session(session, coord)</code></h4>
<p>Called when new TensorFlow session is created.</p>
<p>This is called to signal the hooks that a new session has been created. This has two essential differences with the situation in which <code>begin</code> is called:</p>
<ul>
<li>When this is called, the graph is finalized and ops can no longer be added to the graph.</li>
<li>This method will also be called as a result of recovering a wrapped session, not only at the beginning of the overall session.</li>
</ul>
<h5 id="args-102">Args:</h5>
<ul>
<li><b><code>session</code></b>: A TensorFlow Session that has been created.</li>
<li><b><code>coord</code></b>: A Coordinator object which keeps track of all threads.</li>
</ul>
<hr />
<h4 id="tf.train.summarysaverhook.after_runrun_context-run_values"><code id="SummarySaverHook.after_run">tf.train.SummarySaverHook.after_run(run_context, run_values)</code></h4>
<hr />
<h4 id="tf.train.summarysaverhook.before_runrun_context"><code id="SummarySaverHook.before_run">tf.train.SummarySaverHook.before_run(run_context)</code></h4>
<hr />
<h4 id="tf.train.summarysaverhook.begin"><code id="SummarySaverHook.begin">tf.train.SummarySaverHook.begin()</code></h4>
<hr />
<h4 id="tf.train.summarysaverhook.endsessionnone"><code id="SummarySaverHook.end">tf.train.SummarySaverHook.end(session=None)</code></h4>
<hr />
<h3 id="class-tf.train.globalstepwaiterhook"><a name="//apple_ref/cpp/Class/GlobalStepWaiterHook" class="dashAnchor"></a><code id="GlobalStepWaiterHook">class tf.train.GlobalStepWaiterHook</code></h3>
<p>Delay execution until global step reaches to wait_until_step.</p>
<p>This hook delays execution until global step reaches to <code>wait_until_step</code>. It is used to gradually start workers in distributed settings. One example usage would be setting <code>wait_until_step=int(K*log(task_id+1))</code> assuming that task_id=0 is the chief. - - -</p>
<h4 id="tf.train.globalstepwaiterhook.__init__wait_until_step"><code id="GlobalStepWaiterHook.__init__">tf.train.GlobalStepWaiterHook.__init__(wait_until_step)</code></h4>
<p>Create a _GlobalStepWaiterHook.</p>
<h5 id="args-103">Args:</h5>
<ul>
<li><b><code>wait_until_step</code></b>: an <code>int</code> shows until which global step should we wait.</li>
</ul>
<hr />
<h4 id="tf.train.globalstepwaiterhook.after_create_sessionsession-coord"><code id="GlobalStepWaiterHook.after_create_session">tf.train.GlobalStepWaiterHook.after_create_session(session, coord)</code></h4>
<p>Called when new TensorFlow session is created.</p>
<p>This is called to signal the hooks that a new session has been created. This has two essential differences with the situation in which <code>begin</code> is called:</p>
<ul>
<li>When this is called, the graph is finalized and ops can no longer be added to the graph.</li>
<li>This method will also be called as a result of recovering a wrapped session, not only at the beginning of the overall session.</li>
</ul>
<h5 id="args-104">Args:</h5>
<ul>
<li><b><code>session</code></b>: A TensorFlow Session that has been created.</li>
<li><b><code>coord</code></b>: A Coordinator object which keeps track of all threads.</li>
</ul>
<hr />
<h4 id="tf.train.globalstepwaiterhook.after_runrun_context-run_values"><code id="GlobalStepWaiterHook.after_run">tf.train.GlobalStepWaiterHook.after_run(run_context, run_values)</code></h4>
<p>Called after each call to run().</p>
<p>The <code>run_values</code> argument contains results of requested ops/tensors by <code>before_run()</code>.</p>
<p>The <code>run_context</code> argument is the same one send to <code>before_run</code> call. <code>run_context.request_stop()</code> can be called to stop the iteration.</p>
<h5 id="args-105">Args:</h5>
<ul>
<li><b><code>run_context</code></b>: A <code>SessionRunContext</code> object.</li>
<li><b><code>run_values</code></b>: A SessionRunValues object.</li>
</ul>
<hr />
<h4 id="tf.train.globalstepwaiterhook.before_runrun_context"><code id="GlobalStepWaiterHook.before_run">tf.train.GlobalStepWaiterHook.before_run(run_context)</code></h4>
<hr />
<h4 id="tf.train.globalstepwaiterhook.begin"><code id="GlobalStepWaiterHook.begin">tf.train.GlobalStepWaiterHook.begin()</code></h4>
<hr />
<h4 id="tf.train.globalstepwaiterhook.endsession"><code id="GlobalStepWaiterHook.end">tf.train.GlobalStepWaiterHook.end(session)</code></h4>
<p>Called at the end of session.</p>
<p>The <code>session</code> argument can be used in case the hook wants to run final ops, such as saving a last checkpoint.</p>
<h5 id="args-106">Args:</h5>
<ul>
<li><b><code>session</code></b>: A TensorFlow Session that will be soon closed.</li>
</ul>
<hr />
<h3 id="class-tf.train.sessionrunargs"><a name="//apple_ref/cpp/Class/SessionRunArgs" class="dashAnchor"></a><code id="SessionRunArgs">class tf.train.SessionRunArgs</code></h3>
<p>Represents arguments to be added to a <code>Session.run()</code> call.</p>
<p>Args: fetches: Exactly like the 'fetches' argument to Session.Run(). Can be a single tensor or op, a list of 'fetches' or a dictionary of fetches. For example: fetches = global_step_tensor fetches = [train_op, summary_op, global_step_tensor] fetches = {'step': global_step_tensor, 'summ': summary_op} Note that this can recurse as expected: fetches = {'step': global_step_tensor, 'ops': [train_op, check_nan_op]} feed_dict: Exactly like the <code>feed_dict</code> argument to <code>Session.Run()</code> options: Exactly like the <code>options</code> argument to <code>Session.run()</code>, i.e., a config_pb2.RunOptions proto. - - -</p>
<h4 id="tf.train.sessionrunargs.__getnewargs__"><code id="SessionRunArgs.__getnewargs__">tf.train.SessionRunArgs.__getnewargs__()</code></h4>
<p>Return self as a plain tuple. Used by copy and pickle.</p>
<hr />
<h4 id="tf.train.sessionrunargs.__getstate__"><code id="SessionRunArgs.__getstate__">tf.train.SessionRunArgs.__getstate__()</code></h4>
<p>Exclude the OrderedDict from pickling</p>
<hr />
<h4 id="tf.train.sessionrunargs.__new__cls-fetches-feed_dictnone-optionsnone"><code id="SessionRunArgs.__new__">tf.train.SessionRunArgs.__new__(cls, fetches, feed_dict=None, options=None)</code></h4>
<hr />
<h4 id="tf.train.sessionrunargs.__repr__"><code id="SessionRunArgs.__repr__">tf.train.SessionRunArgs.__repr__()</code></h4>
<p>Return a nicely formatted representation string</p>
<hr />
<h4 id="tf.train.sessionrunargs.feed_dict"><code id="SessionRunArgs.feed_dict">tf.train.SessionRunArgs.feed_dict</code></h4>
<p>Alias for field number 1</p>
<hr />
<h4 id="tf.train.sessionrunargs.fetches"><code id="SessionRunArgs.fetches">tf.train.SessionRunArgs.fetches</code></h4>
<p>Alias for field number 0</p>
<hr />
<h4 id="tf.train.sessionrunargs.options"><code id="SessionRunArgs.options">tf.train.SessionRunArgs.options</code></h4>
<p>Alias for field number 2</p>
<hr />
<h3 id="class-tf.train.sessionruncontext"><a name="//apple_ref/cpp/Class/SessionRunContext" class="dashAnchor"></a><code id="SessionRunContext">class tf.train.SessionRunContext</code></h3>
<p>Provides information about the <code>session.run()</code> call being made.</p>
<p>Provides information about original request to <code>Session.Run()</code> function. SessionRunHook objects can stop the loop by calling <code>request_stop()</code> of <code>run_context</code>. In the future we may use this object to add more information about run without changing the Hook API. - - -</p>
<h4 id="tf.train.sessionruncontext.__init__original_args-session"><code id="SessionRunContext.__init__">tf.train.SessionRunContext.__init__(original_args, session)</code></h4>
<p>Initializes SessionRunContext.</p>
<hr />
<h4 id="tf.train.sessionruncontext.original_args"><code id="SessionRunContext.original_args">tf.train.SessionRunContext.original_args</code></h4>
<p>A <code>SessionRunArgs</code> object holding the original arguments of <code>run()</code>.</p>
<p>If user called <code>MonitoredSession.run(fetches=a, feed_dict=b)</code>, then this field is equal to SessionRunArgs(a, b).</p>
<h5 id="returns-75">Returns:</h5>
<p>A <code>SessionRunArgs</code> object</p>
<hr />
<h4 id="tf.train.sessionruncontext.request_stop"><code id="SessionRunContext.request_stop">tf.train.SessionRunContext.request_stop()</code></h4>
<p>Sets stop requested field.</p>
<p>Hooks can use this function to request stop of iterations. <code>MonitoredSession</code> checks whether this is called or not.</p>
<hr />
<h4 id="tf.train.sessionruncontext.session"><code id="SessionRunContext.session">tf.train.SessionRunContext.session</code></h4>
<p>A TensorFlow session object which will execute the <code>run</code>.</p>
<hr />
<h4 id="tf.train.sessionruncontext.stop_requested"><code id="SessionRunContext.stop_requested">tf.train.SessionRunContext.stop_requested</code></h4>
<p>Returns whether a stop is requested or not.</p>
<p>If true, <code>MonitoredSession</code> stops iterations.</p>
<h5 id="returns-76">Returns:</h5>
<p>A <code>bool</code></p>
<hr />
<h3 id="class-tf.train.sessionrunvalues"><a name="//apple_ref/cpp/Class/SessionRunValues" class="dashAnchor"></a><code id="SessionRunValues">class tf.train.SessionRunValues</code></h3>
<p>Contains the results of <code>Session.run()</code>.</p>
<p>In the future we may use this object to add more information about result of run without changing the Hook API.</p>
<p>Args: results: The return values from <code>Session.run()</code> corresponding to the fetches attribute returned in the RunArgs. Note that this has the same shape as the RunArgs fetches. For example: fetches = global_step_tensor =&gt; results = nparray(int) fetches = [train_op, summary_op, global_step_tensor] =&gt; results = [None, nparray(string), nparray(int)] fetches = {'step': global_step_tensor, 'summ': summary_op} =&gt; results = {'step': nparray(int), 'summ': nparray(string)} options: <code>RunOptions</code> from the <code>Session.run()</code> call. run_metadata: <code>RunMetadata</code> from the <code>Session.run()</code> call. - - -</p>
<h4 id="tf.train.sessionrunvalues.__getnewargs__"><code id="SessionRunValues.__getnewargs__">tf.train.SessionRunValues.__getnewargs__()</code></h4>
<p>Return self as a plain tuple. Used by copy and pickle.</p>
<hr />
<h4 id="tf.train.sessionrunvalues.__getstate__"><code id="SessionRunValues.__getstate__">tf.train.SessionRunValues.__getstate__()</code></h4>
<p>Exclude the OrderedDict from pickling</p>
<hr />
<h4 id="tf.train.sessionrunvalues.__new___cls-results-options-run_metadata"><code id="SessionRunValues.__new__">tf.train.SessionRunValues.__new__(_cls, results, options, run_metadata)</code></h4>
<p>Create new instance of SessionRunValues(results, options, run_metadata)</p>
<hr />
<h4 id="tf.train.sessionrunvalues.__repr__"><code id="SessionRunValues.__repr__">tf.train.SessionRunValues.__repr__()</code></h4>
<p>Return a nicely formatted representation string</p>
<hr />
<h4 id="tf.train.sessionrunvalues.options"><code id="SessionRunValues.options">tf.train.SessionRunValues.options</code></h4>
<p>Alias for field number 1</p>
<hr />
<h4 id="tf.train.sessionrunvalues.results"><code id="SessionRunValues.results">tf.train.SessionRunValues.results</code></h4>
<p>Alias for field number 0</p>
<hr />
<h4 id="tf.train.sessionrunvalues.run_metadata"><code id="SessionRunValues.run_metadata">tf.train.SessionRunValues.run_metadata</code></h4>
<p>Alias for field number 2</p>
<hr />
<h3 id="class-tf.train.looperthread"><a name="//apple_ref/cpp/Class/LooperThread" class="dashAnchor"></a><code id="LooperThread">class tf.train.LooperThread</code></h3>
<p>A thread that runs code repeatedly, optionally on a timer.</p>
<p>This thread class is intended to be used with a <code>Coordinator</code>. It repeatedly runs code specified either as <code>target</code> and <code>args</code> or by the <code>run_loop()</code> method.</p>
<p>Before each run the thread checks if the coordinator has requested stop. In that case the looper thread terminates immediately.</p>
<p>If the code being run raises an exception, that exception is reported to the coordinator and the thread terminates. The coordinator will then request all the other threads it coordinates to stop.</p>
<p>You typically pass looper threads to the supervisor <code>Join()</code> method. - - -</p>
<h4 id="tf.train.looperthread.__init__coord-timer_interval_secs-targetnone-argsnone-kwargsnone"><code id="LooperThread.__init__">tf.train.LooperThread.__init__(coord, timer_interval_secs, target=None, args=None, kwargs=None)</code></h4>
<p>Create a LooperThread.</p>
<h5 id="args-107">Args:</h5>
<ul>
<li><b><code>coord</code></b>: A Coordinator.</li>
<li><b><code>timer_interval_secs</code></b>: Time boundaries at which to call Run(), or None if it should be called back to back.</li>
<li><b><code>target</code></b>: Optional callable object that will be executed in the thread.</li>
<li><b><code>args</code></b>: Optional arguments to pass to <code>target</code> when calling it.</li>
<li><b><code>kwargs</code></b>: Optional keyword arguments to pass to <code>target</code> when calling it.</li>
</ul>
<h5 id="raises-43">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If one of the arguments is invalid.</li>
</ul>
<hr />
<h4 id="tf.train.looperthread.__repr__"><code id="LooperThread.__repr__">tf.train.LooperThread.__repr__()</code></h4>
<hr />
<h4 id="tf.train.looperthread.daemon"><code id="LooperThread.daemon">tf.train.LooperThread.daemon</code></h4>
<p>A boolean value indicating whether this thread is a daemon thread (True) or not (False).</p>
<p>This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False.</p>
<p>The entire Python program exits when no alive non-daemon threads are left.</p>
<hr />
<h4 id="tf.train.looperthread.getname"><code id="LooperThread.getName">tf.train.LooperThread.getName()</code></h4>
<hr />
<h4 id="tf.train.looperthread.ident"><code id="LooperThread.ident">tf.train.LooperThread.ident</code></h4>
<p>Thread identifier of this thread or None if it has not been started.</p>
<p>This is a nonzero integer. See the thread.get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.</p>
<hr />
<h4 id="tf.train.looperthread.isalive"><code id="LooperThread.isAlive">tf.train.LooperThread.isAlive()</code></h4>
<p>Return whether the thread is alive.</p>
<p>This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads.</p>
<hr />
<h4 id="tf.train.looperthread.isdaemon"><code id="LooperThread.isDaemon">tf.train.LooperThread.isDaemon()</code></h4>
<hr />
<h4 id="tf.train.looperthread.is_alive"><code id="LooperThread.is_alive">tf.train.LooperThread.is_alive()</code></h4>
<p>Return whether the thread is alive.</p>
<p>This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads.</p>
<hr />
<h4 id="tf.train.looperthread.jointimeoutnone"><code id="LooperThread.join">tf.train.LooperThread.join(timeout=None)</code></h4>
<p>Wait until the thread terminates.</p>
<p>This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs.</p>
<p>When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call isAlive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out.</p>
<p>When the timeout argument is not present or None, the operation will block until the thread terminates.</p>
<p>A thread can be join()ed many times.</p>
<p>join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception.</p>
<hr />
<h4 id="tf.train.looperthread.loopcoord-timer_interval_secs-target-argsnone-kwargsnone"><code id="LooperThread.loop">tf.train.LooperThread.loop(coord, timer_interval_secs, target, args=None, kwargs=None)</code></h4>
<p>Start a LooperThread that calls a function periodically.</p>
<p>If <code>timer_interval_secs</code> is None the thread calls <code>target(args)</code> repeatedly. Otherwise <code>target(args)</code> is called every <code>timer_interval_secs</code> seconds. The thread terminates when a stop of the coordinator is requested.</p>
<h5 id="args-108">Args:</h5>
<ul>
<li><b><code>coord</code></b>: A Coordinator.</li>
<li><b><code>timer_interval_secs</code></b>: Number. Time boundaries at which to call <code>target</code>.</li>
<li><b><code>target</code></b>: A callable object.</li>
<li><b><code>args</code></b>: Optional arguments to pass to <code>target</code> when calling it.</li>
<li><b><code>kwargs</code></b>: Optional keyword arguments to pass to <code>target</code> when calling it.</li>
</ul>
<h5 id="returns-77">Returns:</h5>
<p>The started thread.</p>
<hr />
<h4 id="tf.train.looperthread.name"><code id="LooperThread.name">tf.train.LooperThread.name</code></h4>
<p>A string used for identification purposes only.</p>
<p>It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.</p>
<hr />
<h4 id="tf.train.looperthread.run"><code id="LooperThread.run">tf.train.LooperThread.run()</code></h4>
<hr />
<h4 id="tf.train.looperthread.run_loop"><code id="LooperThread.run_loop">tf.train.LooperThread.run_loop()</code></h4>
<p>Called at 'timer_interval_secs' boundaries.</p>
<hr />
<h4 id="tf.train.looperthread.setdaemondaemonic"><code id="LooperThread.setDaemon">tf.train.LooperThread.setDaemon(daemonic)</code></h4>
<hr />
<h4 id="tf.train.looperthread.setnamename"><code id="LooperThread.setName">tf.train.LooperThread.setName(name)</code></h4>
<hr />
<h4 id="tf.train.looperthread.start"><code id="LooperThread.start">tf.train.LooperThread.start()</code></h4>
<p>Start the thread's activity.</p>
<p>It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control.</p>
<p>This method will raise a RuntimeError if called more than once on the same thread object.</p>
<hr />
<h4 id="tf.train.looperthread.start_loop"><code id="LooperThread.start_loop">tf.train.LooperThread.start_loop()</code></h4>
<p>Called when the thread starts.</p>
<hr />
<h4 id="tf.train.looperthread.stop_loop"><code id="LooperThread.stop_loop">tf.train.LooperThread.stop_loop()</code></h4>
<p>Called when the thread stops.</p>
<h2 id="other-functions-and-classes">Other Functions and Classes</h2>
<hr />
<h3 id="class-tf.train.syncreplicasoptimizer"><a name="//apple_ref/cpp/Class/SyncReplicasOptimizer" class="dashAnchor"></a><code id="SyncReplicasOptimizer">class tf.train.SyncReplicasOptimizer</code></h3>
<p>Class to synchronize, aggregate gradients and pass them to the optimizer.</p>
<p>In a typical asynchronous training environment, it's common to have some stale gradients. For example, with a N-replica asynchronous training, gradients will be applied to the variables N times independently. Depending on each replica's training speed, some gradients might be calculated from copies of the variable from several steps back (N-1 steps on average). This optimizer avoids stale gradients by collecting gradients from all replicas, averaging them, then applying them to the variables in one shot, after which replicas can fetch the new variables and continue.</p>
<p>The following accumulators/queue are created: <empty line> * N <code>gradient accumulators</code>, one per variable to train. Gradients are pushed to them and the chief worker will wait until enough gradients are collected and then average them before applying to variables. The accumulator will drop all stale gradients (more details in the accumulator op). * 1 <code>token</code> queue where the optimizer pushes the new global_step value after all variables are updated.</p>
<p>The following local variable is created: * <code>sync_rep_local_step</code>, one per replica. Compared against the global_step in each accumulator to check for staleness of the gradients.</p>
<p>The optimizer adds nodes to the graph to collect gradients and pause the trainers until variables are updated. For the Parameter Server job: <empty line> 1. An accumulator is created for each variable, and each replica pushes the gradients into the accumulators instead of directly applying them to the variables. 2. Each accumulator averages once enough gradients (replicas_to_aggregate) have been accumulated. 3. Apply the averaged gradients to the variables. 4. Only after all variables have been updated, increment the global step. 5. Only after step 4, pushes <code>global_step</code> in the <code>token_queue</code>, once for each worker replica. The workers can now fetch the global step, use it to update its local_step variable and start the next batch.</p>
<p>For the replicas: <empty line> 1. Start a step: fetch variables and compute gradients. 2. Once the gradients have been computed, push them into gradient accumulators. Each accumulator will check the staleness and drop the stale. 3. After pushing all the gradients, dequeue an updated value of global_step from the token queue and record that step to its local_step variable. Note that this is effectively a barrier. 4. Start the next batch.</p>
<h3 id="usage-3">Usage</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Create any optimizer to update the variables, say a simple SGD:</span>
opt <span class="op">=</span> GradientDescentOptimizer(learning_rate<span class="op">=</span><span class="fl">0.1</span>)

<span class="co"># Wrap the optimizer with sync_replicas_optimizer with 50 replicas: at each</span>
<span class="co"># step the optimizer collects 50 gradients before applying to variables.</span>
<span class="co"># Note that if you want to have 2 backup replicas, you can change</span>
<span class="co"># total_num_replicas=52 and make sure this number matches how many physical</span>
<span class="co"># replicas you started in your job.</span>
opt <span class="op">=</span> tf.SyncReplicasOptimizer(opt, replicas_to_aggregate<span class="op">=</span><span class="dv">50</span>,
                               total_num_replicas<span class="op">=</span><span class="dv">50</span>)

<span class="co"># Some models have startup_delays to help stabilize the model but when using</span>
<span class="co"># sync_replicas training, set it to 0.</span>

<span class="co"># Now you can call `minimize()` or `compute_gradients()` and</span>
<span class="co"># `apply_gradients()` normally</span>
training_op <span class="op">=</span> opt.minimize(total_loss, global_step<span class="op">=</span><span class="va">self</span>.global_step)


<span class="co"># You can create the hook which handles initialization and queues.</span>
sync_replicas_hook <span class="op">=</span> opt.make_session_run_hook(is_chief)</code></pre></div>
<p>In the training program, every worker will run the train_op as if not synchronized.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">with</span> training.MonitoredTrainingSession(
    master<span class="op">=</span>workers[worker_id].target, is_chief<span class="op">=</span>is_chief,
    hooks<span class="op">=</span>[sync_replicas_hook]) <span class="im">as</span> mon_sess:
  <span class="cf">while</span> <span class="op">not</span> mon_sess.should_stop():
    mon_sess.run(training_op)</code></pre></div>
<hr />
<h4 id="tf.train.syncreplicasoptimizer.__init__opt-replicas_to_aggregate-total_num_replicasnone-variable_averagesnone-variables_to_averagenone-use_lockingfalse-namesync_replicas"><code id="SyncReplicasOptimizer.__init__">tf.train.SyncReplicasOptimizer.__init__(opt, replicas_to_aggregate, total_num_replicas=None, variable_averages=None, variables_to_average=None, use_locking=False, name='sync_replicas')</code></h4>
<p>Construct a sync_replicas optimizer.</p>
<h5 id="args-109">Args:</h5>
<ul>
<li><b><code>opt</code></b>: The actual optimizer that will be used to compute and apply the gradients. Must be one of the Optimizer classes.</li>
<li><b><code>replicas_to_aggregate</code></b>: number of replicas to aggregate for each variable update.</li>
<li><b><code>total_num_replicas</code></b>: Total number of tasks/workers/replicas, could be different from replicas_to_aggregate. If total_num_replicas &gt; replicas_to_aggregate: it is backup_replicas + replicas_to_aggregate. If total_num_replicas &lt; replicas_to_aggregate: Replicas compute multiple batches per update to variables.</li>
<li><b><code>variable_averages</code></b>: Optional <code>ExponentialMovingAverage</code> object, used to maintain moving averages for the variables passed in <code>variables_to_average</code>.</li>
<li><b><code>variables_to_average</code></b>: a list of variables that need to be averaged. Only needed if variable_averages is passed in.</li>
<li><b><code>use_locking</code></b>: If True use locks for update operation.</li>
<li><b><code>name</code></b>: string. Optional name of the returned operation.</li>
</ul>
<hr />
<h4 id="tf.train.syncreplicasoptimizer.compute_gradientsargs-kwargs"><code id="SyncReplicasOptimizer.compute_gradients">tf.train.SyncReplicasOptimizer.compute_gradients(*args, **kwargs)</code></h4>
<p>Compute gradients of &quot;loss&quot; for the variables in &quot;var_list&quot;.</p>
<p>This simply wraps the compute_gradients() from the real optimizer. The gradients will be aggregated in the apply_gradients() so that user can modify the gradients like clipping with per replica global norm if needed. The global norm with aggregated gradients can be bad as one replica's huge gradients can hurt the gradients from other replicas.</p>
<h5 id="args-110">Args:</h5>
<ul>
<li><b><code>*args</code></b>: Arguments for compute_gradients().</li>
<li><b><code>**kwargs</code></b>: Keyword arguments for compute_gradients().</li>
</ul>
<h5 id="returns-78">Returns:</h5>
<p>A list of (gradient, variable) pairs.</p>
<hr />
<h4 id="tf.train.syncreplicasoptimizer.apply_gradientsgrads_and_vars-global_stepnone-namenone"><code id="SyncReplicasOptimizer.apply_gradients">tf.train.SyncReplicasOptimizer.apply_gradients(grads_and_vars, global_step=None, name=None)</code></h4>
<p>Apply gradients to variables.</p>
<p>This contains most of the synchronization implementation and also wraps the apply_gradients() from the real optimizer.</p>
<h5 id="args-111">Args:</h5>
<ul>
<li><b><code>grads_and_vars</code></b>: List of (gradient, variable) pairs as returned by compute_gradients().</li>
<li><b><code>global_step</code></b>: Optional Variable to increment by one after the variables have been updated.</li>
<li><b><code>name</code></b>: Optional name for the returned operation. Default to the name passed to the Optimizer constructor.</li>
</ul>
<h5 id="returns-79">Returns:</h5>
<ul>
<li><b><code>train_op</code></b>: The op to dequeue a token so the replicas can exit this batch and start the next one. This is executed by each replica.</li>
</ul>
<h5 id="raises-44">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If the grads_and_vars is empty.</li>
<li><b><code>ValueError</code></b>: If global step is not provided, the staleness cannot be checked.</li>
</ul>
<hr />
<h4 id="tf.train.syncreplicasoptimizer.get_chief_queue_runner"><code id="SyncReplicasOptimizer.get_chief_queue_runner">tf.train.SyncReplicasOptimizer.get_chief_queue_runner()</code></h4>
<p>Returns the QueueRunner for the chief to execute.</p>
<p>This includes the operations to synchronize replicas: aggregate gradients, apply to variables, increment global step, insert tokens to token queue.</p>
<p>Note that this can only be called after calling apply_gradients() which actually generates this queuerunner.</p>
<h5 id="returns-80">Returns:</h5>
<p>A <code>QueueRunner</code> for chief to execute.</p>
<h5 id="raises-45">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If this is called before apply_gradients().</li>
</ul>
<hr />
<h4 id="tf.train.syncreplicasoptimizer.get_init_tokens_opnum_tokens-1"><code id="SyncReplicasOptimizer.get_init_tokens_op">tf.train.SyncReplicasOptimizer.get_init_tokens_op(num_tokens=-1)</code></h4>
<p>Returns the op to fill the sync_token_queue with the tokens.</p>
<p>This is supposed to be executed in the beginning of the chief/sync thread so that even if the total_num_replicas is less than replicas_to_aggregate, the model can still proceed as the replicas can compute multiple steps per variable update. Make sure: <code>num_tokens &gt;= replicas_to_aggregate - total_num_replicas</code>.</p>
<h5 id="args-112">Args:</h5>
<ul>
<li><b><code>num_tokens</code></b>: Number of tokens to add to the queue.</li>
</ul>
<h5 id="returns-81">Returns:</h5>
<p>An op for the chief/sync replica to fill the token queue.</p>
<h5 id="raises-46">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If this is called before apply_gradients().</li>
<li><b><code>ValueError</code></b>: If num_tokens are smaller than replicas_to_aggregate - total_num_replicas.</li>
</ul>
<h4 id="other-methods-3">Other Methods</h4>
<hr />
<h4 id="tf.train.syncreplicasoptimizer.get_slotargs-kwargs"><code id="SyncReplicasOptimizer.get_slot">tf.train.SyncReplicasOptimizer.get_slot(*args, **kwargs)</code></h4>
<p>Return a slot named &quot;name&quot; created for &quot;var&quot; by the Optimizer.</p>
<p>This simply wraps the get_slot() from the actual optimizer.</p>
<h5 id="args-113">Args:</h5>
<ul>
<li><b><code>*args</code></b>: Arguments for get_slot().</li>
<li><b><code>**kwargs</code></b>: Keyword arguments for get_slot().</li>
</ul>
<h5 id="returns-82">Returns:</h5>
<p>The <code>Variable</code> for the slot if it was created, <code>None</code> otherwise.</p>
<hr />
<h4 id="tf.train.syncreplicasoptimizer.get_slot_namesargs-kwargs"><code id="SyncReplicasOptimizer.get_slot_names">tf.train.SyncReplicasOptimizer.get_slot_names(*args, **kwargs)</code></h4>
<p>Return a list of the names of slots created by the <code>Optimizer</code>.</p>
<p>This simply wraps the get_slot_names() from the actual optimizer.</p>
<h5 id="args-114">Args:</h5>
<ul>
<li><b><code>*args</code></b>: Arguments for get_slot().</li>
<li><b><code>**kwargs</code></b>: Keyword arguments for get_slot().</li>
</ul>
<h5 id="returns-83">Returns:</h5>
<p>A list of strings.</p>
<hr />
<h4 id="tf.train.syncreplicasoptimizer.make_session_run_hookis_chief-num_tokens-1"><code id="SyncReplicasOptimizer.make_session_run_hook">tf.train.SyncReplicasOptimizer.make_session_run_hook(is_chief, num_tokens=-1)</code></h4>
<p>Creates a hook to handle SyncReplicasHook ops such as initialization.</p>
<hr />
<h3 id="tf.train.checkpoint_existscheckpoint_prefix"><a name="//apple_ref/cpp/Function/checkpoint_exists" class="dashAnchor"></a><code id="checkpoint_exists">tf.train.checkpoint_exists(checkpoint_prefix)</code></h3>
<p>Checks whether a V1 or V2 checkpoint exists with the specified prefix.</p>
<p>This is the recommended way to check if a checkpoint exists, since it takes into account the naming difference between V1 and V2 formats.</p>
<h5 id="args-115">Args:</h5>
<ul>
<li><b><code>checkpoint_prefix</code></b>: the prefix of a V1 or V2 checkpoint, with V2 taking priority. Typically the result of <code>Saver.save()</code> or that of <code>tf.train.latest_checkpoint()</code>, regardless of sharded/non-sharded or V1/V2.</li>
</ul>
<h5 id="returns-84">Returns:</h5>
<p>A bool, true iff a checkpoint referred to by <code>checkpoint_prefix</code> exists.</p>
<hr />
<h3 id="tf.train.do_quantize_training_on_graphdefinput_graph-num_bits"><a name="//apple_ref/cpp/Function/do_quantize_training_on_graphdef" class="dashAnchor"></a><code id="do_quantize_training_on_graphdef">tf.train.do_quantize_training_on_graphdef(input_graph, num_bits)</code></h3>
<hr />
<h3 id="tf.train.generate_checkpoint_state_protosave_dir-model_checkpoint_path-all_model_checkpoint_pathsnone"><a name="//apple_ref/cpp/Function/generate_checkpoint_state_proto" class="dashAnchor"></a><code id="generate_checkpoint_state_proto">tf.train.generate_checkpoint_state_proto(save_dir, model_checkpoint_path, all_model_checkpoint_paths=None)</code></h3>
<p>Generates a checkpoint state proto.</p>
<h5 id="args-116">Args:</h5>
<ul>
<li><b><code>save_dir</code></b>: Directory where the model was saved.</li>
<li><b><code>model_checkpoint_path</code></b>: The checkpoint file.</li>
<li><b><code>all_model_checkpoint_paths</code></b>: List of strings. Paths to all not-yet-deleted checkpoints, sorted from oldest to newest. If this is a non-empty list, the last element must be equal to model_checkpoint_path. These paths are also saved in the CheckpointState proto.</li>
</ul>
<h5 id="returns-85">Returns:</h5>
<p>CheckpointState proto with model_checkpoint_path and all_model_checkpoint_paths updated to either absolute paths or relative paths to the current save_dir.</p>
<hr />
<h3 id="tf.train.get_checkpoint_mtimescheckpoint_prefixes"><a name="//apple_ref/cpp/Function/get_checkpoint_mtimes" class="dashAnchor"></a><code id="get_checkpoint_mtimes">tf.train.get_checkpoint_mtimes(checkpoint_prefixes)</code></h3>
<p>Returns the mtimes (modification timestamps) of the checkpoints.</p>
<p>Globs for the checkpoints pointed to by <code>checkpoint_prefixes</code>. If the files exist, collect their mtime. Both V2 and V1 checkpoints are considered, in that priority.</p>
<p>This is the recommended way to get the mtimes, since it takes into account the naming difference between V1 and V2 formats.</p>
<h5 id="args-117">Args:</h5>
<ul>
<li><b><code>checkpoint_prefixes</code></b>: a list of checkpoint paths, typically the results of <code>Saver.save()</code> or those of <code>tf.train.latest_checkpoint()</code>, regardless of sharded/non-sharded or V1/V2.</li>
</ul>
<h5 id="returns-86">Returns:</h5>
<p>A list of mtimes (in microseconds) of the found checkpoints.</p>
