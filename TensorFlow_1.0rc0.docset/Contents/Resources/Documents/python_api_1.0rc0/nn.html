<!-- This file is machine generated: DO NOT EDIT! -->
<h1 id="neural-network">Neural Network</h1>
<p>Note: Functions taking <code>Tensor</code> arguments can also take anything accepted by <a href="framework.md#convert_to_tensor"><code>tf.convert_to_tensor</code></a>.</p>
<p>[TOC]</p>
<h2 id="activation-functions.">Activation Functions.</h2>
<p>The activation ops provide different types of nonlinearities for use in neural networks. These include smooth nonlinearities (<code>sigmoid</code>, <code>tanh</code>, <code>elu</code>, <code>softplus</code>, and <code>softsign</code>), continuous but not everywhere differentiable functions (<code>relu</code>, <code>relu6</code>, <code>crelu</code> and <code>relu_x</code>), and random regularization (<code>dropout</code>).</p>
<p>All activation ops apply componentwise, and produce a tensor of the same shape as the input tensor.</p>
<hr />
<h3 id="tf.nn.relufeatures-namenone"><a name="//apple_ref/cpp/Function/relu" class="dashAnchor"></a><code id="relu">tf.nn.relu(features, name=None)</code></h3>
<p>Computes rectified linear: <code>max(features, 0)</code>.</p>
<h5 id="args">Args:</h5>
<ul>
<li><b><code>features</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>features</code>.</p>
<hr />
<h3 id="tf.nn.relu6features-namenone"><a name="//apple_ref/cpp/Function/relu6" class="dashAnchor"></a><code id="relu6">tf.nn.relu6(features, name=None)</code></h3>
<p>Computes Rectified Linear 6: <code>min(max(features, 0), 6)</code>.</p>
<h5 id="args-1">Args:</h5>
<ul>
<li><b><code>features</code></b>: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, or <code>int8</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-1">Returns:</h5>
<p>A <code>Tensor</code> with the same type as <code>features</code>.</p>
<hr />
<h3 id="tf.nn.crelufeatures-namenone"><a name="//apple_ref/cpp/Function/crelu" class="dashAnchor"></a><code id="crelu">tf.nn.crelu(features, name=None)</code></h3>
<p>Computes Concatenated ReLU.</p>
<p>Concatenates a ReLU which selects only the positive part of the activation with a ReLU which selects only the <em>negative</em> part of the activation. Note that as a result this non-linearity doubles the depth of the activations. Source: https://arxiv.org/abs/1603.05201</p>
<h5 id="args-2">Args:</h5>
<ul>
<li><b><code>features</code></b>: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, or <code>int8</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-2">Returns:</h5>
<p>A <code>Tensor</code> with the same type as <code>features</code>.</p>
<hr />
<h3 id="tf.nn.elufeatures-namenone"><a name="//apple_ref/cpp/Function/elu" class="dashAnchor"></a><code id="elu">tf.nn.elu(features, name=None)</code></h3>
<p>Computes exponential linear: <code>exp(features) - 1</code> if &lt; 0, <code>features</code> otherwise.</p>
<p>See <a href="http://arxiv.org/abs/1511.07289">Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)</a></p>
<h5 id="args-3">Args:</h5>
<ul>
<li><b><code>features</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-3">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>features</code>.</p>
<hr />
<h3 id="tf.nn.softplusfeatures-namenone"><a name="//apple_ref/cpp/Function/softplus" class="dashAnchor"></a><code id="softplus">tf.nn.softplus(features, name=None)</code></h3>
<p>Computes softplus: <code>log(exp(features) + 1)</code>.</p>
<h5 id="args-4">Args:</h5>
<ul>
<li><b><code>features</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-4">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>features</code>.</p>
<hr />
<h3 id="tf.nn.softsignfeatures-namenone"><a name="//apple_ref/cpp/Function/softsign" class="dashAnchor"></a><code id="softsign">tf.nn.softsign(features, name=None)</code></h3>
<p>Computes softsign: <code>features / (abs(features) + 1)</code>.</p>
<h5 id="args-5">Args:</h5>
<ul>
<li><b><code>features</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-5">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>features</code>.</p>
<hr />
<h3 id="tf.nn.dropoutx-keep_prob-noise_shapenone-seednone-namenone"><a name="//apple_ref/cpp/Function/dropout" class="dashAnchor"></a><code id="dropout">tf.nn.dropout(x, keep_prob, noise_shape=None, seed=None, name=None)</code></h3>
<p>Computes dropout.</p>
<p>With probability <code>keep_prob</code>, outputs the input element scaled up by <code>1 / keep_prob</code>, otherwise outputs <code>0</code>. The scaling is so that the expected sum is unchanged.</p>
<p>By default, each element is kept or dropped independently. If <code>noise_shape</code> is specified, it must be <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">broadcastable</a> to the shape of <code>x</code>, and only dimensions with <code>noise_shape[i] == shape(x)[i]</code> will make independent decisions. For example, if <code>shape(x) = [k, l, m, n]</code> and <code>noise_shape = [k, 1, 1, n]</code>, each batch and channel component will be kept independently and each row and column will be kept or not kept together.</p>
<h5 id="args-6">Args:</h5>
<ul>
<li><b><code>x</code></b>: A tensor.</li>
<li><b><code>keep_prob</code></b>: A scalar <code>Tensor</code> with the same type as x. The probability that each element is kept.</li>
<li><b><code>noise_shape</code></b>: A 1-D <code>Tensor</code> of type <code>int32</code>, representing the shape for randomly generated keep/drop flags.</li>
<li><b><code>seed</code></b>: A Python integer. Used to create random seeds. See <a href="../../api_docs/python/constant_op.md#set_random_seed"><code>set_random_seed</code></a> for behavior.</li>
<li><b><code>name</code></b>: A name for this operation (optional).</li>
</ul>
<h5 id="returns-6">Returns:</h5>
<p>A Tensor of the same shape of <code>x</code>.</p>
<h5 id="raises">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If <code>keep_prob</code> is not in <code>(0, 1]</code>.</li>
</ul>
<hr />
<h3 id="tf.nn.bias_addvalue-bias-data_formatnone-namenone"><a name="//apple_ref/cpp/Function/bias_add" class="dashAnchor"></a><code id="bias_add">tf.nn.bias_add(value, bias, data_format=None, name=None)</code></h3>
<p>Adds <code>bias</code> to <code>value</code>.</p>
<p>This is (mostly) a special case of <code>tf.add</code> where <code>bias</code> is restricted to 1-D. Broadcasting is supported, so <code>value</code> may have any number of dimensions. Unlike <code>tf.add</code>, the type of <code>bias</code> is allowed to differ from <code>value</code> in the case where both types are quantized.</p>
<h5 id="args-7">Args:</h5>
<ul>
<li><b><code>value</code></b>: A <code>Tensor</code> with type <code>float</code>, <code>double</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, or <code>complex128</code>.</li>
<li><b><code>bias</code></b>: A 1-D <code>Tensor</code> with size matching the last dimension of <code>value</code>. Must be the same type as <code>value</code> unless <code>value</code> is a quantized type, in which case a different quantized type may be used.</li>
<li><b><code>data_format</code></b>: A string. 'NHWC' and 'NCHW' are supported.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-7">Returns:</h5>
<p>A <code>Tensor</code> with the same type as <code>value</code>.</p>
<hr />
<h3 id="tf.sigmoidx-namenone"><a name="//apple_ref/cpp/Function/sigmoid" class="dashAnchor"></a><code id="sigmoid">tf.sigmoid(x, name=None)</code></h3>
<p>Computes sigmoid of <code>x</code> element-wise.</p>
<p>Specifically, <code>y = 1 / (1 + exp(-x))</code>.</p>
<h5 id="args-8">Args:</h5>
<ul>
<li><b><code>x</code></b>: A Tensor with type <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>complex64</code>, <code>int64</code>, or <code>qint32</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-8">Returns:</h5>
<p>A Tensor with the same type as <code>x</code> if <code>x.dtype != qint32</code> otherwise the return type is <code>quint8</code>.</p>
<p><span class="citation">@compatibility</span>(numpy) Equivalent to np.scipy.special.expit <span class="citation">@end_compatibility</span></p>
<hr />
<h3 id="tf.tanhx-namenone"><a name="//apple_ref/cpp/Function/tanh" class="dashAnchor"></a><code id="tanh">tf.tanh(x, name=None)</code></h3>
<p>Computes hyperbolic tangent of <code>x</code> element-wise.</p>
<h5 id="args-9">Args:</h5>
<ul>
<li><b><code>x</code></b>: A Tensor or SparseTensor with type <code>float</code>, <code>double</code>, <code>int32</code>, <code>complex64</code>, <code>int64</code>, or <code>qint32</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-9">Returns:</h5>
<p>A Tensor or SparseTensor respectively with the same type as <code>x</code> if <code>x.dtype != qint32</code> otherwise the return type is <code>quint8</code>.</p>
<h2 id="convolution">Convolution</h2>
<p>The convolution ops sweep a 2-D filter over a batch of images, applying the filter to each window of each image of the appropriate size. The different ops trade off between generic vs. specific filters:</p>
<ul>
<li><code>conv2d</code>: Arbitrary filters that can mix channels together.</li>
<li><code>depthwise_conv2d</code>: Filters that operate on each channel independently.</li>
<li><code>separable_conv2d</code>: A depthwise spatial filter followed by a pointwise filter.</li>
</ul>
<p>Note that although these ops are called &quot;convolution&quot;, they are strictly speaking &quot;cross-correlation&quot; since the filter is combined with an input window without reversing the filter. For details, see <a href="https://en.wikipedia.org/wiki/Cross-correlation#Properties">the properties of cross-correlation</a>.</p>
<p>The filter is applied to image patches of the same size as the filter and strided according to the <code>strides</code> argument. <code>strides = [1, 1, 1, 1]</code> applies the filter to a patch at every offset, <code>strides = [1, 2, 2, 1]</code> applies the filter to every other image patch in each dimension, etc.</p>
<p>Ignoring channels for the moment, and assume that the 4-D <code>input</code> has shape <code>[batch, in_height, in_width, ...]</code> and the 4-D <code>filter</code> has shape <code>[filter_height, filter_width, ...]</code>, then the spatial semantics of the convolution ops are as follows: first, according to the padding scheme chosen as <code>'SAME'</code> or <code>'VALID'</code>, the output size and the padding pixels are computed. For the <code>'SAME'</code> padding, the output height and width are computed as:</p>
<pre><code>out_height = ceil(float(in_height) / float(strides[1]))
out_width  = ceil(float(in_width) / float(strides[2]))</code></pre>
<p>and the padding on the top and left are computed as:</p>
<pre><code>pad_along_height = max((out_height - 1) * strides[1] +
                    filter_height - in_height, 0)
pad_along_width = max((out_width - 1) * strides[2] +
                   filter_width - in_width, 0)
pad_top = pad_along_height // 2
pad_bottom = pad_along_height - pad_top
pad_left = pad_along_width // 2
pad_right = pad_along_width - pad_left</code></pre>
<p>Note that the division by 2 means that there might be cases when the padding on both sides (top vs bottom, right vs left) are off by one. In this case, the bottom and right sides always get the one additional padded pixel. For example, when <code>pad_along_height</code> is 5, we pad 2 pixels at the top and 3 pixels at the bottom. Note that this is different from existing libraries such as cuDNN and Caffe, which explicitly specify the number of padded pixels and always pad the same number of pixels on both sides.</p>
<p>For the <code>'VALID</code>' padding, the output height and width are computed as:</p>
<pre><code>out_height = ceil(float(in_height - filter_height + 1) / float(strides[1]))
out_width  = ceil(float(in_width - filter_width + 1) / float(strides[2]))</code></pre>
<p>and the padding values are always zero. The output is then computed as</p>
<pre><code>output[b, i, j, :] =
    sum_{di, dj} input[b, strides[1] * i + di - pad_top,
                       strides[2] * j + dj - pad_left, ...] *
                 filter[di, dj, ...]</code></pre>
<p>where any value outside the original input image region are considered zero ( i.e. we pad zero values around the border of the image).</p>
<p>Since <code>input</code> is 4-D, each <code>input[b, i, j, :]</code> is a vector. For <code>conv2d</code>, these vectors are multiplied by the <code>filter[di, dj, :, :]</code> matrices to produce new vectors. For <code>depthwise_conv_2d</code>, each scalar component <code>input[b, i, j, k]</code> is multiplied by a vector <code>filter[di, dj, k]</code>, and all the vectors are concatenated.</p>
<hr />
<h3 id="tf.nn.convolutioninput-filter-padding-stridesnone-dilation_ratenone-namenone-data_formatnone"><a name="//apple_ref/cpp/Function/convolution" class="dashAnchor"></a><code id="convolution">tf.nn.convolution(input, filter, padding, strides=None, dilation_rate=None, name=None, data_format=None)</code></h3>
<p>Computes sums of N-D convolutions (actually cross-correlation).</p>
<p>This also supports either output striding via the optional <code>strides</code> parameter or atrous convolution (also known as convolution with holes or dilated convolution, based on the French word &quot;trous&quot; meaning holes in English) via the optional <code>dilation_rate</code> parameter. Currently, however, output striding is not supported for atrous convolutions.</p>
<p>Specifically, in the case that <code>data_format</code> does not start with &quot;NC&quot;, given a rank (N+2) <code>input</code> Tensor of shape</p>
<p>[num_batches, input_spatial_shape[0], ..., input_spatial_shape[N-1], num_input_channels],</p>
<p>a rank (N+2) <code>filter</code> Tensor of shape</p>
<p>[spatial_filter_shape[0], ..., spatial_filter_shape[N-1], num_input_channels, num_output_channels],</p>
<p>an optional <code>dilation_rate</code> tensor of shape [N] (defaulting to [1]<em>N) specifying the filter upsampling/input downsampling rate, and an optional list of N <code>strides</code> (defaulting [1]</em>N), this computes for each N-D spatial output position (x[0], ..., x[N-1]):</p>
<p>output[b, x[0], ..., x[N-1], k] =</p>
<pre><code>  sum_{z[0], ..., z[N-1], q}

      filter[z[0], ..., z[N-1], q, k] *
      padded_input[b,
                   x[0]*strides[0] + dilation_rate[0]*z[0],
                   ...,
                   x[N-1]*strides[N-1] + dilation_rate[N-1]*z[N-1],
                   q]</code></pre>
<p>where <code>padded_input</code> is obtained by zero padding the input using an effective spatial filter shape of <code>(spatial_filter_shape-1) * dilation_rate + 1</code> and output striding <code>strides</code> as described in the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>.</p>
<p>In the case that <code>data_format</code> does start with <code>&quot;NC&quot;</code>, the <code>input</code> and output (but not the <code>filter</code>) are simply transposed as follows:</p>
<p>convolution(input, data_format, <strong>kwargs) = tf.transpose(convolution(tf.transpose(input, [0] + range(2,N+2) + [1]), </strong>kwargs), [0, N+1] + range(1, N+1))</p>
<p>It is required that 1 &lt;= N &lt;= 3.</p>
<h5 id="args-10">Args:</h5>
<ul>
<li><b><code>input</code></b>: An N-D <code>Tensor</code> of type <code>T</code>, of shape <code>[batch_size] + input_spatial_shape + [in_channels]</code> if data_format does not start with &quot;NC&quot; (default), or <code>[batch_size, in_channels] + input_spatial_shape</code> if data_format starts with &quot;NC&quot;.</li>
<li><b><code>filter</code></b>: An N-D <code>Tensor</code> with the same type as <code>input</code> and shape <code>spatial_filter_shape + [in_channels, out_channels]</code>.</li>
<li><b><code>padding</code></b>: A string, either <code>&quot;VALID&quot;</code> or <code>&quot;SAME&quot;</code>. The padding algorithm.</li>
<li><b><code>strides</code></b>: Optional. Sequence of N ints &gt;= 1. Specifies the output stride. Defaults to [1]*N. If any value of strides is &gt; 1, then all values of dilation_rate must be 1.</li>
<li><b><code>dilation_rate</code></b>: Optional. Sequence of N ints &gt;= 1. Specifies the filter upsampling/input downsampling rate. In the literature, the same parameter is sometimes called <code>input stride</code> or <code>dilation</code>. The effective filter size used for the convolution will be <code>spatial_filter_shape + (spatial_filter_shape - 1) * (rate - 1)</code>, obtained by inserting (dilation_rate[i]-1) zeros between consecutive elements of the original filter in each spatial dimension i. If any value of dilation_rate is &gt; 1, then all values of strides must be 1.</li>
<li><b><code>name</code></b>: Optional name for the returned tensor.</li>
<li><b><code>data_format</code></b>: A string or None. Specifies whether the channel dimension of the <code>input</code> and output is the last dimension (default, or if <code>data_format</code> does not start with &quot;NC&quot;), or the second dimension (if <code>data_format</code> starts with &quot;NC&quot;). For N=1, the valid values are &quot;NWC&quot; (default) and &quot;NCW&quot;. For N=2, the valid values are &quot;NHWC&quot; (default) and &quot;NCHW&quot;. For N=3, the valid value is &quot;NDHWC&quot;.</li>
</ul>
<h5 id="returns-10">Returns:</h5>
<p>A <code>Tensor</code> with the same type as <code>input</code> of shape</p>
<pre><code>  `[batch_size] + output_spatial_shape + [out_channels]`</code></pre>
<p>if data_format is None or does not start with &quot;NC&quot;, or</p>
<pre><code>  `[batch_size, out_channels] + output_spatial_shape`</code></pre>
<p>if data_format starts with &quot;NC&quot;, where <code>output_spatial_shape</code> depends on the value of <code>padding</code>.</p>
<p>If padding == &quot;SAME&quot;: output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])</p>
<p>If padding == &quot;VALID&quot;: output_spatial_shape[i] = ceil((input_spatial_shape[i] - (spatial_filter_shape[i]-1) * dilation_rate[i]) / strides[i]).</p>
<h5 id="raises-1">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If input/output depth does not match <code>filter</code> shape, if padding is other than <code>&quot;VALID&quot;</code> or <code>&quot;SAME&quot;</code>, or if data_format is invalid.</li>
</ul>
<hr />
<h3 id="tf.nn.conv2dinput-filter-strides-padding-use_cudnn_on_gpunone-data_formatnone-namenone"><a name="//apple_ref/cpp/Function/conv2d" class="dashAnchor"></a><code id="conv2d">tf.nn.conv2d(input, filter, strides, padding, use_cudnn_on_gpu=None, data_format=None, name=None)</code></h3>
<p>Computes a 2-D convolution given 4-D <code>input</code> and <code>filter</code> tensors.</p>
<p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code> and a filter / kernel tensor of shape <code>[filter_height, filter_width, in_channels, out_channels]</code>, this op performs the following:</p>
<ol style="list-style-type: decimal">
<li>Flattens the filter to a 2-D matrix with shape <code>[filter_height * filter_width * in_channels, output_channels]</code>.</li>
<li>Extracts image patches from the input tensor to form a <em>virtual</em> tensor of shape <code>[batch, out_height, out_width,    filter_height * filter_width * in_channels]</code>.</li>
<li>For each patch, right-multiplies the filter matrix and the image patch vector.</li>
</ol>
<p>In detail, with the default NHWC format,</p>
<pre><code>output[b, i, j, k] =
    sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *
                    filter[di, dj, q, k]</code></pre>
<p>Must have <code>strides[0] = strides[3] = 1</code>. For the most common case of the same horizontal and vertices strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<h5 id="args-11">Args:</h5>
<ul>
<li><b><code>input</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.</li>
<li><b><code>filter</code></b>: A <code>Tensor</code>. Must have the same type as <code>input</code>.</li>
<li><b><code>strides</code></b>: A list of <code>ints</code>. 1-D of length 4. The stride of the sliding window for each dimension of <code>input</code>. Must be in the same order as the dimension specified with format.</li>
<li><b><code>padding</code></b>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</li>
<li><b><code>use_cudnn_on_gpu</code></b>: An optional <code>bool</code>. Defaults to <code>True</code>.</li>
<li><b><code>data_format</code></b>: An optional <code>string</code> from: <code>&quot;NHWC&quot;, &quot;NCHW&quot;</code>. Defaults to <code>&quot;NHWC&quot;</code>. Specify the data format of the input and output data. With the default format &quot;NHWC&quot;, the data is stored in the order of: [batch, in_height, in_width, in_channels]. Alternatively, the format could be &quot;NCHW&quot;, the data storage order of: [batch, in_channels, in_height, in_width].</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-11">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>input</code>.</p>
<hr />
<h3 id="tf.nn.depthwise_conv2dinput-filter-strides-padding-ratenone-namenone"><a name="//apple_ref/cpp/Function/depthwise_conv2d" class="dashAnchor"></a><code id="depthwise_conv2d">tf.nn.depthwise_conv2d(input, filter, strides, padding, rate=None, name=None)</code></h3>
<p>Depthwise 2-D convolution.</p>
<p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code> and a filter tensor of shape <code>[filter_height, filter_width, in_channels, channel_multiplier]</code> containing <code>in_channels</code> convolutional filters of depth 1, <code>depthwise_conv2d</code> applies a different filter to each input channel (expanding from 1 channel to <code>channel_multiplier</code> channels for each), then concatenates the results together. The output has <code>in_channels * channel_multiplier</code> channels.</p>
<p>In detail,</p>
<pre><code>output[b, i, j, k * channel_multiplier + q] = sum_{di, dj}
     filter[di, dj, k, q] * input[b, strides[1] * i + rate[0] * di,
                                     strides[2] * j + rate[1] * dj, k]</code></pre>
<p>Must have <code>strides[0] = strides[3] = 1</code>. For the most common case of the same horizontal and vertical strides, <code>strides = [1, stride, stride, 1]</code>. If any value in <code>rate</code> is greater than 1, we perform atrous depthwise convolution, in which case all values in the <code>strides</code> tensor must be equal to 1.</p>
<h5 id="args-12">Args:</h5>
<ul>
<li><b><code>input</code></b>: 4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.</li>
<li><b><code>filter</code></b>: 4-D with shape <code>[filter_height, filter_width, in_channels, channel_multiplier]</code>.</li>
<li><b><code>strides</code></b>: 1-D of size 4. The stride of the sliding window for each dimension of <code>input</code>.</li>
<li><b><code>padding</code></b>: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm. See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a></li>
<li><b><code>rate</code></b>: 1-D of size 2. The dilation rate in which we sample input values across the <code>height</code> and <code>width</code> dimensions in atrous convolution. If it is greater than 1, then all values of strides must be 1.</li>
<li><b><code>name</code></b>: A name for this operation (optional).</li>
</ul>
<h5 id="returns-12">Returns:</h5>
<p>A 4-D <code>Tensor</code> of shape <code>[batch, out_height, out_width, in_channels * channel_multiplier].</code></p>
<hr />
<h3 id="tf.nn.depthwise_conv2d_nativeinput-filter-strides-padding-namenone"><a name="//apple_ref/cpp/Function/depthwise_conv2d_native" class="dashAnchor"></a><code id="depthwise_conv2d_native">tf.nn.depthwise_conv2d_native(input, filter, strides, padding, name=None)</code></h3>
<p>Computes a 2-D depthwise convolution given 4-D <code>input</code> and <code>filter</code> tensors.</p>
<p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code> and a filter / kernel tensor of shape <code>[filter_height, filter_width, in_channels, channel_multiplier]</code>, containing <code>in_channels</code> convolutional filters of depth 1, <code>depthwise_conv2d</code> applies a different filter to each input channel (expanding from 1 channel to <code>channel_multiplier</code> channels for each), then concatenates the results together. Thus, the output has <code>in_channels * channel_multiplier</code> channels.</p>
<p>for k in 0..in_channels-1 for q in 0..channel_multiplier-1 output[b, i, j, k * channel_multiplier + q] = sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] * filter[di, dj, k, q]</p>
<p>Must have <code>strides[0] = strides[3] = 1</code>. For the most common case of the same horizontal and vertices strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<h5 id="args-13">Args:</h5>
<ul>
<li><b><code>input</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>.</li>
<li><b><code>filter</code></b>: A <code>Tensor</code>. Must have the same type as <code>input</code>.</li>
<li><b><code>strides</code></b>: A list of <code>ints</code>. 1-D of length 4. The stride of the sliding window for each dimension of <code>input</code>.</li>
<li><b><code>padding</code></b>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-13">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>input</code>.</p>
<hr />
<h3 id="tf.nn.separable_conv2dinput-depthwise_filter-pointwise_filter-strides-padding-ratenone-namenone"><a name="//apple_ref/cpp/Function/separable_conv2d" class="dashAnchor"></a><code id="separable_conv2d">tf.nn.separable_conv2d(input, depthwise_filter, pointwise_filter, strides, padding, rate=None, name=None)</code></h3>
<p>2-D convolution with separable filters.</p>
<p>Performs a depthwise convolution that acts separately on channels followed by a pointwise convolution that mixes channels. Note that this is separability between dimensions <code>[1, 2]</code> and <code>3</code>, not spatial separability between dimensions <code>1</code> and <code>2</code>.</p>
<p>In detail,</p>
<pre><code>output[b, i, j, k] = sum_{di, dj, q, r]
    input[b, strides[1] * i + di, strides[2] * j + dj, q] *
    depthwise_filter[di, dj, q, r] *
    pointwise_filter[0, 0, q * channel_multiplier + r, k]</code></pre>
<p><code>strides</code> controls the strides for the depthwise convolution only, since the pointwise convolution has implicit strides of <code>[1, 1, 1, 1]</code>. Must have <code>strides[0] = strides[3] = 1</code>. For the most common case of the same horizontal and vertical strides, <code>strides = [1, stride, stride, 1]</code>. If any value in <code>rate</code> is greater than 1, we perform atrous depthwise convolution, in which case all values in the <code>strides</code> tensor must be equal to 1.</p>
<h5 id="args-14">Args:</h5>
<ul>
<li><b><code>input</code></b>: 4-D <code>Tensor</code> with shape <code>[batch, in_height, in_width, in_channels]</code>.</li>
<li><b><code>depthwise_filter</code></b>: 4-D <code>Tensor</code> with shape <code>[filter_height, filter_width, in_channels, channel_multiplier]</code>. Contains <code>in_channels</code> convolutional filters of depth 1.</li>
<li><b><code>pointwise_filter</code></b>: 4-D <code>Tensor</code> with shape <code>[1, 1, channel_multiplier * in_channels, out_channels]</code>. Pointwise filter to mix channels after <code>depthwise_filter</code> has convolved spatially.</li>
<li><b><code>strides</code></b>: 1-D of size 4. The strides for the depthwise convolution for each dimension of <code>input</code>.</li>
<li><b><code>padding</code></b>: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm. See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a></li>
<li><b><code>rate</code></b>: 1-D of size 2. The dilation rate in which we sample input values across the <code>height</code> and <code>width</code> dimensions in atrous convolution. If it is greater than 1, then all values of strides must be 1.</li>
<li><b><code>name</code></b>: A name for this operation (optional).</li>
</ul>
<h5 id="returns-14">Returns:</h5>
<p>A 4-D <code>Tensor</code> of shape <code>[batch, out_height, out_width, out_channels]</code>.</p>
<h5 id="raises-2">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If channel_multiplier * in_channels &gt; out_channels, which means that the separable convolution is overparameterized.</li>
</ul>
<hr />
<h3 id="tf.nn.atrous_conv2dvalue-filters-rate-padding-namenone"><a name="//apple_ref/cpp/Function/atrous_conv2d" class="dashAnchor"></a><code id="atrous_conv2d">tf.nn.atrous_conv2d(value, filters, rate, padding, name=None)</code></h3>
<p>Atrous convolution (a.k.a. convolution with holes or dilated convolution).</p>
<p>Computes a 2-D atrous convolution, also known as convolution with holes or dilated convolution, given 4-D <code>value</code> and <code>filters</code> tensors. If the <code>rate</code> parameter is equal to one, it performs regular 2-D convolution. If the <code>rate</code> parameter is greater than one, it performs convolution with holes, sampling the input values every <code>rate</code> pixels in the <code>height</code> and <code>width</code> dimensions. This is equivalent to convolving the input with a set of upsampled filters, produced by inserting <code>rate - 1</code> zeros between two consecutive values of the filters along the <code>height</code> and <code>width</code> dimensions, hence the name atrous convolution or convolution with holes (the French word trous means holes in English).</p>
<p>More specifically:</p>
<pre><code>output[b, i, j, k] = sum_{di, dj, q} filters[di, dj, q, k] *
      value[b, i + rate * di, j + rate * dj, q]</code></pre>
<p>Atrous convolution allows us to explicitly control how densely to compute feature responses in fully convolutional networks. Used in conjunction with bilinear interpolation, it offers an alternative to <code>conv2d_transpose</code> in dense prediction tasks such as semantic image segmentation, optical flow computation, or depth estimation. It also allows us to effectively enlarge the field of view of filters without increasing the number of parameters or the amount of computation.</p>
<p>For a description of atrous convolution and how it can be used for dense feature extraction, please see: <a href="http://arxiv.org/abs/1412.7062">Semantic Image Segmentation with Deep Convolutional Nets and Fully Connected CRFs</a>. The same operation is investigated further in <a href="http://arxiv.org/abs/1511.07122">Multi-Scale Context Aggregation by Dilated Convolutions</a>. Previous works that effectively use atrous convolution in different ways are, among others, <a href="http://arxiv.org/abs/1312.6229">OverFeat: Integrated Recognition, Localization and Detection using Convolutional Networks</a> and <a href="http://arxiv.org/abs/1302.1700">Fast Image Scanning with Deep Max-Pooling Convolutional Neural Networks</a>. Atrous convolution is also closely related to the so-called noble identities in multi-rate signal processing.</p>
<p>There are many different ways to implement atrous convolution (see the refs above). The implementation here reduces</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    atrous_conv2d(value, filters, rate, padding<span class="op">=</span>padding)</code></pre></div>
<p>to the following three operations:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    paddings <span class="op">=</span> ...
    net <span class="op">=</span> space_to_batch(value, paddings, block_size<span class="op">=</span>rate)
    net <span class="op">=</span> conv2d(net, filters, strides<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>], padding<span class="op">=</span><span class="st">&quot;VALID&quot;</span>)
    crops <span class="op">=</span> ...
    net <span class="op">=</span> batch_to_space(net, crops, block_size<span class="op">=</span>rate)</code></pre></div>
<p>Advanced usage. Note the following optimization: A sequence of <code>atrous_conv2d</code> operations with identical <code>rate</code> parameters, 'SAME' <code>padding</code>, and filters with odd heights/ widths:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    net <span class="op">=</span> atrous_conv2d(net, filters1, rate, padding<span class="op">=</span><span class="st">&quot;SAME&quot;</span>)
    net <span class="op">=</span> atrous_conv2d(net, filters2, rate, padding<span class="op">=</span><span class="st">&quot;SAME&quot;</span>)
    ...
    net <span class="op">=</span> atrous_conv2d(net, filtersK, rate, padding<span class="op">=</span><span class="st">&quot;SAME&quot;</span>)</code></pre></div>
<p>can be equivalently performed cheaper in terms of computation and memory as:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    pad <span class="op">=</span> ...  <span class="co"># padding so that the input dims are multiples of rate</span>
    net <span class="op">=</span> space_to_batch(net, paddings<span class="op">=</span>pad, block_size<span class="op">=</span>rate)
    net <span class="op">=</span> conv2d(net, filters1, strides<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>], padding<span class="op">=</span><span class="st">&quot;SAME&quot;</span>)
    net <span class="op">=</span> conv2d(net, filters2, strides<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>], padding<span class="op">=</span><span class="st">&quot;SAME&quot;</span>)
    ...
    net <span class="op">=</span> conv2d(net, filtersK, strides<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>], padding<span class="op">=</span><span class="st">&quot;SAME&quot;</span>)
    net <span class="op">=</span> batch_to_space(net, crops<span class="op">=</span>pad, block_size<span class="op">=</span>rate)</code></pre></div>
<p>because a pair of consecutive <code>space_to_batch</code> and <code>batch_to_space</code> ops with the same <code>block_size</code> cancel out when their respective <code>paddings</code> and <code>crops</code> inputs are identical.</p>
<h5 id="args-15">Args:</h5>
<ul>
<li><b><code>value</code></b>: A 4-D <code>Tensor</code> of type <code>float</code>. It needs to be in the default &quot;NHWC&quot; format. Its shape is <code>[batch, in_height, in_width, in_channels]</code>.</li>
<li><b><code>filters</code></b>: A 4-D <code>Tensor</code> with the same type as <code>value</code> and shape <code>[filter_height, filter_width, in_channels, out_channels]</code>. <code>filters</code>' <code>in_channels</code> dimension must match that of <code>value</code>. Atrous convolution is equivalent to standard convolution with upsampled filters with effective height <code>filter_height + (filter_height - 1) * (rate - 1)</code> and effective width <code>filter_width + (filter_width - 1) * (rate - 1)</code>, produced by inserting <code>rate - 1</code> zeros along consecutive elements across the <code>filters</code>' spatial dimensions.</li>
<li><b><code>rate</code></b>: A positive int32. The stride with which we sample input values across the <code>height</code> and <code>width</code> dimensions. Equivalently, the rate by which we upsample the filter values by inserting zeros across the <code>height</code> and <code>width</code> dimensions. In the literature, the same parameter is sometimes called <code>input stride</code> or <code>dilation</code>.</li>
<li><b><code>padding</code></b>: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.</li>
<li><b><code>name</code></b>: Optional name for the returned tensor.</li>
</ul>
<h5 id="returns-15">Returns:</h5>
<p>A <code>Tensor</code> with the same type as <code>value</code>.</p>
<h5 id="raises-3">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If input/output depth does not match <code>filters</code>' shape, or if padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</li>
</ul>
<hr />
<h3 id="tf.nn.atrous_conv2d_transposevalue-filters-output_shape-rate-padding-namenone"><a name="//apple_ref/cpp/Function/atrous_conv2d_transpose" class="dashAnchor"></a><code id="atrous_conv2d_transpose">tf.nn.atrous_conv2d_transpose(value, filters, output_shape, rate, padding, name=None)</code></h3>
<p>The transpose of <code>atrous_conv2d</code>.</p>
<p>This operation is sometimes called &quot;deconvolution&quot; after <a href="http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf">Deconvolutional Networks</a>, but is actually the transpose (gradient) of <code>atrous_conv2d</code> rather than an actual deconvolution.</p>
<h5 id="args-16">Args:</h5>
<ul>
<li><b><code>value</code></b>: A 4-D <code>Tensor</code> of type <code>float</code>. It needs to be in the default <code>NHWC</code> format. Its shape is <code>[batch, in_height, in_width, in_channels]</code>.</li>
<li><b><code>filters</code></b>: A 4-D <code>Tensor</code> with the same type as <code>value</code> and shape <code>[filter_height, filter_width, out_channels, in_channels]</code>. <code>filters</code>' <code>in_channels</code> dimension must match that of <code>value</code>. Atrous convolution is equivalent to standard convolution with upsampled filters with effective height <code>filter_height + (filter_height - 1) * (rate - 1)</code> and effective width <code>filter_width + (filter_width - 1) * (rate - 1)</code>, produced by inserting <code>rate - 1</code> zeros along consecutive elements across the <code>filters</code>' spatial dimensions.</li>
<li><b><code>output_shape</code></b>: A 1-D <code>Tensor</code> of shape representing the output shape of the deconvolution op.</li>
<li><b><code>rate</code></b>: A positive int32. The stride with which we sample input values across the <code>height</code> and <code>width</code> dimensions. Equivalently, the rate by which we upsample the filter values by inserting zeros across the <code>height</code> and <code>width</code> dimensions. In the literature, the same parameter is sometimes called <code>input stride</code> or <code>dilation</code>.</li>
<li><b><code>padding</code></b>: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm.</li>
<li><b><code>name</code></b>: Optional name for the returned tensor.</li>
</ul>
<h5 id="returns-16">Returns:</h5>
<p>A <code>Tensor</code> with the same type as <code>value</code>.</p>
<h5 id="raises-4">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If input/output depth does not match <code>filters</code>' shape, or if padding is other than <code>'VALID'</code> or <code>'SAME'</code>, or if the <code>rate</code> is less than one, or if the output_shape is not a tensor with 4 elements.</li>
</ul>
<hr />
<h3 id="tf.nn.conv2d_transposevalue-filter-output_shape-strides-paddingsame-data_formatnhwc-namenone"><a name="//apple_ref/cpp/Function/conv2d_transpose" class="dashAnchor"></a><code id="conv2d_transpose">tf.nn.conv2d_transpose(value, filter, output_shape, strides, padding='SAME', data_format='NHWC', name=None)</code></h3>
<p>The transpose of <code>conv2d</code>.</p>
<p>This operation is sometimes called &quot;deconvolution&quot; after <a href="http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf">Deconvolutional Networks</a>, but is actually the transpose (gradient) of <code>conv2d</code> rather than an actual deconvolution.</p>
<h5 id="args-17">Args:</h5>
<ul>
<li><b><code>value</code></b>: A 4-D <code>Tensor</code> of type <code>float</code> and shape <code>[batch, height, width, in_channels]</code> for <code>NHWC</code> data format or <code>[batch, in_channels, height, width]</code> for <code>NCHW</code> data format.</li>
<li><b><code>filter</code></b>: A 4-D <code>Tensor</code> with the same type as <code>value</code> and shape <code>[height, width, output_channels, in_channels]</code>. <code>filter</code>'s <code>in_channels</code> dimension must match that of <code>value</code>.</li>
<li><b><code>output_shape</code></b>: A 1-D <code>Tensor</code> representing the output shape of the deconvolution op.</li>
<li><b><code>strides</code></b>: A list of ints. The stride of the sliding window for each dimension of the input tensor.</li>
<li><b><code>padding</code></b>: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm. See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a></li>
<li><b><code>data_format</code></b>: A string. 'NHWC' and 'NCHW' are supported.</li>
<li><b><code>name</code></b>: Optional name for the returned tensor.</li>
</ul>
<h5 id="returns-17">Returns:</h5>
<p>A <code>Tensor</code> with the same type as <code>value</code>.</p>
<h5 id="raises-5">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If input/output depth does not match <code>filter</code>'s shape, or if padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</li>
</ul>
<hr />
<h3 id="tf.nn.conv1dvalue-filters-stride-padding-use_cudnn_on_gpunone-data_formatnone-namenone"><a name="//apple_ref/cpp/Function/conv1d" class="dashAnchor"></a><code id="conv1d">tf.nn.conv1d(value, filters, stride, padding, use_cudnn_on_gpu=None, data_format=None, name=None)</code></h3>
<p>Computes a 1-D convolution given 3-D input and filter tensors.</p>
<p>Given an input tensor of shape [batch, in_width, in_channels] if data_format is &quot;NHWC&quot;, or [batch, in_channels, in_width] if data_format is &quot;NCHW&quot;, and a filter / kernel tensor of shape [filter_width, in_channels, out_channels], this op reshapes the arguments to pass them to conv2d to perform the equivalent convolution operation.</p>
<p>Internally, this op reshapes the input tensors and invokes <code>tf.nn.conv2d</code>. For example, if <code>data_format</code> does not start with &quot;NC&quot;, a tensor of shape [batch, in_width, in_channels] is reshaped to [batch, 1, in_width, in_channels], and the filter is reshaped to [1, filter_width, in_channels, out_channels]. The result is then reshaped back to [batch, out_width, out_channels] (where out_width is a function of the stride and padding as in conv2d) and returned to the caller.</p>
<h5 id="args-18">Args:</h5>
<ul>
<li><b><code>value</code></b>: A 3D <code>Tensor</code>. Must be of type <code>float32</code> or <code>float64</code>.</li>
<li><b><code>filters</code></b>: A 3D <code>Tensor</code>. Must have the same type as <code>input</code>.</li>
<li><b><code>stride</code></b>: An <code>integer</code>. The number of entries by which the filter is moved right at each step.</li>
<li><b><code>padding</code></b>: 'SAME' or 'VALID'</li>
<li><b><code>use_cudnn_on_gpu</code></b>: An optional <code>bool</code>. Defaults to <code>True</code>.</li>
<li><b><code>data_format</code></b>: An optional <code>string</code> from <code>&quot;NHWC&quot;, &quot;NCHW&quot;</code>. Defaults to <code>&quot;NHWC&quot;</code>, the data is stored in the order of [batch, in_width, in_channels]. The <code>&quot;NCHW&quot;</code> format stores data as [batch, in_channels, in_width].</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-18">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as input.</p>
<h5 id="raises-6">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: if <code>data_format</code> is invalid.</li>
</ul>
<hr />
<h3 id="tf.nn.conv3dinput-filter-strides-padding-namenone"><a name="//apple_ref/cpp/Function/conv3d" class="dashAnchor"></a><code id="conv3d">tf.nn.conv3d(input, filter, strides, padding, name=None)</code></h3>
<p>Computes a 3-D convolution given 5-D <code>input</code> and <code>filter</code> tensors.</p>
<p>In signal processing, cross-correlation is a measure of similarity of two waveforms as a function of a time-lag applied to one of them. This is also known as a sliding dot product or sliding inner-product.</p>
<p>Our Conv3D implements a form of cross-correlation.</p>
<h5 id="args-19">Args:</h5>
<ul>
<li><b><code>input</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>. Shape <code>[batch, in_depth, in_height, in_width, in_channels]</code>.</li>
<li><b><code>filter</code></b>: A <code>Tensor</code>. Must have the same type as <code>input</code>. Shape <code>[filter_depth, filter_height, filter_width, in_channels, out_channels]</code>. <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.</li>
<li><b><code>strides</code></b>: A list of <code>ints</code> that has length <code>&gt;= 5</code>. 1-D tensor of length 5. The stride of the sliding window for each dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</li>
<li><b><code>padding</code></b>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-19">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>input</code>.</p>
<hr />
<h3 id="tf.nn.conv3d_transposevalue-filter-output_shape-strides-paddingsame-namenone"><a name="//apple_ref/cpp/Function/conv3d_transpose" class="dashAnchor"></a><code id="conv3d_transpose">tf.nn.conv3d_transpose(value, filter, output_shape, strides, padding='SAME', name=None)</code></h3>
<p>The transpose of <code>conv3d</code>.</p>
<p>This operation is sometimes called &quot;deconvolution&quot; after <a href="http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf">Deconvolutional Networks</a>, but is actually the transpose (gradient) of <code>conv3d</code> rather than an actual deconvolution.</p>
<h5 id="args-20">Args:</h5>
<ul>
<li><b><code>value</code></b>: A 5-D <code>Tensor</code> of type <code>float</code> and shape <code>[batch, depth, height, width, in_channels]</code>.</li>
<li><b><code>filter</code></b>: A 5-D <code>Tensor</code> with the same type as <code>value</code> and shape <code>[depth, height, width, output_channels, in_channels]</code>. <code>filter</code>'s <code>in_channels</code> dimension must match that of <code>value</code>.</li>
<li><b><code>output_shape</code></b>: A 1-D <code>Tensor</code> representing the output shape of the deconvolution op.</li>
<li><b><code>strides</code></b>: A list of ints. The stride of the sliding window for each dimension of the input tensor.</li>
<li><b><code>padding</code></b>: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm. See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a></li>
<li><b><code>name</code></b>: Optional name for the returned tensor.</li>
</ul>
<h5 id="returns-20">Returns:</h5>
<p>A <code>Tensor</code> with the same type as <code>value</code>.</p>
<h5 id="raises-7">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If input/output depth does not match <code>filter</code>'s shape, or if padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</li>
</ul>
<hr />
<h3 id="tf.nn.conv2d_backprop_filterinput-filter_sizes-out_backprop-strides-padding-use_cudnn_on_gpunone-data_formatnone-namenone"><a name="//apple_ref/cpp/Function/conv2d_backprop_filter" class="dashAnchor"></a><code id="conv2d_backprop_filter">tf.nn.conv2d_backprop_filter(input, filter_sizes, out_backprop, strides, padding, use_cudnn_on_gpu=None, data_format=None, name=None)</code></h3>
<p>Computes the gradients of convolution with respect to the filter.</p>
<h5 id="args-21">Args:</h5>
<ul>
<li><b><code>input</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>. 4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.</li>
<li><b><code>filter_sizes</code></b>: A <code>Tensor</code> of type <code>int32</code>. An integer vector representing the tensor shape of <code>filter</code>, where <code>filter</code> is a 4-D <code>[filter_height, filter_width, in_channels, out_channels]</code> tensor.</li>
<li><b><code>out_backprop</code></b>: A <code>Tensor</code>. Must have the same type as <code>input</code>. 4-D with shape <code>[batch, out_height, out_width, out_channels]</code>. Gradients w.r.t. the output of the convolution.</li>
<li><b><code>strides</code></b>: A list of <code>ints</code>. The stride of the sliding window for each dimension of the input of the convolution. Must be in the same order as the dimension specified with format.</li>
<li><b><code>padding</code></b>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</li>
<li><b><code>use_cudnn_on_gpu</code></b>: An optional <code>bool</code>. Defaults to <code>True</code>.</li>
<li><b><code>data_format</code></b>: An optional <code>string</code> from: <code>&quot;NHWC&quot;, &quot;NCHW&quot;</code>. Defaults to <code>&quot;NHWC&quot;</code>. Specify the data format of the input and output data. With the default format &quot;NHWC&quot;, the data is stored in the order of: [batch, in_height, in_width, in_channels]. Alternatively, the format could be &quot;NCHW&quot;, the data storage order of: [batch, in_channels, in_height, in_width].</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-21">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>input</code>. 4-D with shape <code>[filter_height, filter_width, in_channels, out_channels]</code>. Gradient w.r.t. the <code>filter</code> input of the convolution.</p>
<hr />
<h3 id="tf.nn.conv2d_backprop_inputinput_sizes-filter-out_backprop-strides-padding-use_cudnn_on_gpunone-data_formatnone-namenone"><a name="//apple_ref/cpp/Function/conv2d_backprop_input" class="dashAnchor"></a><code id="conv2d_backprop_input">tf.nn.conv2d_backprop_input(input_sizes, filter, out_backprop, strides, padding, use_cudnn_on_gpu=None, data_format=None, name=None)</code></h3>
<p>Computes the gradients of convolution with respect to the input.</p>
<h5 id="args-22">Args:</h5>
<ul>
<li><b><code>input_sizes</code></b>: A <code>Tensor</code> of type <code>int32</code>. An integer vector representing the shape of <code>input</code>, where <code>input</code> is a 4-D <code>[batch, height, width, channels]</code> tensor.</li>
<li><b><code>filter</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>. 4-D with shape <code>[filter_height, filter_width, in_channels, out_channels]</code>.</li>
<li><b><code>out_backprop</code></b>: A <code>Tensor</code>. Must have the same type as <code>filter</code>. 4-D with shape <code>[batch, out_height, out_width, out_channels]</code>. Gradients w.r.t. the output of the convolution.</li>
<li><b><code>strides</code></b>: A list of <code>ints</code>. The stride of the sliding window for each dimension of the input of the convolution. Must be in the same order as the dimension specified with format.</li>
<li><b><code>padding</code></b>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</li>
<li><b><code>use_cudnn_on_gpu</code></b>: An optional <code>bool</code>. Defaults to <code>True</code>.</li>
<li><b><code>data_format</code></b>: An optional <code>string</code> from: <code>&quot;NHWC&quot;, &quot;NCHW&quot;</code>. Defaults to <code>&quot;NHWC&quot;</code>. Specify the data format of the input and output data. With the default format &quot;NHWC&quot;, the data is stored in the order of: [batch, in_height, in_width, in_channels]. Alternatively, the format could be &quot;NCHW&quot;, the data storage order of: [batch, in_channels, in_height, in_width].</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-22">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>filter</code>. 4-D with shape <code>[batch, in_height, in_width, in_channels]</code>. Gradient w.r.t. the input of the convolution.</p>
<hr />
<h3 id="tf.nn.conv3d_backprop_filter_v2input-filter_sizes-out_backprop-strides-padding-namenone"><a name="//apple_ref/cpp/Function/conv3d_backprop_filter_v2" class="dashAnchor"></a><code id="conv3d_backprop_filter_v2">tf.nn.conv3d_backprop_filter_v2(input, filter_sizes, out_backprop, strides, padding, name=None)</code></h3>
<p>Computes the gradients of 3-D convolution with respect to the filter.</p>
<h5 id="args-23">Args:</h5>
<ul>
<li><b><code>input</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>. Shape <code>[batch, depth, rows, cols, in_channels]</code>.</li>
<li><b><code>filter_sizes</code></b>: A <code>Tensor</code> of type <code>int32</code>. An integer vector representing the tensor shape of <code>filter</code>, where <code>filter</code> is a 5-D <code>[filter_depth, filter_height, filter_width, in_channels, out_channels]</code> tensor.</li>
<li><b><code>out_backprop</code></b>: A <code>Tensor</code>. Must have the same type as <code>input</code>. Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols, out_channels]</code>.</li>
<li><b><code>strides</code></b>: A list of <code>ints</code> that has length <code>&gt;= 5</code>. 1-D tensor of length 5. The stride of the sliding window for each dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</li>
<li><b><code>padding</code></b>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-23">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>input</code>.</p>
<hr />
<h3 id="tf.nn.depthwise_conv2d_native_backprop_filterinput-filter_sizes-out_backprop-strides-padding-namenone"><a name="//apple_ref/cpp/Function/depthwise_conv2d_native_backprop_filter" class="dashAnchor"></a><code id="depthwise_conv2d_native_backprop_filter">tf.nn.depthwise_conv2d_native_backprop_filter(input, filter_sizes, out_backprop, strides, padding, name=None)</code></h3>
<p>Computes the gradients of depthwise convolution with respect to the filter.</p>
<h5 id="args-24">Args:</h5>
<ul>
<li><b><code>input</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>. 4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.</li>
<li><b><code>filter_sizes</code></b>: A <code>Tensor</code> of type <code>int32</code>. An integer vector representing the tensor shape of <code>filter</code>, where <code>filter</code> is a 4-D <code>[filter_height, filter_width, in_channels, depthwise_multiplier]</code> tensor.</li>
<li><b><code>out_backprop</code></b>: A <code>Tensor</code>. Must have the same type as <code>input</code>. 4-D with shape <code>[batch, out_height, out_width, out_channels]</code>. Gradients w.r.t. the output of the convolution.</li>
<li><b><code>strides</code></b>: A list of <code>ints</code>. The stride of the sliding window for each dimension of the input of the convolution.</li>
<li><b><code>padding</code></b>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-24">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>input</code>. 4-D with shape <code>[filter_height, filter_width, in_channels, out_channels]</code>. Gradient w.r.t. the <code>filter</code> input of the convolution.</p>
<hr />
<h3 id="tf.nn.depthwise_conv2d_native_backprop_inputinput_sizes-filter-out_backprop-strides-padding-namenone"><a name="//apple_ref/cpp/Function/depthwise_conv2d_native_backprop_input" class="dashAnchor"></a><code id="depthwise_conv2d_native_backprop_input">tf.nn.depthwise_conv2d_native_backprop_input(input_sizes, filter, out_backprop, strides, padding, name=None)</code></h3>
<p>Computes the gradients of depthwise convolution with respect to the input.</p>
<h5 id="args-25">Args:</h5>
<ul>
<li><b><code>input_sizes</code></b>: A <code>Tensor</code> of type <code>int32</code>. An integer vector representing the shape of <code>input</code>, where <code>input</code> is a 4-D <code>[batch, height, width, channels]</code> tensor.</li>
<li><b><code>filter</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>. 4-D with shape <code>[filter_height, filter_width, in_channels, depthwise_multiplier]</code>.</li>
<li><b><code>out_backprop</code></b>: A <code>Tensor</code>. Must have the same type as <code>filter</code>. 4-D with shape <code>[batch, out_height, out_width, out_channels]</code>. Gradients w.r.t. the output of the convolution.</li>
<li><b><code>strides</code></b>: A list of <code>ints</code>. The stride of the sliding window for each dimension of the input of the convolution.</li>
<li><b><code>padding</code></b>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-25">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>filter</code>. 4-D with shape <code>[batch, in_height, in_width, in_channels]</code>. Gradient w.r.t. the input of the convolution.</p>
<h2 id="pooling">Pooling</h2>
<p>The pooling ops sweep a rectangular window over the input tensor, computing a reduction operation for each window (average, max, or max with argmax). Each pooling op uses rectangular windows of size <code>ksize</code> separated by offset <code>strides</code>. For example, if <code>strides</code> is all ones every window is used, if <code>strides</code> is all twos every other window is used in each dimension, etc.</p>
<p>In detail, the output is</p>
<pre><code>output[i] = reduce(value[strides * i:strides * i + ksize])</code></pre>
<p>where the indices also take into consideration the padding values. Please refer to the <code>Convolution</code> section for details about the padding calculation.</p>
<hr />
<h3 id="tf.nn.avg_poolvalue-ksize-strides-padding-data_formatnhwc-namenone"><a name="//apple_ref/cpp/Function/avg_pool" class="dashAnchor"></a><code id="avg_pool">tf.nn.avg_pool(value, ksize, strides, padding, data_format='NHWC', name=None)</code></h3>
<p>Performs the average pooling on the input.</p>
<p>Each entry in <code>output</code> is the mean of the corresponding size <code>ksize</code> window in <code>value</code>.</p>
<h5 id="args-26">Args:</h5>
<ul>
<li><b><code>value</code></b>: A 4-D <code>Tensor</code> of shape <code>[batch, height, width, channels]</code> and type <code>float32</code>, <code>float64</code>, <code>qint8</code>, <code>quint8</code>, or <code>qint32</code>.</li>
<li><b><code>ksize</code></b>: A list of ints that has length &gt;= 4. The size of the window for each dimension of the input tensor.</li>
<li><b><code>strides</code></b>: A list of ints that has length &gt;= 4. The stride of the sliding window for each dimension of the input tensor.</li>
<li><b><code>padding</code></b>: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm. See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a></li>
<li><b><code>data_format</code></b>: A string. 'NHWC' and 'NCHW' are supported.</li>
<li><b><code>name</code></b>: Optional name for the operation.</li>
</ul>
<h5 id="returns-26">Returns:</h5>
<p>A <code>Tensor</code> with the same type as <code>value</code>. The average pooled output tensor.</p>
<hr />
<h3 id="tf.nn.max_poolvalue-ksize-strides-padding-data_formatnhwc-namenone"><a name="//apple_ref/cpp/Function/max_pool" class="dashAnchor"></a><code id="max_pool">tf.nn.max_pool(value, ksize, strides, padding, data_format='NHWC', name=None)</code></h3>
<p>Performs the max pooling on the input.</p>
<h5 id="args-27">Args:</h5>
<ul>
<li><b><code>value</code></b>: A 4-D <code>Tensor</code> with shape <code>[batch, height, width, channels]</code> and type <code>tf.float32</code>.</li>
<li><b><code>ksize</code></b>: A list of ints that has length &gt;= 4. The size of the window for each dimension of the input tensor.</li>
<li><b><code>strides</code></b>: A list of ints that has length &gt;= 4. The stride of the sliding window for each dimension of the input tensor.</li>
<li><b><code>padding</code></b>: A string, either <code>'VALID'</code> or <code>'SAME'</code>. The padding algorithm. See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a></li>
<li><b><code>data_format</code></b>: A string. 'NHWC' and 'NCHW' are supported.</li>
<li><b><code>name</code></b>: Optional name for the operation.</li>
</ul>
<h5 id="returns-27">Returns:</h5>
<p>A <code>Tensor</code> with type <code>tf.float32</code>. The max pooled output tensor.</p>
<hr />
<h3 id="tf.nn.max_pool_with_argmaxinput-ksize-strides-padding-targmaxnone-namenone"><a name="//apple_ref/cpp/Function/max_pool_with_argmax" class="dashAnchor"></a><code id="max_pool_with_argmax">tf.nn.max_pool_with_argmax(input, ksize, strides, padding, Targmax=None, name=None)</code></h3>
<p>Performs max pooling on the input and outputs both max values and indices.</p>
<p>The indices in <code>argmax</code> are flattened, so that a maximum value at position <code>[b, y, x, c]</code> becomes flattened index <code>((b * height + y) * width + x) * channels + c</code>.</p>
<h5 id="args-28">Args:</h5>
<ul>
<li><b><code>input</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>half</code>. 4-D with shape <code>[batch, height, width, channels]</code>. Input to pool over.</li>
<li><b><code>ksize</code></b>: A list of <code>ints</code> that has length <code>&gt;= 4</code>. The size of the window for each dimension of the input tensor.</li>
<li><b><code>strides</code></b>: A list of <code>ints</code> that has length <code>&gt;= 4</code>. The stride of the sliding window for each dimension of the input tensor.</li>
<li><b><code>padding</code></b>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</li>
<li><b><code>Targmax</code></b>: An optional <code>tf.DType</code> from: <code>tf.int32, tf.int64</code>. Defaults to <code>tf.int64</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-28">Returns:</h5>
<p>A tuple of <code>Tensor</code> objects (output, argmax).</p>
<ul>
<li><b><code>output</code></b>: A <code>Tensor</code>. Has the same type as <code>input</code>. The max pooled output tensor.</li>
<li><b><code>argmax</code></b>: A <code>Tensor</code> of type <code>Targmax</code>. 4-D. The flattened indices of the max values chosen for each output.</li>
</ul>
<hr />
<h3 id="tf.nn.avg_pool3dinput-ksize-strides-padding-namenone"><a name="//apple_ref/cpp/Function/avg_pool3d" class="dashAnchor"></a><code id="avg_pool3d">tf.nn.avg_pool3d(input, ksize, strides, padding, name=None)</code></h3>
<p>Performs 3D average pooling on the input.</p>
<h5 id="args-29">Args:</h5>
<ul>
<li><b><code>input</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>. Shape <code>[batch, depth, rows, cols, channels]</code> tensor to pool over.</li>
<li><b><code>ksize</code></b>: A list of <code>ints</code> that has length <code>&gt;= 5</code>. 1-D tensor of length 5. The size of the window for each dimension of the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.</li>
<li><b><code>strides</code></b>: A list of <code>ints</code> that has length <code>&gt;= 5</code>. 1-D tensor of length 5. The stride of the sliding window for each dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</li>
<li><b><code>padding</code></b>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-29">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>input</code>. The average pooled output tensor.</p>
<hr />
<h3 id="tf.nn.max_pool3dinput-ksize-strides-padding-namenone"><a name="//apple_ref/cpp/Function/max_pool3d" class="dashAnchor"></a><code id="max_pool3d">tf.nn.max_pool3d(input, ksize, strides, padding, name=None)</code></h3>
<p>Performs 3D max pooling on the input.</p>
<h5 id="args-30">Args:</h5>
<ul>
<li><b><code>input</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>. Shape <code>[batch, depth, rows, cols, channels]</code> tensor to pool over.</li>
<li><b><code>ksize</code></b>: A list of <code>ints</code> that has length <code>&gt;= 5</code>. 1-D tensor of length 5. The size of the window for each dimension of the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.</li>
<li><b><code>strides</code></b>: A list of <code>ints</code> that has length <code>&gt;= 5</code>. 1-D tensor of length 5. The stride of the sliding window for each dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</li>
<li><b><code>padding</code></b>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-30">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>input</code>. The max pooled output tensor.</p>
<hr />
<h3 id="tf.nn.fractional_avg_poolvalue-pooling_ratio-pseudo_randomnone-overlappingnone-deterministicnone-seednone-seed2none-namenone"><a name="//apple_ref/cpp/Function/fractional_avg_pool" class="dashAnchor"></a><code id="fractional_avg_pool">tf.nn.fractional_avg_pool(value, pooling_ratio, pseudo_random=None, overlapping=None, deterministic=None, seed=None, seed2=None, name=None)</code></h3>
<p>Performs fractional average pooling on the input.</p>
<p>Fractional average pooling is similar to Fractional max pooling in the pooling region generation step. The only difference is that after pooling regions are generated, a mean operation is performed instead of a max operation in each pooling region.</p>
<h5 id="args-31">Args:</h5>
<ul>
<li><b><code>value</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>. 4-D with shape <code>[batch, height, width, channels]</code>.</li>
<li><b><code>pooling_ratio</code></b>: A list of <code>floats</code> that has length <code>&gt;= 4</code>. Pooling ratio for each dimension of <code>value</code>, currently only supports row and col dimension and should be &gt;= 1.0. For example, a valid pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't allow pooling on batch and channels dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions respectively.</li>
<li><b><code>pseudo_random</code></b>: An optional <code>bool</code>. Defaults to <code>False</code>. When set to True, generates the pooling sequence in a pseudorandom fashion, otherwise, in a random fashion. Check paper <a href="http://arxiv.org/abs/1412.6071">Benjamin Graham, Fractional Max-Pooling</a> for difference between pseudorandom and random.</li>
<li><p><b><code>overlapping</code></b>: An optional <code>bool</code>. Defaults to <code>False</code>. When set to True, it means when pooling, the values at the boundary of adjacent pooling cells are used by both cells. For example:</p>
<p><code>index  0  1  2  3  4</code></p>
<p><code>value  20 5  16 3  7</code></p>
<p>If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice. The result would be [41/3, 26/3] for fractional avg pooling.</p></li>
<li><b><code>deterministic</code></b>: An optional <code>bool</code>. Defaults to <code>False</code>. When set to True, a fixed pooling region will be used when iterating over a FractionalAvgPool node in the computation graph. Mainly used in unit test to make FractionalAvgPool deterministic.</li>
<li><b><code>seed</code></b>: An optional <code>int</code>. Defaults to <code>0</code>. If either seed or seed2 are set to be non-zero, the random number generator is seeded by the given seed. Otherwise, it is seeded by a random seed.</li>
<li><b><code>seed2</code></b>: An optional <code>int</code>. Defaults to <code>0</code>. An second seed to avoid seed collision.</li>
<li><p><b><code>name</code></b>: A name for the operation (optional).</p></li>
</ul>
<h5 id="returns-31">Returns:</h5>
<p>A tuple of <code>Tensor</code> objects (output, row_pooling_sequence, col_pooling_sequence).</p>
<ul>
<li><b><code>output</code></b>: A <code>Tensor</code>. Has the same type as <code>value</code>. output tensor after fractional avg pooling.</li>
<li><b><code>row_pooling_sequence</code></b>: A <code>Tensor</code> of type <code>int64</code>. row pooling sequence, needed to calculate gradient.</li>
<li><b><code>col_pooling_sequence</code></b>: A <code>Tensor</code> of type <code>int64</code>. column pooling sequence, needed to calculate gradient.</li>
</ul>
<hr />
<h3 id="tf.nn.fractional_max_poolvalue-pooling_ratio-pseudo_randomnone-overlappingnone-deterministicnone-seednone-seed2none-namenone"><a name="//apple_ref/cpp/Function/fractional_max_pool" class="dashAnchor"></a><code id="fractional_max_pool">tf.nn.fractional_max_pool(value, pooling_ratio, pseudo_random=None, overlapping=None, deterministic=None, seed=None, seed2=None, name=None)</code></h3>
<p>Performs fractional max pooling on the input.</p>
<p>Fractional max pooling is slightly different than regular max pooling. In regular max pooling, you downsize an input set by taking the maximum value of smaller N x N subsections of the set (often 2x2), and try to reduce the set by a factor of N, where N is an integer. Fractional max pooling, as you might expect from the word &quot;fractional&quot;, means that the overall reduction ratio N does not have to be an integer.</p>
<p>The sizes of the pooling regions are generated randomly but are fairly uniform. For example, let's look at the height dimension, and the constraints on the list of rows that will be pool boundaries.</p>
<p>First we define the following:</p>
<ol style="list-style-type: decimal">
<li>input_row_length : the number of rows from the input set</li>
<li>output_row_length : which will be smaller than the input</li>
<li>alpha = input_row_length / output_row_length : our reduction ratio</li>
<li>K = floor(alpha)</li>
<li>row_pooling_sequence : this is the result list of pool boundary rows</li>
</ol>
<p>Then, row_pooling_sequence should satisfy:</p>
<ol style="list-style-type: decimal">
<li>a[0] = 0 : the first value of the sequence is 0</li>
<li>a[end] = input_row_length : the last value of the sequence is the size</li>
<li>K &lt;= (a[i+1] - a[i]) &lt;= K+1 : all intervals are K or K+1 size</li>
<li>length(row_pooling_sequence) = output_row_length+1</li>
</ol>
<p>For more details on fractional max pooling, see this paper: <a href="http://arxiv.org/abs/1412.6071">Benjamin Graham, Fractional Max-Pooling</a></p>
<h5 id="args-32">Args:</h5>
<ul>
<li><b><code>value</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>. 4-D with shape <code>[batch, height, width, channels]</code>.</li>
<li><b><code>pooling_ratio</code></b>: A list of <code>floats</code> that has length <code>&gt;= 4</code>. Pooling ratio for each dimension of <code>value</code>, currently only supports row and col dimension and should be &gt;= 1.0. For example, a valid pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't allow pooling on batch and channels dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions respectively.</li>
<li><b><code>pseudo_random</code></b>: An optional <code>bool</code>. Defaults to <code>False</code>. When set to True, generates the pooling sequence in a pseudorandom fashion, otherwise, in a random fashion. Check paper <a href="http://arxiv.org/abs/1412.6071">Benjamin Graham, Fractional Max-Pooling</a> for difference between pseudorandom and random.</li>
<li><p><b><code>overlapping</code></b>: An optional <code>bool</code>. Defaults to <code>False</code>. When set to True, it means when pooling, the values at the boundary of adjacent pooling cells are used by both cells. For example:</p>
<p><code>index  0  1  2  3  4</code></p>
<p><code>value  20 5  16 3  7</code></p>
<p>If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice. The result would be [20, 16] for fractional max pooling.</p></li>
<li><b><code>deterministic</code></b>: An optional <code>bool</code>. Defaults to <code>False</code>. When set to True, a fixed pooling region will be used when iterating over a FractionalMaxPool node in the computation graph. Mainly used in unit test to make FractionalMaxPool deterministic.</li>
<li><b><code>seed</code></b>: An optional <code>int</code>. Defaults to <code>0</code>. If either seed or seed2 are set to be non-zero, the random number generator is seeded by the given seed. Otherwise, it is seeded by a random seed.</li>
<li><b><code>seed2</code></b>: An optional <code>int</code>. Defaults to <code>0</code>. An second seed to avoid seed collision.</li>
<li><p><b><code>name</code></b>: A name for the operation (optional).</p></li>
</ul>
<h5 id="returns-32">Returns:</h5>
<p>A tuple of <code>Tensor</code> objects (output, row_pooling_sequence, col_pooling_sequence).</p>
<ul>
<li><b><code>output</code></b>: A <code>Tensor</code>. Has the same type as <code>value</code>. output tensor after fractional max pooling.</li>
<li><b><code>row_pooling_sequence</code></b>: A <code>Tensor</code> of type <code>int64</code>. row pooling sequence, needed to calculate gradient.</li>
<li><b><code>col_pooling_sequence</code></b>: A <code>Tensor</code> of type <code>int64</code>. column pooling sequence, needed to calculate gradient.</li>
</ul>
<hr />
<h3 id="tf.nn.poolinput-window_shape-pooling_type-padding-dilation_ratenone-stridesnone-namenone-data_formatnone"><a name="//apple_ref/cpp/Function/pool" class="dashAnchor"></a><code id="pool">tf.nn.pool(input, window_shape, pooling_type, padding, dilation_rate=None, strides=None, name=None, data_format=None)</code></h3>
<p>Performs an N-D pooling operation.</p>
<p>In the case that <code>data_format</code> does not start with &quot;NC&quot;, computes for 0 &lt;= b &lt; batch_size, 0 &lt;= x[i] &lt; output_spatial_shape[i], 0 &lt;= c &lt; num_channels:</p>
<p>output[b, x[0], ..., x[N-1], c] = REDUCE_{z[0], ..., z[N-1]} input[b, x[0] * strides[0] - pad_before[0] + dilation_rate[0]<em>z[0], ... x[N-1]</em>strides[N-1] - pad_before[N-1] + dilation_rate[N-1]*z[N-1], c],</p>
<p>where the reduction function REDUCE depends on the value of <code>pooling_type</code>, and pad_before is defined based on the value of <code>padding</code> as described in the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a>. The reduction never includes out-of-bounds positions.</p>
<p>In the case that <code>data_format</code> starts with <code>&quot;NC&quot;</code>, the <code>input</code> and output are simply transposed as follows:</p>
<p>pool(input, data_format, <strong>kwargs) = tf.transpose(pool(tf.transpose(input, [0] + range(2,N+2) + [1]), </strong>kwargs), [0, N+1] + range(1, N+1))</p>
<h5 id="args-33">Args:</h5>
<ul>
<li><b><code>input</code></b>: Tensor of rank N+2, of shape <code>[batch_size] + input_spatial_shape + [num_channels]</code> if data_format does not start with &quot;NC&quot; (default), or <code>[batch_size, num_channels] + input_spatial_shape</code> if data_format starts with &quot;NC&quot;. Pooling happens over the spatial dimensions only.</li>
<li><b><code>window_shape</code></b>: Sequence of N ints &gt;= 1.</li>
<li><b><code>pooling_type</code></b>: Specifies pooling operation, must be &quot;AVG&quot; or &quot;MAX&quot;.</li>
<li><b><code>padding</code></b>: The padding algorithm, must be &quot;SAME&quot; or &quot;VALID&quot;. See the <a href="https://www.tensorflow.org/api_docs/python/nn.html#convolution">comment here</a></li>
<li><b><code>dilation_rate</code></b>: Optional. Dilation rate. List of N ints &gt;= 1. Defaults to [1]*N. If any value of dilation_rate is &gt; 1, then all values of strides must be 1.</li>
<li><b><code>strides</code></b>: Optional. Sequence of N ints &gt;= 1. Defaults to [1]*N. If any value of strides is &gt; 1, then all values of dilation_rate must be
<ol style="list-style-type: decimal">
<li></li>
</ol></li>
<li><b><code>name</code></b>: Optional. Name of the op.</li>
<li><b><code>data_format</code></b>: A string or None. Specifies whether the channel dimension of the <code>input</code> and output is the last dimension (default, or if <code>data_format</code> does not start with &quot;NC&quot;), or the second dimension (if <code>data_format</code> starts with &quot;NC&quot;). For N=1, the valid values are &quot;NWC&quot; (default) and &quot;NCW&quot;. For N=2, the valid values are &quot;NHWC&quot; (default) and &quot;NCHW&quot;. For N=3, the valid value is &quot;NDHWC&quot;.</li>
</ul>
<h5 id="returns-33">Returns:</h5>
<p>Tensor of rank N+2, of shape [batch_size] + output_spatial_shape + [num_channels]</p>
<p>if data_format is None or does not start with &quot;NC&quot;, or</p>
<pre><code>[batch_size, num_channels] + output_spatial_shape</code></pre>
<p>if data_format starts with &quot;NC&quot;, where <code>output_spatial_shape</code> depends on the value of padding:</p>
<p>If padding = &quot;SAME&quot;: output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i]) If padding = &quot;VALID&quot;: output_spatial_shape[i] = ceil((input_spatial_shape[i] - (window_shape[i] - 1) * dilation_rate[i]) / strides[i]).</p>
<h5 id="raises-8">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: if arguments are invalid.</li>
</ul>
<h2 id="morphological-filtering">Morphological filtering</h2>
<p>Morphological operators are non-linear filters used in image processing.</p>
<p><a href="https://en.wikipedia.org/wiki/Dilation_(morphology)">Greyscale morphological dilation</a> is the max-sum counterpart of standard sum-product convolution:</p>
<pre><code>output[b, y, x, c] =
    max_{dy, dx} input[b,
                       strides[1] * y + rates[1] * dy,
                       strides[2] * x + rates[2] * dx,
                       c] +
                 filter[dy, dx, c]</code></pre>
<p>The <code>filter</code> is usually called structuring function. Max-pooling is a special case of greyscale morphological dilation when the filter assumes all-zero values (a.k.a. flat structuring function).</p>
<p><a href="https://en.wikipedia.org/wiki/Erosion_(morphology)">Greyscale morphological erosion</a> is the min-sum counterpart of standard sum-product convolution:</p>
<pre><code>output[b, y, x, c] =
    min_{dy, dx} input[b,
                       strides[1] * y - rates[1] * dy,
                       strides[2] * x - rates[2] * dx,
                       c] -
                 filter[dy, dx, c]</code></pre>
<p>Dilation and erosion are dual to each other. The dilation of the input signal <code>f</code> by the structuring signal <code>g</code> is equal to the negation of the erosion of <code>-f</code> by the reflected <code>g</code>, and vice versa.</p>
<p>Striding and padding is carried out in exactly the same way as in standard convolution. Please refer to the <code>Convolution</code> section for details.</p>
<hr />
<h3 id="tf.nn.dilation2dinput-filter-strides-rates-padding-namenone"><a name="//apple_ref/cpp/Function/dilation2d" class="dashAnchor"></a><code id="dilation2d">tf.nn.dilation2d(input, filter, strides, rates, padding, name=None)</code></h3>
<p>Computes the grayscale dilation of 4-D <code>input</code> and 3-D <code>filter</code> tensors.</p>
<p>The <code>input</code> tensor has shape <code>[batch, in_height, in_width, depth]</code> and the <code>filter</code> tensor has shape <code>[filter_height, filter_width, depth]</code>, i.e., each input channel is processed independently of the others with its own structuring function. The <code>output</code> tensor has shape <code>[batch, out_height, out_width, depth]</code>. The spatial dimensions of the output tensor depend on the <code>padding</code> algorithm. We currently only support the default &quot;NHWC&quot; <code>data_format</code>.</p>
<p>In detail, the grayscale morphological 2-D dilation is the max-sum correlation (for consistency with <code>conv2d</code>, we use unmirrored filters):</p>
<pre><code>output[b, y, x, c] =
   max_{dy, dx} input[b,
                      strides[1] * y + rates[1] * dy,
                      strides[2] * x + rates[2] * dx,
                      c] +
                filter[dy, dx, c]</code></pre>
<p>Max-pooling is a special case when the filter has size equal to the pooling kernel size and contains all zeros.</p>
<p>Note on duality: The dilation of <code>input</code> by the <code>filter</code> is equal to the negation of the erosion of <code>-input</code> by the reflected <code>filter</code>.</p>
<h5 id="args-34">Args:</h5>
<ul>
<li><b><code>input</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>int16</code>, <code>int8</code>, <code>uint16</code>, <code>half</code>. 4-D with shape <code>[batch, in_height, in_width, depth]</code>.</li>
<li><b><code>filter</code></b>: A <code>Tensor</code>. Must have the same type as <code>input</code>. 3-D with shape <code>[filter_height, filter_width, depth]</code>.</li>
<li><b><code>strides</code></b>: A list of <code>ints</code> that has length <code>&gt;= 4</code>. The stride of the sliding window for each dimension of the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.</li>
<li><b><code>rates</code></b>: A list of <code>ints</code> that has length <code>&gt;= 4</code>. The input stride for atrous morphological dilation. Must be: <code>[1, rate_height, rate_width, 1]</code>.</li>
<li><b><code>padding</code></b>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-34">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>input</code>. 4-D with shape <code>[batch, out_height, out_width, depth]</code>.</p>
<hr />
<h3 id="tf.nn.erosion2dvalue-kernel-strides-rates-padding-namenone"><a name="//apple_ref/cpp/Function/erosion2d" class="dashAnchor"></a><code id="erosion2d">tf.nn.erosion2d(value, kernel, strides, rates, padding, name=None)</code></h3>
<p>Computes the grayscale erosion of 4-D <code>value</code> and 3-D <code>kernel</code> tensors.</p>
<p>The <code>value</code> tensor has shape <code>[batch, in_height, in_width, depth]</code> and the <code>kernel</code> tensor has shape <code>[kernel_height, kernel_width, depth]</code>, i.e., each input channel is processed independently of the others with its own structuring function. The <code>output</code> tensor has shape <code>[batch, out_height, out_width, depth]</code>. The spatial dimensions of the output tensor depend on the <code>padding</code> algorithm. We currently only support the default &quot;NHWC&quot; <code>data_format</code>.</p>
<p>In detail, the grayscale morphological 2-D erosion is given by:</p>
<pre><code>output[b, y, x, c] =
   min_{dy, dx} value[b,
                      strides[1] * y - rates[1] * dy,
                      strides[2] * x - rates[2] * dx,
                      c] -
                kernel[dy, dx, c]</code></pre>
<p>Duality: The erosion of <code>value</code> by the <code>kernel</code> is equal to the negation of the dilation of <code>-value</code> by the reflected <code>kernel</code>.</p>
<h5 id="args-35">Args:</h5>
<ul>
<li><b><code>value</code></b>: A <code>Tensor</code>. 4-D with shape <code>[batch, in_height, in_width, depth]</code>.</li>
<li><b><code>kernel</code></b>: A <code>Tensor</code>. Must have the same type as <code>value</code>. 3-D with shape <code>[kernel_height, kernel_width, depth]</code>.</li>
<li><b><code>strides</code></b>: A list of <code>ints</code> that has length <code>&gt;= 4</code>. 1-D of length 4. The stride of the sliding window for each dimension of the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.</li>
<li><b><code>rates</code></b>: A list of <code>ints</code> that has length <code>&gt;= 4</code>. 1-D of length 4. The input stride for atrous morphological dilation. Must be: <code>[1, rate_height, rate_width, 1]</code>.</li>
<li><b><code>padding</code></b>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</li>
<li><b><code>name</code></b>: A name for the operation (optional). If not specified &quot;erosion2d&quot; is used.</li>
</ul>
<h5 id="returns-35">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>value</code>. 4-D with shape <code>[batch, out_height, out_width, depth]</code>.</p>
<h5 id="raises-9">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If the <code>value</code> depth does not match <code>kernel</code>' shape, or if padding is other than <code>'VALID'</code> or <code>'SAME'</code>.</li>
</ul>
<hr />
<h3 id="tf.nn.with_space_to_batchinput-dilation_rate-padding-op-filter_shapenone-spatial_dimsnone"><a name="//apple_ref/cpp/Function/with_space_to_batch" class="dashAnchor"></a><code id="with_space_to_batch">tf.nn.with_space_to_batch(input, dilation_rate, padding, op, filter_shape=None, spatial_dims=None)</code></h3>
<p>Performs <code>op</code> on the space-to-batch representation of <code>input</code>.</p>
<p>This has the effect of transforming sliding window operations into the corresponding &quot;atrous&quot; operation in which the input is sampled at the specified <code>dilation_rate</code>.</p>
<p>In the special case that <code>dilation_rate</code> is uniformly 1, this simply returns:</p>
<p>op(input, num_spatial_dims, padding)</p>
<p>Otherwise, it returns:</p>
<p>batch_to_space_nd( op(space_to_batch_nd(input, adjusted_dilation_rate, adjusted_paddings), num_spatial_dims, &quot;VALID&quot;) adjusted_dilation_rate, adjusted_crops),</p>
<p>where:</p>
<p>adjusted_dilation_rate is an int64 tensor of shape [max(spatial_dims)], adjusted_{paddings,crops} are int64 tensors of shape [max(spatial_dims), 2]</p>
<p>defined as follows:</p>
<p>We first define two int64 tensors <code>paddings</code> and <code>crops</code> of shape <code>[num_spatial_dims, 2]</code> based on the value of <code>padding</code> and the spatial dimensions of the <code>input</code>:</p>
<p>If <code>padding = &quot;VALID&quot;</code>, then:</p>
<p>paddings, crops = required_space_to_batch_paddings( input_shape[spatial_dims], dilation_rate)</p>
<p>If <code>padding = &quot;SAME&quot;</code>, then:</p>
<p>dilated_filter_shape = filter_shape + (filter_shape - 1) * (dilation_rate - 1)</p>
<p>paddings, crops = required_space_to_batch_paddings( input_shape[spatial_dims], dilation_rate, [(dilated_filter_shape - 1) // 2, dilated_filter_shape - 1 - (dilated_filter_shape - 1) // 2])</p>
<p>Because <code>space_to_batch_nd</code> and <code>batch_to_space_nd</code> assume that the spatial dimensions are contiguous starting at the second dimension, but the specified <code>spatial_dims</code> may not be, we must adjust <code>dilation_rate</code>, <code>paddings</code> and <code>crops</code> in order to be usable with these operations. For a given dimension, if the block size is 1, and both the starting and ending padding and crop amounts are 0, then space_to_batch_nd effectively leaves that dimension alone, which is what is needed for dimensions not part of <code>spatial_dims</code>. Furthermore, <code>space_to_batch_nd</code> and <code>batch_to_space_nd</code> handle this case efficiently for any number of leading and trailing dimensions.</p>
<p>For 0 &lt;= i &lt; len(spatial_dims), we assign:</p>
<p>adjusted_dilation_rate[spatial_dims[i] - 1] = dilation_rate[i] adjusted_paddings[spatial_dims[i] - 1, :] = paddings[i, :] adjusted_crops[spatial_dims[i] - 1, :] = crops[i, :]</p>
<p>All unassigned values of <code>adjusted_dilation_rate</code> default to 1, while all unassigned values of <code>adjusted_paddings</code> and <code>adjusted_crops</code> default to 0.</p>
<p>Note in the case that <code>dilation_rate</code> is not uniformly 1, specifying &quot;VALID&quot; padding is equivalent to specifying <code>padding = &quot;SAME&quot;</code> with a filter_shape of <code>[1]*N</code>.</p>
<p>Advanced usage. Note the following optimization: A sequence of <code>with_space_to_batch</code> operations with identical (not uniformly 1) <code>dilation_rate</code> parameters and &quot;VALID&quot; padding</p>
<p>net = with_space_to_batch(net, dilation_rate, &quot;VALID&quot;, op_1) ... net = with_space_to_batch(net, dilation_rate, &quot;VALID&quot;, op_k)</p>
<p>can be combined into a single <code>with_space_to_batch</code> operation as follows:</p>
<p>def combined_op(converted_input, num_spatial_dims, _): result = op_1(converted_input, num_spatial_dims, &quot;VALID&quot;) ... result = op_k(result, num_spatial_dims, &quot;VALID&quot;)</p>
<p>net = with_space_to_batch(net, dilation_rate, &quot;VALID&quot;, combined_op)</p>
<p>This eliminates the overhead of <code>k-1</code> calls to <code>space_to_batch_nd</code> and <code>batch_to_space_nd</code>.</p>
<p>Similarly, a sequence of <code>with_space_to_batch</code> operations with identical (not uniformly 1) <code>dilation_rate</code> parameters, &quot;SAME&quot; padding, and odd filter dimensions</p>
<p>net = with_space_to_batch(net, dilation_rate, &quot;SAME&quot;, op_1, filter_shape_1) ... net = with_space_to_batch(net, dilation_rate, &quot;SAME&quot;, op_k, filter_shape_k)</p>
<p>can be combined into a single <code>with_space_to_batch</code> operation as follows:</p>
<p>def combined_op(converted_input, num_spatial_dims, _): result = op_1(converted_input, num_spatial_dims, &quot;SAME&quot;) ... result = op_k(result, num_spatial_dims, &quot;SAME&quot;)</p>
<p>net = with_space_to_batch(net, dilation_rate, &quot;VALID&quot;, combined_op)</p>
<h5 id="args-36">Args:</h5>
<ul>
<li><b><code>input</code></b>: Tensor of rank &gt; max(spatial_dims).</li>
<li><b><code>dilation_rate</code></b>: int32 Tensor of <em>known</em> shape [num_spatial_dims].</li>
<li><b><code>padding</code></b>: str constant equal to &quot;VALID&quot; or &quot;SAME&quot;</li>
<li><b><code>op</code></b>: Function that maps (input, num_spatial_dims, padding) -&gt; output</li>
<li><b><code>filter_shape</code></b>: If padding = &quot;SAME&quot;, specifies the shape of the convolution kernel/pooling window as an integer Tensor of shape [&gt;=num_spatial_dims]. If padding = &quot;VALID&quot;, filter_shape is ignored and need not be specified.</li>
<li><b><code>spatial_dims</code></b>: Monotonically increasing sequence of <code>num_spatial_dims</code> integers (which are &gt;= 1) specifying the spatial dimensions of <code>input</code> and output. Defaults to: <code>range(1, num_spatial_dims+1)</code>.</li>
</ul>
<h5 id="returns-36">Returns:</h5>
<p>The output Tensor as described above.</p>
<h5 id="raises-10">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: if <code>padding</code> is invalid or the arguments are incompatible.</li>
<li><b><code>ValueError</code></b>: if <code>spatial_dims</code> are invalid.</li>
</ul>
<h2 id="normalization">Normalization</h2>
<p>Normalization is useful to prevent neurons from saturating when inputs may have varying scale, and to aid generalization.</p>
<hr />
<h3 id="tf.nn.l2_normalizex-dim-epsilon1e-12-namenone"><a name="//apple_ref/cpp/Function/l2_normalize" class="dashAnchor"></a><code id="l2_normalize">tf.nn.l2_normalize(x, dim, epsilon=1e-12, name=None)</code></h3>
<p>Normalizes along dimension <code>dim</code> using an L2 norm.</p>
<p>For a 1-D tensor with <code>dim = 0</code>, computes</p>
<pre><code>output = x / sqrt(max(sum(x**2), epsilon))</code></pre>
<p>For <code>x</code> with more dimensions, independently normalizes each 1-D slice along dimension <code>dim</code>.</p>
<h5 id="args-37">Args:</h5>
<ul>
<li><b><code>x</code></b>: A <code>Tensor</code>.</li>
<li><b><code>dim</code></b>: Dimension along which to normalize. A scalar or a vector of integers.</li>
<li><b><code>epsilon</code></b>: A lower bound value for the norm. Will use <code>sqrt(epsilon)</code> as the divisor if <code>norm &lt; sqrt(epsilon)</code>.</li>
<li><b><code>name</code></b>: A name for this operation (optional).</li>
</ul>
<h5 id="returns-37">Returns:</h5>
<p>A <code>Tensor</code> with the same shape as <code>x</code>.</p>
<hr />
<h3 id="tf.nn.local_response_normalizationinput-depth_radiusnone-biasnone-alphanone-betanone-namenone"><a name="//apple_ref/cpp/Function/local_response_normalization" class="dashAnchor"></a><code id="local_response_normalization">tf.nn.local_response_normalization(input, depth_radius=None, bias=None, alpha=None, beta=None, name=None)</code></h3>
<p>Local Response Normalization.</p>
<p>The 4-D <code>input</code> tensor is treated as a 3-D array of 1-D vectors (along the last dimension), and each vector is normalized independently. Within a given vector, each component is divided by the weighted, squared sum of inputs within <code>depth_radius</code>. In detail,</p>
<pre><code>sqr_sum[a, b, c, d] =
    sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)
output = input / (bias + alpha * sqr_sum) ** beta</code></pre>
<p>For details, see <a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks">Krizhevsky et al., ImageNet classification with deep convolutional neural networks (NIPS 2012)</a>.</p>
<h5 id="args-38">Args:</h5>
<ul>
<li><b><code>input</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>half</code>. 4-D.</li>
<li><b><code>depth_radius</code></b>: An optional <code>int</code>. Defaults to <code>5</code>. 0-D. Half-width of the 1-D normalization window.</li>
<li><b><code>bias</code></b>: An optional <code>float</code>. Defaults to <code>1</code>. An offset (usually positive to avoid dividing by 0).</li>
<li><b><code>alpha</code></b>: An optional <code>float</code>. Defaults to <code>1</code>. A scale factor, usually positive.</li>
<li><b><code>beta</code></b>: An optional <code>float</code>. Defaults to <code>0.5</code>. An exponent.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-38">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>input</code>.</p>
<hr />
<h3 id="tf.nn.sufficient_statisticsx-axes-shiftnone-keep_dimsfalse-namenone"><a name="//apple_ref/cpp/Function/sufficient_statistics" class="dashAnchor"></a><code id="sufficient_statistics">tf.nn.sufficient_statistics(x, axes, shift=None, keep_dims=False, name=None)</code></h3>
<p>Calculate the sufficient statistics for the mean and variance of <code>x</code>.</p>
<p>These sufficient statistics are computed using the one pass algorithm on an input that's optionally shifted. See: https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Computing_shifted_data</p>
<h5 id="args-39">Args:</h5>
<ul>
<li><b><code>x</code></b>: A <code>Tensor</code>.</li>
<li><b><code>axes</code></b>: Array of ints. Axes along which to compute mean and variance.</li>
<li><b><code>shift</code></b>: A <code>Tensor</code> containing the value by which to shift the data for numerical stability, or <code>None</code> if no shift is to be performed. A shift close to the true mean provides the most numerically stable results.</li>
<li><b><code>keep_dims</code></b>: produce statistics with the same dimensionality as the input.</li>
<li><b><code>name</code></b>: Name used to scope the operations that compute the sufficient stats.</li>
</ul>
<h5 id="returns-39">Returns:</h5>
<p>Four <code>Tensor</code> objects of the same type as <code>x</code>:</p>
<ul>
<li>the count (number of elements to average over).</li>
<li>the (possibly shifted) sum of the elements in the array.</li>
<li>the (possibly shifted) sum of squares of the elements in the array.</li>
<li>the shift by which the mean must be corrected or None if <code>shift</code> is None.</li>
</ul>
<hr />
<h3 id="tf.nn.normalize_momentscounts-mean_ss-variance_ss-shift-namenone"><a name="//apple_ref/cpp/Function/normalize_moments" class="dashAnchor"></a><code id="normalize_moments">tf.nn.normalize_moments(counts, mean_ss, variance_ss, shift, name=None)</code></h3>
<p>Calculate the mean and variance of based on the sufficient statistics.</p>
<h5 id="args-40">Args:</h5>
<ul>
<li><b><code>counts</code></b>: A <code>Tensor</code> containing a the total count of the data (one value).</li>
<li><b><code>mean_ss</code></b>: A <code>Tensor</code> containing the mean sufficient statistics: the (possibly shifted) sum of the elements to average over.</li>
<li><b><code>variance_ss</code></b>: A <code>Tensor</code> containing the variance sufficient statistics: the (possibly shifted) squared sum of the data to compute the variance over.</li>
<li><b><code>shift</code></b>: A <code>Tensor</code> containing the value by which the data is shifted for numerical stability, or <code>None</code> if no shift was performed.</li>
<li><b><code>name</code></b>: Name used to scope the operations that compute the moments.</li>
</ul>
<h5 id="returns-40">Returns:</h5>
<p>Two <code>Tensor</code> objects: <code>mean</code> and <code>variance</code>.</p>
<hr />
<h3 id="tf.nn.momentsx-axes-shiftnone-namenone-keep_dimsfalse"><a name="//apple_ref/cpp/Function/moments" class="dashAnchor"></a><code id="moments">tf.nn.moments(x, axes, shift=None, name=None, keep_dims=False)</code></h3>
<p>Calculate the mean and variance of <code>x</code>.</p>
<p>The mean and variance are calculated by aggregating the contents of <code>x</code> across <code>axes</code>. If <code>x</code> is 1-D and <code>axes = [0]</code> this is just the mean and variance of a vector.</p>
<p>Note: for numerical stability, when shift=None, the true mean would be computed and used as shift.</p>
<p>When using these moments for batch normalization (see <code>tf.nn.batch_normalization</code>):</p>
<ul>
<li>for so-called &quot;global normalization&quot;, used with convolutional filters with shape <code>[batch, height, width, depth]</code>, pass <code>axes=[0, 1, 2]</code>.</li>
<li>for simple batch normalization pass <code>axes=[0]</code> (batch only).</li>
</ul>
<h5 id="args-41">Args:</h5>
<ul>
<li><b><code>x</code></b>: A <code>Tensor</code>.</li>
<li><b><code>axes</code></b>: Array of ints. Axes along which to compute mean and variance.</li>
<li><b><code>shift</code></b>: A <code>Tensor</code> containing the value by which to shift the data for numerical stability, or <code>None</code> in which case the true mean of the data is used as shift. A shift close to the true mean provides the most numerically stable results.</li>
<li><b><code>name</code></b>: Name used to scope the operations that compute the moments.</li>
<li><b><code>keep_dims</code></b>: produce moments with the same dimensionality as the input.</li>
</ul>
<h5 id="returns-41">Returns:</h5>
<p>Two <code>Tensor</code> objects: <code>mean</code> and <code>variance</code>.</p>
<hr />
<h3 id="tf.nn.weighted_momentsx-axes-frequency_weights-namenone-keep_dimsfalse"><a name="//apple_ref/cpp/Function/weighted_moments" class="dashAnchor"></a><code id="weighted_moments">tf.nn.weighted_moments(x, axes, frequency_weights, name=None, keep_dims=False)</code></h3>
<p>Returns the frequency-weighted mean and variance of <code>x</code>.</p>
<h5 id="args-42">Args:</h5>
<ul>
<li><b><code>x</code></b>: A tensor.</li>
<li><b><code>axes</code></b>: 1-d tensor of int32 values; these are the axes along which to compute mean and variance.</li>
<li><b><code>frequency_weights</code></b>: A tensor of positive weights which can be broadcast with x.</li>
<li><b><code>name</code></b>: Name used to scope the operation.</li>
<li><b><code>keep_dims</code></b>: Produce moments with the same dimensionality as the input.</li>
</ul>
<h5 id="returns-42">Returns:</h5>
<p>Two tensors: <code>weighted_mean</code> and <code>weighted_variance</code>.</p>
<hr />
<h3 id="tf.nn.fused_batch_normx-scale-offset-meannone-variancenone-epsilon0.001-data_formatnhwc-is_trainingtrue-namenone"><a name="//apple_ref/cpp/Function/fused_batch_norm" class="dashAnchor"></a><code id="fused_batch_norm">tf.nn.fused_batch_norm(x, scale, offset, mean=None, variance=None, epsilon=0.001, data_format='NHWC', is_training=True, name=None)</code></h3>
<p>Batch normalization.</p>
<p>As described in http://arxiv.org/abs/1502.03167.</p>
<h5 id="args-43">Args:</h5>
<ul>
<li><b><code>x</code></b>: Input <code>Tensor</code> of 4 dimensions.</li>
<li><b><code>scale</code></b>: A <code>Tensor</code> of 1 dimension for scaling.</li>
<li><b><code>offset</code></b>: A <code>Tensor</code> of 1 dimension for bias.</li>
<li><b><code>mean</code></b>: A <code>Tensor</code> of 1 dimension for population mean used for inference.</li>
<li><b><code>variance</code></b>: A <code>Tensor</code> of 1 dimension for population variance used for inference.</li>
<li><b><code>epsilon</code></b>: A small float number added to the variance of x.</li>
<li><b><code>data_format</code></b>: The data format for x. Either &quot;NHWC&quot; (default) or &quot;NCHW&quot;.</li>
<li><b><code>is_training</code></b>: A bool value to specify if the operation is used for training or inference.</li>
<li><b><code>name</code></b>: A name for this operation (optional).</li>
</ul>
<h5 id="returns-43">Returns:</h5>
<ul>
<li><b><code>y</code></b>: A 4D Tensor for the normalized, scaled, offsetted x.</li>
<li><b><code>batch_mean</code></b>: A 1D Tensor for the mean of x.</li>
<li><b><code>batch_var</code></b>: A 1D Tensor for the variance of x.</li>
</ul>
<h5 id="raises-11">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If mean or variance is not None when is_training is True.</li>
</ul>
<hr />
<h3 id="tf.nn.batch_normalizationx-mean-variance-offset-scale-variance_epsilon-namenone"><a name="//apple_ref/cpp/Function/batch_normalization" class="dashAnchor"></a><code id="batch_normalization">tf.nn.batch_normalization(x, mean, variance, offset, scale, variance_epsilon, name=None)</code></h3>
<p>Batch normalization.</p>
<p>As described in http://arxiv.org/abs/1502.03167. Normalizes a tensor by <code>mean</code> and <code>variance</code>, and applies (optionally) a <code>scale</code> \(\) to it, as well as an <code>offset</code> \(\):</p>
<p>\(+\)</p>
<p><code>mean</code>, <code>variance</code>, <code>offset</code> and <code>scale</code> are all expected to be of one of two shapes:</p>
<ul>
<li>In all generality, they can have the same number of dimensions as the input <code>x</code>, with identical sizes as <code>x</code> for the dimensions that are not normalized over (the 'depth' dimension(s)), and dimension 1 for the others which are being normalized over. <code>mean</code> and <code>variance</code> in this case would typically be the outputs of <code>tf.nn.moments(..., keep_dims=True)</code> during training, or running averages thereof during inference.</li>
<li>In the common case where the 'depth' dimension is the last dimension in the input tensor <code>x</code>, they may be one dimensional tensors of the same size as the 'depth' dimension. This is the case for example for the common <code>[batch, depth]</code> layout of fully-connected layers, and <code>[batch, height, width, depth]</code> for convolutions. <code>mean</code> and <code>variance</code> in this case would typically be the outputs of <code>tf.nn.moments(..., keep_dims=False)</code> during training, or running averages thereof during inference.</li>
</ul>
<h5 id="args-44">Args:</h5>
<ul>
<li><b><code>x</code></b>: Input <code>Tensor</code> of arbitrary dimensionality.</li>
<li><b><code>mean</code></b>: A mean <code>Tensor</code>.</li>
<li><b><code>variance</code></b>: A variance <code>Tensor</code>.</li>
<li><b><code>offset</code></b>: An offset <code>Tensor</code>, often denoted \(\) in equations, or None. If present, will be added to the normalized tensor.</li>
<li><b><code>scale</code></b>: A scale <code>Tensor</code>, often denoted \(\) in equations, or <code>None</code>. If present, the scale is applied to the normalized tensor.</li>
<li><b><code>variance_epsilon</code></b>: A small float number to avoid dividing by 0.</li>
<li><b><code>name</code></b>: A name for this operation (optional).</li>
</ul>
<h5 id="returns-44">Returns:</h5>
<p>the normalized, scaled, offset tensor.</p>
<hr />
<h3 id="tf.nn.batch_norm_with_global_normalizationt-m-v-beta-gamma-variance_epsilon-scale_after_normalization-namenone"><a name="//apple_ref/cpp/Function/batch_norm_with_global_normalization" class="dashAnchor"></a><code id="batch_norm_with_global_normalization">tf.nn.batch_norm_with_global_normalization(t, m, v, beta, gamma, variance_epsilon, scale_after_normalization, name=None)</code></h3>
<p>Batch normalization.</p>
<p>This op is deprecated. See <code>tf.nn.batch_normalization</code>.</p>
<h5 id="args-45">Args:</h5>
<ul>
<li><b><code>t</code></b>: A 4D input Tensor.</li>
<li><b><code>m</code></b>: A 1D mean Tensor with size matching the last dimension of t. This is the first output from tf.nn.moments, or a saved moving average thereof.</li>
<li><b><code>v</code></b>: A 1D variance Tensor with size matching the last dimension of t. This is the second output from tf.nn.moments, or a saved moving average thereof.</li>
<li><b><code>beta</code></b>: A 1D beta Tensor with size matching the last dimension of t. An offset to be added to the normalized tensor.</li>
<li><b><code>gamma</code></b>: A 1D gamma Tensor with size matching the last dimension of t. If &quot;scale_after_normalization&quot; is true, this tensor will be multiplied with the normalized tensor.</li>
<li><b><code>variance_epsilon</code></b>: A small float number to avoid dividing by 0.</li>
<li><b><code>scale_after_normalization</code></b>: A bool indicating whether the resulted tensor needs to be multiplied with gamma.</li>
<li><b><code>name</code></b>: A name for this operation (optional).</li>
</ul>
<h5 id="returns-45">Returns:</h5>
<p>A batch-normalized <code>t</code>.</p>
<h2 id="losses">Losses</h2>
<p>The loss ops measure error between two tensors, or between a tensor and zero. These can be used for measuring accuracy of a network in a regression task or for regularization purposes (weight decay).</p>
<hr />
<h3 id="tf.nn.l2_losst-namenone"><a name="//apple_ref/cpp/Function/l2_loss" class="dashAnchor"></a><code id="l2_loss">tf.nn.l2_loss(t, name=None)</code></h3>
<p>L2 Loss.</p>
<p>Computes half the L2 norm of a tensor without the <code>sqrt</code>:</p>
<pre><code>output = sum(t ** 2) / 2</code></pre>
<h5 id="args-46">Args:</h5>
<ul>
<li><b><code>t</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>, <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>, <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>. Typically 2-D, but may have any dimensions.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-46">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>t</code>. 0-D.</p>
<hr />
<h3 id="tf.nn.log_poisson_losstargets-log_input-compute_full_lossfalse-namenone"><a name="//apple_ref/cpp/Function/log_poisson_loss" class="dashAnchor"></a><code id="log_poisson_loss">tf.nn.log_poisson_loss(targets, log_input, compute_full_loss=False, name=None)</code></h3>
<p>Computes log Poisson loss given <code>log_input</code>.</p>
<p>Gives the log-likelihood loss between the prediction and the target under the assumption that the target has a Poisson distribution. Caveat: By default, this is not the exact loss, but the loss minus a constant term [log(z!)]. That has no effect for optimization, but does not play well with relative loss comparisons. To compute an approximation of the log factorial term, specify compute_full_loss=True to enable Stirling's Approximation.</p>
<p>For brevity, let <code>c = log(x) = log_input</code>, <code>z = targets</code>. The log Poisson loss is</p>
<pre><code>  -log(exp(-x) * (x^z) / z!)
= -log(exp(-x) * (x^z)) + log(z!)
~ -log(exp(-x)) - log(x^z) [+ z * log(z) - z + 0.5 * log(2 * pi * z)]
    [ Note the second term is the Stirling&#39;s Approximation for log(z!).
      It is invariant to x and does not affect optimization, though
      important for correct relative loss comparisons. It is only
      computed when compute_full_loss == True. ]
= x - z * log(x) [+ z * log(z) - z + 0.5 * log(2 * pi * z)]
= exp(c) - z * c [+ z * log(z) - z + 0.5 * log(2 * pi * z)]</code></pre>
<h5 id="args-47">Args:</h5>
<ul>
<li><b><code>targets</code></b>: A <code>Tensor</code> of the same type and shape as <code>log_input</code>.</li>
<li><b><code>log_input</code></b>: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.</li>
<li><b><code>compute_full_loss</code></b>: whether to compute the full loss. If false, a constant term is dropped in favor of more efficient optimization.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-47">Returns:</h5>
<p>A <code>Tensor</code> of the same shape as <code>log_input</code> with the componentwise logistic losses.</p>
<h5 id="raises-12">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If <code>log_input</code> and <code>targets</code> do not have the same shape.</li>
</ul>
<h2 id="classification">Classification</h2>
<p>TensorFlow provides several operations that help you perform classification.</p>
<hr />
<h3 id="tf.nn.sigmoid_cross_entropy_with_logits_sentinelnone-labelsnone-logitsnone-namenone"><a name="//apple_ref/cpp/Function/sigmoid_cross_entropy_with_logits" class="dashAnchor"></a><code id="sigmoid_cross_entropy_with_logits">tf.nn.sigmoid_cross_entropy_with_logits(_sentinel=None, labels=None, logits=None, name=None)</code></h3>
<p>Computes sigmoid cross entropy given <code>logits</code>.</p>
<p>Measures the probability error in discrete classification tasks in which each class is independent and not mutually exclusive. For instance, one could perform multilabel classification where a picture can contain both an elephant and a dog at the same time.</p>
<p>For brevity, let <code>x = logits</code>, <code>z = labels</code>. The logistic loss is</p>
<pre><code>  z * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))
= z * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))
= z * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))
= z * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))
= (1 - z) * x + log(1 + exp(-x))
= x - x * z + log(1 + exp(-x))</code></pre>
<p>For x &lt; 0, to avoid overflow in exp(-x), we reformulate the above</p>
<pre><code>  x - x * z + log(1 + exp(-x))
= log(exp(x)) - x * z + log(1 + exp(-x))
= - x * z + log(1 + exp(x))</code></pre>
<p>Hence, to ensure stability and avoid overflow, the implementation uses this equivalent formulation</p>
<pre><code>max(x, 0) - x * z + log(1 + exp(-abs(x)))</code></pre>
<p><code>logits</code> and <code>labels</code> must have the same type and shape.</p>
<h5 id="args-48">Args:</h5>
<p>_sentinel: Used to prevent positional parameters. Internal, do not use.</p>
<ul>
<li><b><code>labels</code></b>: A <code>Tensor</code> of the same type and shape as <code>logits</code>.</li>
<li><b><code>logits</code></b>: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-48">Returns:</h5>
<p>A <code>Tensor</code> of the same shape as <code>logits</code> with the componentwise logistic losses.</p>
<h5 id="raises-13">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If <code>logits</code> and <code>labels</code> do not have the same shape.</li>
</ul>
<hr />
<h3 id="tf.nn.softmaxlogits-dim-1-namenone"><a name="//apple_ref/cpp/Function/softmax" class="dashAnchor"></a><code id="softmax">tf.nn.softmax(logits, dim=-1, name=None)</code></h3>
<p>Computes softmax activations.</p>
<p>For each batch <code>i</code> and class <code>j</code> we have</p>
<pre><code>softmax = exp(logits) / reduce_sum(exp(logits), dim)</code></pre>
<h5 id="args-49">Args:</h5>
<ul>
<li><b><code>logits</code></b>: A non-empty <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.</li>
<li><b><code>dim</code></b>: The dimension softmax would be performed on. The default is -1 which indicates the last dimension.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-49">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>logits</code>. Same shape as <code>logits</code>.</p>
<h5 id="raises-14">Raises:</h5>
<ul>
<li><b><code>InvalidArgumentError</code></b>: if <code>logits</code> is empty or <code>dim</code> is beyond the last dimension of <code>logits</code>.</li>
</ul>
<hr />
<h3 id="tf.nn.log_softmaxlogits-dim-1-namenone"><a name="//apple_ref/cpp/Function/log_softmax" class="dashAnchor"></a><code id="log_softmax">tf.nn.log_softmax(logits, dim=-1, name=None)</code></h3>
<p>Computes log softmax activations.</p>
<p>For each batch <code>i</code> and class <code>j</code> we have</p>
<pre><code>logsoftmax = logits - log(reduce_sum(exp(logits), dim))</code></pre>
<h5 id="args-50">Args:</h5>
<ul>
<li><b><code>logits</code></b>: A non-empty <code>Tensor</code>. Must be one of the following types: <code>half</code>, <code>float32</code>, <code>float64</code>.</li>
<li><b><code>dim</code></b>: The dimension softmax would be performed on. The default is -1 which indicates the last dimension.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-50">Returns:</h5>
<p>A <code>Tensor</code>. Has the same type as <code>logits</code>. Same shape as <code>logits</code>.</p>
<h5 id="raises-15">Raises:</h5>
<ul>
<li><b><code>InvalidArgumentError</code></b>: if <code>logits</code> is empty or <code>dim</code> is beyond the last dimension of <code>logits</code>.</li>
</ul>
<hr />
<h3 id="tf.nn.softmax_cross_entropy_with_logits_sentinelnone-labelsnone-logitsnone-dim-1-namenone"><a name="//apple_ref/cpp/Function/softmax_cross_entropy_with_logits" class="dashAnchor"></a><code id="softmax_cross_entropy_with_logits">tf.nn.softmax_cross_entropy_with_logits(_sentinel=None, labels=None, logits=None, dim=-1, name=None)</code></h3>
<p>Computes softmax cross entropy between <code>logits</code> and <code>labels</code>.</p>
<p>Measures the probability error in discrete classification tasks in which the classes are mutually exclusive (each entry is in exactly one class). For example, each CIFAR-10 image is labeled with one and only one label: an image can be a dog or a truck, but not both.</p>
<p><strong>NOTE:</strong> While the classes are mutually exclusive, their probabilities need not be. All that is required is that each row of <code>labels</code> is a valid probability distribution. If they are not, the computation of the gradient will be incorrect.</p>
<p>If using exclusive <code>labels</code> (wherein one and only one class is true at a time), see <code>sparse_softmax_cross_entropy_with_logits</code>.</p>
<p><strong>WARNING:</strong> This op expects unscaled logits, since it performs a <code>softmax</code> on <code>logits</code> internally for efficiency. Do not call this op with the output of <code>softmax</code>, as it will produce incorrect results.</p>
<p><code>logits</code> and <code>labels</code> must have the same shape <code>[batch_size, num_classes]</code> and the same dtype (either <code>float16</code>, <code>float32</code>, or <code>float64</code>).</p>
<p><strong>Note that to avoid confusion, it is required to pass only named arguments to this function.</strong></p>
<h5 id="args-51">Args:</h5>
<p>_sentinel: Used to prevent positional parameters. Internal, do not use.</p>
<ul>
<li><b><code>labels</code></b>: Each row <code>labels[i]</code> must be a valid probability distribution.</li>
<li><b><code>logits</code></b>: Unscaled log probabilities.</li>
<li><b><code>dim</code></b>: The class dimension. Defaulted to -1 which is the last dimension.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-51">Returns:</h5>
<p>A 1-D <code>Tensor</code> of length <code>batch_size</code> of the same type as <code>logits</code> with the softmax cross entropy loss.</p>
<hr />
<h3 id="tf.nn.sparse_softmax_cross_entropy_with_logits_sentinelnone-labelsnone-logitsnone-namenone"><a name="//apple_ref/cpp/Function/sparse_softmax_cross_entropy_with_logits" class="dashAnchor"></a><code id="sparse_softmax_cross_entropy_with_logits">tf.nn.sparse_softmax_cross_entropy_with_logits(_sentinel=None, labels=None, logits=None, name=None)</code></h3>
<p>Computes sparse softmax cross entropy between <code>logits</code> and <code>labels</code>.</p>
<p>Measures the probability error in discrete classification tasks in which the classes are mutually exclusive (each entry is in exactly one class). For example, each CIFAR-10 image is labeled with one and only one label: an image can be a dog or a truck, but not both.</p>
<p><strong>NOTE:</strong> For this operation, the probability of a given label is considered exclusive. That is, soft classes are not allowed, and the <code>labels</code> vector must provide a single specific index for the true class for each row of <code>logits</code> (each minibatch entry). For soft softmax classification with a probability distribution for each entry, see <code>softmax_cross_entropy_with_logits</code>.</p>
<p><strong>WARNING:</strong> This op expects unscaled logits, since it performs a softmax on <code>logits</code> internally for efficiency. Do not call this op with the output of <code>softmax</code>, as it will produce incorrect results.</p>
<p>A common use case is to have logits of shape <code>[batch_size, num_classes]</code> and labels of shape <code>[batch_size]</code>. But higher dimensions are supported.</p>
<p><strong>Note that to avoid confusion, it is required to pass only named arguments to this function.</strong></p>
<h5 id="args-52">Args:</h5>
<p>_sentinel: Used to prevent positional parameters. Internal, do not use.</p>
<ul>
<li><b><code>labels</code></b>: <code>Tensor</code> of shape <code>[d_0, d_1, ..., d_{r-1}]</code> (where <code>r</code> is rank of <code>labels</code> and result) and dtype <code>int32</code> or <code>int64</code>. Each entry in <code>labels</code> must be an index in <code>[0, num_classes)</code>. Other values will raise an exception when this op is run on CPU, and return <code>NaN</code> for corresponding loss and gradient rows on GPU.</li>
<li><b><code>logits</code></b>: Unscaled log probabilities of shape <code>[d_0, d_1, ..., d_{r-1}, num_classes]</code> and dtype <code>float32</code> or <code>float64</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-52">Returns:</h5>
<p>A <code>Tensor</code> of the same shape as <code>labels</code> and of the same type as <code>logits</code> with the softmax cross entropy loss.</p>
<h5 id="raises-16">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If logits are scalars (need to have rank &gt;= 1) or if the rank of the labels is not equal to the rank of the labels minus one.</li>
</ul>
<hr />
<h3 id="tf.nn.weighted_cross_entropy_with_logitstargets-logits-pos_weight-namenone"><a name="//apple_ref/cpp/Function/weighted_cross_entropy_with_logits" class="dashAnchor"></a><code id="weighted_cross_entropy_with_logits">tf.nn.weighted_cross_entropy_with_logits(targets, logits, pos_weight, name=None)</code></h3>
<p>Computes a weighted cross entropy.</p>
<p>This is like <code>sigmoid_cross_entropy_with_logits()</code> except that <code>pos_weight</code>, allows one to trade off recall and precision by up- or down-weighting the cost of a positive error relative to a negative error.</p>
<p>The usual cross-entropy cost is defined as:</p>
<p>targets * -log(sigmoid(logits)) + (1 - targets) * -log(1 - sigmoid(logits))</p>
<p>The argument <code>pos_weight</code> is used as a multiplier for the positive targets:</p>
<p>targets * -log(sigmoid(logits)) * pos_weight + (1 - targets) * -log(1 - sigmoid(logits))</p>
<p>For brevity, let <code>x = logits</code>, <code>z = targets</code>, <code>q = pos_weight</code>. The loss is:</p>
<pre><code>  qz * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))
= qz * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))
= qz * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))
= qz * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))
= (1 - z) * x + (qz +  1 - z) * log(1 + exp(-x))
= (1 - z) * x + (1 + (q - 1) * z) * log(1 + exp(-x))</code></pre>
<p>Setting <code>l = (1 + (q - 1) * z)</code>, to ensure stability and avoid overflow, the implementation uses</p>
<pre><code>(1 - z) * x + l * (log(1 + exp(-abs(x))) + max(-x, 0))</code></pre>
<p><code>logits</code> and <code>targets</code> must have the same type and shape.</p>
<h5 id="args-53">Args:</h5>
<ul>
<li><b><code>targets</code></b>: A <code>Tensor</code> of the same type and shape as <code>logits</code>.</li>
<li><b><code>logits</code></b>: A <code>Tensor</code> of type <code>float32</code> or <code>float64</code>.</li>
<li><b><code>pos_weight</code></b>: A coefficient to use on the positive examples.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-53">Returns:</h5>
<p>A <code>Tensor</code> of the same shape as <code>logits</code> with the componentwise weighted logistic losses.</p>
<h5 id="raises-17">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If <code>logits</code> and <code>targets</code> do not have the same shape.</li>
</ul>
<h2 id="embeddings">Embeddings</h2>
<p>TensorFlow provides library support for looking up values in embedding tensors.</p>
<hr />
<h3 id="tf.nn.embedding_lookupparams-ids-partition_strategymod-namenone-validate_indicestrue-max_normnone"><a name="//apple_ref/cpp/Function/embedding_lookup" class="dashAnchor"></a><code id="embedding_lookup">tf.nn.embedding_lookup(params, ids, partition_strategy='mod', name=None, validate_indices=True, max_norm=None)</code></h3>
<p>Looks up <code>ids</code> in a list of embedding tensors.</p>
<p>This function is used to perform parallel lookups on the list of tensors in <code>params</code>. It is a generalization of <a href="../../api_docs/python/array_ops.md#gather"><code>tf.gather()</code></a>, where <code>params</code> is interpreted as a partitioning of a large embedding tensor. <code>params</code> may be a <code>PartitionedVariable</code> as returned by using <code>tf.get_variable()</code> with a partitioner.</p>
<p>If <code>len(params) &gt; 1</code>, each element <code>id</code> of <code>ids</code> is partitioned between the elements of <code>params</code> according to the <code>partition_strategy</code>. In all strategies, if the id space does not evenly divide the number of partitions, each of the first <code>(max_id + 1) % len(params)</code> partitions will be assigned one more id.</p>
<p>If <code>partition_strategy</code> is <code>&quot;mod&quot;</code>, we assign each id to partition <code>p = id % len(params)</code>. For instance, 13 ids are split across 5 partitions as: <code>[[0, 5, 10], [1, 6, 11], [2, 7, 12], [3, 8], [4, 9]]</code></p>
<p>If <code>partition_strategy</code> is <code>&quot;div&quot;</code>, we assign ids to partitions in a contiguous manner. In this case, 13 ids are split across 5 partitions as: <code>[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]</code></p>
<p>The results of the lookup are concatenated into a dense tensor. The returned tensor has shape <code>shape(ids) + shape(params)[1:]</code>.</p>
<h5 id="args-54">Args:</h5>
<ul>
<li><b><code>params</code></b>: A single tensor representing the complete embedding tensor, or a list of P tensors all of same shape except for the first dimension, representing sharded embedding tensors. Alternatively, a <code>PartitionedVariable</code>, created by partitioning along dimension 0. Each element must be appropriately sized for the given <code>partition_strategy</code>.</li>
<li><b><code>ids</code></b>: A <code>Tensor</code> with type <code>int32</code> or <code>int64</code> containing the ids to be looked up in <code>params</code>.</li>
<li><b><code>partition_strategy</code></b>: A string specifying the partitioning strategy, relevant if <code>len(params) &gt; 1</code>. Currently <code>&quot;div&quot;</code> and <code>&quot;mod&quot;</code> are supported. Default is <code>&quot;mod&quot;</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
<li><b><code>validate_indices</code></b>: Whether or not to validate gather indices.</li>
<li><b><code>max_norm</code></b>: If not None, embedding values are l2-normalized to the value of max_norm.</li>
</ul>
<h5 id="returns-54">Returns:</h5>
<p>A <code>Tensor</code> with the same type as the tensors in <code>params</code>.</p>
<h5 id="raises-18">Raises:</h5>
<ul>
<li><b><code>ValueError</code></b>: If <code>params</code> is empty.</li>
</ul>
<hr />
<h3 id="tf.nn.embedding_lookup_sparseparams-sp_ids-sp_weights-partition_strategymod-namenone-combinernone-max_normnone"><a name="//apple_ref/cpp/Function/embedding_lookup_sparse" class="dashAnchor"></a><code id="embedding_lookup_sparse">tf.nn.embedding_lookup_sparse(params, sp_ids, sp_weights, partition_strategy='mod', name=None, combiner=None, max_norm=None)</code></h3>
<p>Computes embeddings for the given ids and weights.</p>
<p>This op assumes that there is at least one id for each row in the dense tensor represented by sp_ids (i.e. there are no rows with empty features), and that all the indices of sp_ids are in canonical row-major order.</p>
<p>It also assumes that all id values lie in the range [0, p0), where p0 is the sum of the size of params along dimension 0.</p>
<h5 id="args-55">Args:</h5>
<ul>
<li><b><code>params</code></b>: A single tensor representing the complete embedding tensor, or a list of P tensors all of same shape except for the first dimension, representing sharded embedding tensors. Alternatively, a <code>PartitionedVariable</code>, created by partitioning along dimension 0. Each element must be appropriately sized for the given <code>partition_strategy</code>.</li>
<li><b><code>sp_ids</code></b>: N x M SparseTensor of int64 ids (typically from FeatureValueToId), where N is typically batch size and M is arbitrary.</li>
<li><b><code>sp_weights</code></b>: either a SparseTensor of float / double weights, or None to indicate all weights should be taken to be 1. If specified, sp_weights must have exactly the same shape and indices as sp_ids.</li>
<li><b><code>partition_strategy</code></b>: A string specifying the partitioning strategy, relevant if <code>len(params) &gt; 1</code>. Currently <code>&quot;div&quot;</code> and <code>&quot;mod&quot;</code> are supported. Default is <code>&quot;mod&quot;</code>. See <code>tf.nn.embedding_lookup</code> for more details.</li>
<li><b><code>name</code></b>: Optional name for the op.</li>
<li><b><code>combiner</code></b>: A string specifying the reduction op. Currently &quot;mean&quot;, &quot;sqrtn&quot; and &quot;sum&quot; are supported. &quot;sum&quot; computes the weighted sum of the embedding results for each row. &quot;mean&quot; is the weighted sum divided by the total weight. &quot;sqrtn&quot; is the weighted sum divided by the square root of the sum of the squares of the weights.</li>
<li><b><code>max_norm</code></b>: If not None, each embedding is normalized to have l2 norm equal to max_norm before combining.</li>
</ul>
<h5 id="returns-55">Returns:</h5>
<p>A dense tensor representing the combined embeddings for the sparse ids. For each row in the dense tensor represented by sp_ids, the op looks up the embeddings for all ids in that row, multiplies them by the corresponding weight, and combines these embeddings as specified.</p>
<p>In other words, if</p>
<pre><code>shape(combined params) = [p0, p1, ..., pm]</code></pre>
<p>and</p>
<pre><code>shape(sp_ids) = shape(sp_weights) = [d0, d1, ..., dn]</code></pre>
<p>then</p>
<pre><code>shape(output) = [d0, d1, ..., dn-1, p1, ..., pm].</code></pre>
<p>For instance, if params is a 10x20 matrix, and sp_ids / sp_weights are</p>
<pre><code>[0, 0]: id 1, weight 2.0
[0, 1]: id 3, weight 0.5
[1, 0]: id 0, weight 1.0
[2, 3]: id 1, weight 3.0</code></pre>
<p>with <code>combiner</code>=&quot;mean&quot;, then the output will be a 3x20 matrix where</p>
<pre><code>output[0, :] = (params[1, :] * 2.0 + params[3, :] * 0.5) / (2.0 + 0.5)
output[1, :] = params[0, :] * 1.0
output[2, :] = params[1, :] * 3.0</code></pre>
<h5 id="raises-19">Raises:</h5>
<ul>
<li><b><code>TypeError</code></b>: If sp_ids is not a SparseTensor, or if sp_weights is neither None nor SparseTensor.</li>
<li><b><code>ValueError</code></b>: If combiner is not one of {&quot;mean&quot;, &quot;sqrtn&quot;, &quot;sum&quot;}.</li>
</ul>
<h2 id="recurrent-neural-networks">Recurrent Neural Networks</h2>
<p>TensorFlow provides a number of methods for constructing Recurrent Neural Networks. Most accept an <code>RNNCell</code>-subclassed object (see the documentation for <code>tf.contrib.rnn</code>).</p>
<hr />
<h3 id="tf.nn.dynamic_rnncell-inputs-sequence_lengthnone-initial_statenone-dtypenone-parallel_iterationsnone-swap_memoryfalse-time_majorfalse-scopenone"><a name="//apple_ref/cpp/Function/dynamic_rnn" class="dashAnchor"></a><code id="dynamic_rnn">tf.nn.dynamic_rnn(cell, inputs, sequence_length=None, initial_state=None, dtype=None, parallel_iterations=None, swap_memory=False, time_major=False, scope=None)</code></h3>
<p>Creates a recurrent neural network specified by RNNCell <code>cell</code>.</p>
<p>This function is functionally identical to the function <code>rnn</code> above, but performs fully dynamic unrolling of <code>inputs</code>.</p>
<p>Unlike <code>rnn</code>, the input <code>inputs</code> is not a Python list of <code>Tensors</code>, one for each frame. Instead, <code>inputs</code> may be a single <code>Tensor</code> where the maximum time is either the first or second dimension (see the parameter <code>time_major</code>). Alternatively, it may be a (possibly nested) tuple of Tensors, each of them having matching batch and time dimensions. The corresponding output is either a single <code>Tensor</code> having the same number of time steps and batch size, or a (possibly nested) tuple of such tensors, matching the nested structure of <code>cell.output_size</code>.</p>
<p>The parameter <code>sequence_length</code> is optional and is used to copy-through state and zero-out outputs when past a batch element's sequence length. So it's more for correctness than performance, unlike in rnn().</p>
<h5 id="args-56">Args:</h5>
<ul>
<li><b><code>cell</code></b>: An instance of RNNCell.</li>
<li><p><b><code>inputs</code></b>: The RNN inputs.</p>
<p>If <code>time_major == False</code> (default), this must be a <code>Tensor</code> of shape: <code>[batch_size, max_time, ...]</code>, or a nested tuple of such elements.</p>
<p>If <code>time_major == True</code>, this must be a <code>Tensor</code> of shape: <code>[max_time, batch_size, ...]</code>, or a nested tuple of such elements.</p>
<p>This may also be a (possibly nested) tuple of Tensors satisfying this property. The first two dimensions must match across all the inputs, but otherwise the ranks and other shape components may differ. In this case, input to <code>cell</code> at each time-step will replicate the structure of these tuples, except for the time dimension (from which the time is taken).</p>
<p>The input to <code>cell</code> at each time step will be a <code>Tensor</code> or (possibly nested) tuple of Tensors each with dimensions <code>[batch_size, ...]</code>.</p></li>
<li><b><code>sequence_length</code></b>: (optional) An int32/int64 vector sized <code>[batch_size]</code>.</li>
<li><b><code>initial_state</code></b>: (optional) An initial state for the RNN. If <code>cell.state_size</code> is an integer, this must be a <code>Tensor</code> of appropriate type and shape <code>[batch_size, cell.state_size]</code>. If <code>cell.state_size</code> is a tuple, this should be a tuple of tensors having shapes <code>[batch_size, s] for s in cell.state_size</code>.</li>
<li><b><code>dtype</code></b>: (optional) The data type for the initial state and expected output. Required if initial_state is not provided or RNN state has a heterogeneous dtype.</li>
<li><b><code>parallel_iterations</code></b>: (Default: 32). The number of iterations to run in parallel. Those operations which do not have any temporal dependency and can be run in parallel, will be. This parameter trades off time for space. Values &gt;&gt; 1 use more memory but take less time, while smaller values use less memory but computations take longer.</li>
<li><b><code>swap_memory</code></b>: Transparently swap the tensors produced in forward inference but needed for back prop from GPU to CPU. This allows training RNNs which would typically not fit on a single GPU, with very minimal (or no) performance penalty.</li>
<li><b><code>time_major</code></b>: The shape format of the <code>inputs</code> and <code>outputs</code> Tensors. If true, these <code>Tensors</code> must be shaped <code>[max_time, batch_size, depth]</code>. If false, these <code>Tensors</code> must be shaped <code>[batch_size, max_time, depth]</code>. Using <code>time_major = True</code> is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation. However, most TensorFlow data is batch-major, so by default this function accepts input and emits output in batch-major form.</li>
<li><p><b><code>scope</code></b>: VariableScope for the created subgraph; defaults to &quot;rnn&quot;.</p></li>
</ul>
<h5 id="returns-56">Returns:</h5>
<p>A pair (outputs, state) where:</p>
<ul>
<li><p><b><code>outputs</code></b>: The RNN output <code>Tensor</code>.</p>
<p>If time_major == False (default), this will be a <code>Tensor</code> shaped: <code>[batch_size, max_time, cell.output_size]</code>.</p>
<p>If time_major == True, this will be a <code>Tensor</code> shaped: <code>[max_time, batch_size, cell.output_size]</code>.</p>
<p>Note, if <code>cell.output_size</code> is a (possibly nested) tuple of integers or <code>TensorShape</code> objects, then <code>outputs</code> will be a tuple having the same structure as <code>cell.output_size</code>, containing Tensors having shapes corresponding to the shape data in <code>cell.output_size</code>.</p></li>
<li><p><b><code>state</code></b>: The final state. If <code>cell.state_size</code> is an int, this will be shaped <code>[batch_size, cell.state_size]</code>. If it is a <code>TensorShape</code>, this will be shaped <code>[batch_size] + cell.state_size</code>. If it is a (possibly nested) tuple of ints or <code>TensorShape</code>, this will be a tuple having the corresponding shapes.</p></li>
</ul>
<h5 id="raises-20">Raises:</h5>
<ul>
<li><b><code>TypeError</code></b>: If <code>cell</code> is not an instance of RNNCell.</li>
<li><b><code>ValueError</code></b>: If inputs is None or an empty list.</li>
</ul>
<hr />
<h3 id="tf.nn.bidirectional_dynamic_rnncell_fw-cell_bw-inputs-sequence_lengthnone-initial_state_fwnone-initial_state_bwnone-dtypenone-parallel_iterationsnone-swap_memoryfalse-time_majorfalse-scopenone"><a name="//apple_ref/cpp/Function/bidirectional_dynamic_rnn" class="dashAnchor"></a><code id="bidirectional_dynamic_rnn">tf.nn.bidirectional_dynamic_rnn(cell_fw, cell_bw, inputs, sequence_length=None, initial_state_fw=None, initial_state_bw=None, dtype=None, parallel_iterations=None, swap_memory=False, time_major=False, scope=None)</code></h3>
<p>Creates a dynamic version of bidirectional recurrent neural network.</p>
<p>Similar to the unidirectional case above (rnn) but takes input and builds independent forward and backward RNNs. The input_size of forward and backward cell must match. The initial state for both directions is zero by default (but can be set optionally) and no intermediate states are ever returned -- the network is fully unrolled for the given (passed in) length(s) of the sequence(s) or completely unrolled if length(s) is not given.</p>
<h5 id="args-57">Args:</h5>
<ul>
<li><b><code>cell_fw</code></b>: An instance of RNNCell, to be used for forward direction.</li>
<li><b><code>cell_bw</code></b>: An instance of RNNCell, to be used for backward direction.</li>
<li><b><code>inputs</code></b>: The RNN inputs. If time_major == False (default), this must be a tensor of shape: <code>[batch_size, max_time, input_size]</code>. If time_major == True, this must be a tensor of shape: <code>[max_time, batch_size, input_size]</code>. [batch_size, input_size].</li>
<li><b><code>sequence_length</code></b>: An int32/int64 vector, size <code>[batch_size]</code>, containing the actual lengths for each of the sequences.</li>
<li><b><code>initial_state_fw</code></b>: (optional) An initial state for the forward RNN. This must be a tensor of appropriate type and shape <code>[batch_size, cell_fw.state_size]</code>. If <code>cell_fw.state_size</code> is a tuple, this should be a tuple of tensors having shapes <code>[batch_size, s] for s in cell_fw.state_size</code>.</li>
<li><b><code>initial_state_bw</code></b>: (optional) Same as for <code>initial_state_fw</code>, but using the corresponding properties of <code>cell_bw</code>.</li>
<li><b><code>dtype</code></b>: (optional) The data type for the initial states and expected output. Required if initial_states are not provided or RNN states have a heterogeneous dtype.</li>
<li><b><code>parallel_iterations</code></b>: (Default: 32). The number of iterations to run in parallel. Those operations which do not have any temporal dependency and can be run in parallel, will be. This parameter trades off time for space. Values &gt;&gt; 1 use more memory but take less time, while smaller values use less memory but computations take longer.</li>
<li><b><code>swap_memory</code></b>: Transparently swap the tensors produced in forward inference but needed for back prop from GPU to CPU. This allows training RNNs which would typically not fit on a single GPU, with very minimal (or no) performance penalty.</li>
<li><b><code>time_major</code></b>: The shape format of the <code>inputs</code> and <code>outputs</code> Tensors. If true, these <code>Tensors</code> must be shaped <code>[max_time, batch_size, depth]</code>. If false, these <code>Tensors</code> must be shaped <code>[batch_size, max_time, depth]</code>. Using <code>time_major = True</code> is a bit more efficient because it avoids transposes at the beginning and end of the RNN calculation. However, most TensorFlow data is batch-major, so by default this function accepts input and emits output in batch-major form.</li>
<li><b><code>dtype</code></b>: (optional) The data type for the initial state. Required if either of the initial states are not provided.</li>
<li><b><code>scope</code></b>: VariableScope for the created subgraph; defaults to &quot;bidirectional_rnn&quot;</li>
</ul>
<h5 id="returns-57">Returns:</h5>
<p>A tuple (outputs, output_states) where:</p>
<ul>
<li><b><code>outputs</code></b>: A tuple (output_fw, output_bw) containing the forward and the backward rnn output <code>Tensor</code>. If time_major == False (default), output_fw will be a <code>Tensor</code> shaped: <code>[batch_size, max_time, cell_fw.output_size]</code> and output_bw will be a <code>Tensor</code> shaped: <code>[batch_size, max_time, cell_bw.output_size]</code>. If time_major == True, output_fw will be a <code>Tensor</code> shaped: <code>[max_time, batch_size, cell_fw.output_size]</code> and output_bw will be a <code>Tensor</code> shaped: <code>[max_time, batch_size, cell_bw.output_size]</code>. It returns a tuple instead of a single concatenated <code>Tensor</code>, unlike in the <code>bidirectional_rnn</code>. If the concatenated one is preferred, the forward and backward outputs can be concatenated as <code>tf.concat(outputs, 2)</code>.</li>
<li><b><code>output_states</code></b>: A tuple (output_state_fw, output_state_bw) containing the forward and the backward final states of bidirectional rnn.</li>
</ul>
<h5 id="raises-21">Raises:</h5>
<ul>
<li><b><code>TypeError</code></b>: If <code>cell_fw</code> or <code>cell_bw</code> is not an instance of <code>RNNCell</code>.</li>
</ul>
<hr />
<h3 id="tf.nn.raw_rnncell-loop_fn-parallel_iterationsnone-swap_memoryfalse-scopenone"><a name="//apple_ref/cpp/Function/raw_rnn" class="dashAnchor"></a><code id="raw_rnn">tf.nn.raw_rnn(cell, loop_fn, parallel_iterations=None, swap_memory=False, scope=None)</code></h3>
<p>Creates an <code>RNN</code> specified by RNNCell <code>cell</code> and loop function <code>loop_fn</code>.</p>
<p><strong>NOTE: This method is still in testing, and the API may change.</strong></p>
<p>This function is a more primitive version of <code>dynamic_rnn</code> that provides more direct access to the inputs each iteration. It also provides more control over when to start and finish reading the sequence, and what to emit for the output.</p>
<p>For example, it can be used to implement the dynamic decoder of a seq2seq model.</p>
<p>Instead of working with <code>Tensor</code> objects, most operations work with <code>TensorArray</code> objects directly.</p>
<p>The operation of <code>raw_rnn</code>, in pseudo-code, is basically the following:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">time <span class="op">=</span> tf.constant(<span class="dv">0</span>, dtype<span class="op">=</span>tf.int32)
(finished, next_input, initial_state, _, loop_state) <span class="op">=</span> loop_fn(
    time<span class="op">=</span>time, cell_output<span class="op">=</span><span class="va">None</span>, cell_state<span class="op">=</span><span class="va">None</span>, loop_state<span class="op">=</span><span class="va">None</span>)
emit_ta <span class="op">=</span> TensorArray(dynamic_size<span class="op">=</span><span class="va">True</span>, dtype<span class="op">=</span>initial_state.dtype)
state <span class="op">=</span> initial_state
<span class="cf">while</span> <span class="op">not</span> <span class="bu">all</span>(finished):
  (output, cell_state) <span class="op">=</span> cell(next_input, state)
  (next_finished, next_input, next_state, emit, loop_state) <span class="op">=</span> loop_fn(
      time<span class="op">=</span>time <span class="op">+</span> <span class="dv">1</span>, cell_output<span class="op">=</span>output, cell_state<span class="op">=</span>cell_state,
      loop_state<span class="op">=</span>loop_state)
  <span class="co"># Emit zeros and copy forward state for minibatch entries that are finished.</span>
  state <span class="op">=</span> tf.where(finished, state, next_state)
  emit <span class="op">=</span> tf.where(finished, tf.zeros_like(emit), emit)
  emit_ta <span class="op">=</span> emit_ta.write(time, emit)
  <span class="co"># If any new minibatch entries are marked as finished, mark these.</span>
  finished <span class="op">=</span> tf.logical_or(finished, next_finished)
  time <span class="op">+=</span> <span class="dv">1</span>
<span class="cf">return</span> (emit_ta, state, loop_state)</code></pre></div>
<p>with the additional properties that output and state may be (possibly nested) tuples, as determined by <code>cell.output_size</code> and <code>cell.state_size</code>, and as a result the final <code>state</code> and <code>emit_ta</code> may themselves be tuples.</p>
<p>A simple implementation of <code>dynamic_rnn</code> via <code>raw_rnn</code> looks like this:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">inputs <span class="op">=</span> tf.placeholder(shape<span class="op">=</span>(max_time, batch_size, input_depth),
                        dtype<span class="op">=</span>tf.float32)
sequence_length <span class="op">=</span> tf.placeholder(shape<span class="op">=</span>(batch_size,), dtype<span class="op">=</span>tf.int32)
inputs_ta <span class="op">=</span> tf.TensorArray(dtype<span class="op">=</span>tf.float32, size<span class="op">=</span>max_time)
inputs_ta <span class="op">=</span> inputs_ta.unstack(inputs)

cell <span class="op">=</span> tf.contrib.rnn.LSTMCell(num_units)

<span class="kw">def</span> loop_fn(time, cell_output, cell_state, loop_state):
  emit_output <span class="op">=</span> cell_output  <span class="co"># == None for time == 0</span>
  <span class="cf">if</span> cell_output <span class="op">is</span> <span class="va">None</span>:  <span class="co"># time == 0</span>
    next_cell_state <span class="op">=</span> cell.zero_state(batch_size, tf.float32)
  <span class="cf">else</span>:
    next_cell_state <span class="op">=</span> cell_state
  elements_finished <span class="op">=</span> (time <span class="op">&gt;=</span> sequence_length)
  finished <span class="op">=</span> tf.reduce_all(elements_finished)
  next_input <span class="op">=</span> tf.cond(
      finished,
      <span class="kw">lambda</span>: tf.zeros([batch_size, input_depth], dtype<span class="op">=</span>tf.float32),
      <span class="kw">lambda</span>: inputs_ta.read(time))
  next_loop_state <span class="op">=</span> <span class="va">None</span>
  <span class="cf">return</span> (elements_finished, next_input, next_cell_state,
          emit_output, next_loop_state)

outputs_ta, final_state, _ <span class="op">=</span> raw_rnn(cell, loop_fn)
outputs <span class="op">=</span> outputs_ta.stack()</code></pre></div>
<h5 id="args-58">Args:</h5>
<ul>
<li><b><code>cell</code></b>: An instance of RNNCell.</li>
<li><p><b><code>loop_fn</code></b>: A callable that takes inputs <code>(time, cell_output, cell_state, loop_state)</code> and returns the tuple <code>(finished, next_input, next_cell_state, emit_output, next_loop_state)</code>. Here <code>time</code> is an int32 scalar <code>Tensor</code>, <code>cell_output</code> is a <code>Tensor</code> or (possibly nested) tuple of tensors as determined by <code>cell.output_size</code>, and <code>cell_state</code> is a <code>Tensor</code> or (possibly nested) tuple of tensors, as determined by the <code>loop_fn</code> on its first call (and should match <code>cell.state_size</code>). The outputs are: <code>finished</code>, a boolean <code>Tensor</code> of shape <code>[batch_size]</code>, <code>next_input</code>: the next input to feed to <code>cell</code>, <code>next_cell_state</code>: the next state to feed to <code>cell</code>, and <code>emit_output</code>: the output to store for this iteration.</p>
<p>Note that <code>emit_output</code> should be a <code>Tensor</code> or (possibly nested) tuple of tensors with shapes and structure matching <code>cell.output_size</code> and <code>cell_output</code> above. The parameter <code>cell_state</code> and output <code>next_cell_state</code> may be either a single or (possibly nested) tuple of tensors. The parameter <code>loop_state</code> and output <code>next_loop_state</code> may be either a single or (possibly nested) tuple of <code>Tensor</code> and <code>TensorArray</code> objects. This last parameter may be ignored by <code>loop_fn</code> and the return value may be <code>None</code>. If it is not <code>None</code>, then the <code>loop_state</code> will be propagated through the RNN loop, for use purely by <code>loop_fn</code> to keep track of its own state. The <code>next_loop_state</code> parameter returned may be <code>None</code>.</p>
<p>The first call to <code>loop_fn</code> will be <code>time = 0</code>, <code>cell_output = None</code>, <code>cell_state = None</code>, and <code>loop_state = None</code>. For this call: The <code>next_cell_state</code> value should be the value with which to initialize the cell's state. It may be a final state from a previous RNN or it may be the output of <code>cell.zero_state()</code>. It should be a (possibly nested) tuple structure of tensors. If <code>cell.state_size</code> is an integer, this must be a <code>Tensor</code> of appropriate type and shape <code>[batch_size, cell.state_size]</code>. If <code>cell.state_size</code> is a <code>TensorShape</code>, this must be a <code>Tensor</code> of appropriate type and shape <code>[batch_size] + cell.state_size</code>. If <code>cell.state_size</code> is a (possibly nested) tuple of ints or <code>TensorShape</code>, this will be a tuple having the corresponding shapes. The <code>emit_output</code> value may be either <code>None</code> or a (possibly nested) tuple structure of tensors, e.g., <code>(tf.zeros(shape_0, dtype=dtype_0), tf.zeros(shape_1, dtype=dtype_1))</code>. If this first <code>emit_output</code> return value is <code>None</code>, then the <code>emit_ta</code> result of <code>raw_rnn</code> will have the same structure and dtypes as <code>cell.output_size</code>. Otherwise <code>emit_ta</code> will have the same structure, shapes (prepended with a <code>batch_size</code> dimension), and dtypes as <code>emit_output</code>. The actual values returned for <code>emit_output</code> at this initializing call are ignored. Note, this emit structure must be consistent across all time steps.</p></li>
<li><b><code>parallel_iterations</code></b>: (Default: 32). The number of iterations to run in parallel. Those operations which do not have any temporal dependency and can be run in parallel, will be. This parameter trades off time for space. Values &gt;&gt; 1 use more memory but take less time, while smaller values use less memory but computations take longer.</li>
<li><b><code>swap_memory</code></b>: Transparently swap the tensors produced in forward inference but needed for back prop from GPU to CPU. This allows training RNNs which would typically not fit on a single GPU, with very minimal (or no) performance penalty.</li>
<li><p><b><code>scope</code></b>: VariableScope for the created subgraph; defaults to &quot;rnn&quot;.</p></li>
</ul>
<h5 id="returns-58">Returns:</h5>
<p>A tuple <code>(emit_ta, final_state, final_loop_state)</code> where:</p>
<p><code>emit_ta</code>: The RNN output <code>TensorArray</code>. If <code>loop_fn</code> returns a (possibly nested) set of Tensors for <code>emit_output</code> during initialization, (inputs <code>time = 0</code>, <code>cell_output = None</code>, and <code>loop_state = None</code>), then <code>emit_ta</code> will have the same structure, dtypes, and shapes as <code>emit_output</code> instead. If <code>loop_fn</code> returns <code>emit_output = None</code> during this call, the structure of <code>cell.output_size</code> is used: If <code>cell.output_size</code> is a (possibly nested) tuple of integers or <code>TensorShape</code> objects, then <code>emit_ta</code> will be a tuple having the same structure as <code>cell.output_size</code>, containing TensorArrays whose elements' shapes correspond to the shape data in <code>cell.output_size</code>.</p>
<p><code>final_state</code>: The final cell state. If <code>cell.state_size</code> is an int, this will be shaped <code>[batch_size, cell.state_size]</code>. If it is a <code>TensorShape</code>, this will be shaped <code>[batch_size] + cell.state_size</code>. If it is a (possibly nested) tuple of ints or <code>TensorShape</code>, this will be a tuple having the corresponding shapes.</p>
<p><code>final_loop_state</code>: The final loop state as returned by <code>loop_fn</code>.</p>
<h5 id="raises-22">Raises:</h5>
<ul>
<li><b><code>TypeError</code></b>: If <code>cell</code> is not an instance of RNNCell, or <code>loop_fn</code> is not a <code>callable</code>.</li>
</ul>
<h2 id="connectionist-temporal-classification-ctc">Connectionist Temporal Classification (CTC)</h2>
<hr />
<h3 id="tf.nn.ctc_losslabels-inputs-sequence_length-preprocess_collapse_repeatedfalse-ctc_merge_repeatedtrue-time_majortrue"><a name="//apple_ref/cpp/Function/ctc_loss" class="dashAnchor"></a><code id="ctc_loss">tf.nn.ctc_loss(labels, inputs, sequence_length, preprocess_collapse_repeated=False, ctc_merge_repeated=True, time_major=True)</code></h3>
<p>Computes the CTC (Connectionist Temporal Classification) Loss.</p>
<p>This op implements the CTC loss as presented in the article:</p>
<p>A. Graves, S. Fernandez, F. Gomez, J. Schmidhuber. Connectionist Temporal Classification: Labelling Unsegmented Sequence Data with Recurrent Neural Networks. ICML 2006, Pittsburgh, USA, pp. 369-376.</p>
<p>http://www.cs.toronto.edu/~graves/icml_2006.pdf</p>
<p>Input requirements:</p>
<pre><code>sequence_length(b) &lt;= time for all b

max(labels.indices(labels.indices[:, 1] == b, 2))
  &lt;= sequence_length(b) for all b.</code></pre>
<p>Notes:</p>
<p>This class performs the softmax operation for you, so inputs should be e.g. linear projections of outputs by an LSTM.</p>
<p>The <code>inputs</code> Tensor's innermost dimension size, <code>num_classes</code>, represents <code>num_labels + 1</code> classes, where num_labels is the number of true labels, and the largest value <code>(num_classes - 1)</code> is reserved for the blank label.</p>
<p>For example, for a vocabulary containing 3 labels <code>[a, b, c]</code>, <code>num_classes = 4</code> and the labels indexing is <code>{a: 0, b: 1, c: 2, blank: 3}</code>.</p>
<p>Regarding the arguments <code>preprocess_collapse_repeated</code> and <code>ctc_merge_repeated</code>:</p>
<p>If <code>preprocess_collapse_repeated</code> is True, then a preprocessing step runs before loss calculation, wherein repeated labels passed to the loss are merged into single labels. This is useful if the training labels come from, e.g., forced alignments and therefore have unnecessary repetitions.</p>
<p>If <code>ctc_merge_repeated</code> is set False, then deep within the CTC calculation, repeated non-blank labels will not be merged and are interpreted as individual labels. This is a simplified (non-standard) version of CTC.</p>
<p>Here is a table of the (roughly) expected first order behavior:</p>
<ul>
<li><code>preprocess_collapse_repeated=False</code>, <code>ctc_merge_repeated=True</code></li>
</ul>
<p>Classical CTC behavior: Outputs true repeated classes with blanks in between, and can also output repeated classes with no blanks in between that need to be collapsed by the decoder.</p>
<ul>
<li><code>preprocess_collapse_repeated=True</code>, <code>ctc_merge_repeated=False</code></li>
</ul>
<p>Never learns to output repeated classes, as they are collapsed in the input labels before training.</p>
<ul>
<li><code>preprocess_collapse_repeated=False</code>, <code>ctc_merge_repeated=False</code></li>
</ul>
<p>Outputs repeated classes with blanks in between, but generally does not require the decoder to collapse/merge repeated classes.</p>
<ul>
<li><code>preprocess_collapse_repeated=True</code>, <code>ctc_merge_repeated=True</code></li>
</ul>
<p>Untested. Very likely will not learn to output repeated classes.</p>
<h5 id="args-59">Args:</h5>
<ul>
<li><b><code>labels</code></b>: An <code>int32</code> <code>SparseTensor</code>. <code>labels.indices[i, :] == [b, t]</code> means <code>labels.values[i]</code> stores the id for (batch b, time t). <code>labels.values[i]</code> must take on values in <code>[0, num_labels)</code>. See <code>core/ops/ctc_ops.cc</code> for more details.</li>
<li><b><code>inputs</code></b>: 3-D <code>float</code> <code>Tensor</code>. If time_major == False, this will be a <code>Tensor</code> shaped: <code>[batch_size x max_time x num_classes]</code>. If time_major == True (default), this will be a <code>Tensor</code> shaped: <code>[max_time x batch_size x num_classes]</code>. The logits.</li>
<li><b><code>sequence_length</code></b>: 1-D <code>int32</code> vector, size <code>[batch_size]</code>. The sequence lengths.</li>
<li><b><code>preprocess_collapse_repeated</code></b>: Boolean. Default: False. If True, repeated labels are collapsed prior to the CTC calculation.</li>
<li><b><code>ctc_merge_repeated</code></b>: Boolean. Default: True.</li>
<li><b><code>time_major</code></b>: The shape format of the <code>inputs</code> Tensors. If True, these <code>Tensors</code> must be shaped <code>[max_time, batch_size, num_classes]</code>. If False, these <code>Tensors</code> must be shaped <code>[batch_size, max_time, num_classes]</code>. Using <code>time_major = True</code> (default) is a bit more efficient because it avoids transposes at the beginning of the ctc_loss calculation. However, most TensorFlow data is batch-major, so by this function also accepts inputs in batch-major form.</li>
</ul>
<h5 id="returns-59">Returns:</h5>
<p>A 1-D <code>float</code> <code>Tensor</code>, size <code>[batch]</code>, containing the negative log probabilities.</p>
<h5 id="raises-23">Raises:</h5>
<ul>
<li><b><code>TypeError</code></b>: if labels is not a <code>SparseTensor</code>.</li>
</ul>
<hr />
<h3 id="tf.nn.ctc_greedy_decoderinputs-sequence_length-merge_repeatedtrue"><a name="//apple_ref/cpp/Function/ctc_greedy_decoder" class="dashAnchor"></a><code id="ctc_greedy_decoder">tf.nn.ctc_greedy_decoder(inputs, sequence_length, merge_repeated=True)</code></h3>
<p>Performs greedy decoding on the logits given in input (best path).</p>
<p>Note: Regardless of the value of merge_repeated, if the maximum index of a given time and batch corresponds to the blank index <code>(num_classes - 1)</code>, no new element is emitted.</p>
<p>If <code>merge_repeated</code> is <code>True</code>, merge repeated classes in output. This means that if consecutive logits' maximum indices are the same, only the first of these is emitted. The sequence <code>A B B * B * B</code> (where '*' is the blank label) becomes</p>
<ul>
<li><code>A B</code> if <code>merge_repeated=True</code>.</li>
<li><code>A B B B B B</code> if <code>merge_repeated=False</code>.</li>
</ul>
<h5 id="args-60">Args:</h5>
<ul>
<li><b><code>inputs</code></b>: 3-D <code>float</code> <code>Tensor</code> sized <code>[max_time x batch_size x num_classes]</code>. The logits.</li>
<li><b><code>sequence_length</code></b>: 1-D <code>int32</code> vector containing sequence lengths, having size <code>[batch_size]</code>.</li>
<li><b><code>merge_repeated</code></b>: Boolean. Default: True.</li>
</ul>
<h5 id="returns-60">Returns:</h5>
<p>A tuple <code>(decoded, log_probabilities)</code> where</p>
<ul>
<li><b><code>decoded</code></b>: A single-element list. <code>decoded[0]</code> is an <code>SparseTensor</code> containing the decoded outputs s.t.: <code>decoded.indices</code>: Indices matrix <code>(total_decoded_outputs x 2)</code>. The rows store: <code>[batch, time]</code>. <code>decoded.values</code>: Values vector, size <code>(total_decoded_outputs)</code>. The vector stores the decoded classes. <code>decoded.shape</code>: Shape vector, size <code>(2)</code>. The shape values are: <code>[batch_size, max_decoded_length]</code></li>
<li><b><code>log_probability</code></b>: A <code>float</code> matrix <code>(batch_size x 1)</code> containing sequence log-probabilities.</li>
</ul>
<hr />
<h3 id="tf.nn.ctc_beam_search_decoderinputs-sequence_length-beam_width100-top_paths1-merge_repeatedtrue"><a name="//apple_ref/cpp/Function/ctc_beam_search_decoder" class="dashAnchor"></a><code id="ctc_beam_search_decoder">tf.nn.ctc_beam_search_decoder(inputs, sequence_length, beam_width=100, top_paths=1, merge_repeated=True)</code></h3>
<p>Performs beam search decoding on the logits given in input.</p>
<p><strong>Note</strong> The <code>ctc_greedy_decoder</code> is a special case of the <code>ctc_beam_search_decoder</code> with <code>top_paths=1</code> and <code>beam_width=1</code> (but that decoder is faster for this special case).</p>
<p>If <code>merge_repeated</code> is <code>True</code>, merge repeated classes in the output beams. This means that if consecutive entries in a beam are the same, only the first of these is emitted. That is, when the top path is <code>A B B B B</code>, the return value is:</p>
<ul>
<li><code>A B</code> if <code>merge_repeated = True</code>.</li>
<li><code>A B B B B</code> if <code>merge_repeated = False</code>.</li>
</ul>
<h5 id="args-61">Args:</h5>
<ul>
<li><b><code>inputs</code></b>: 3-D <code>float</code> <code>Tensor</code>, size <code>[max_time x batch_size x num_classes]</code>. The logits.</li>
<li><b><code>sequence_length</code></b>: 1-D <code>int32</code> vector containing sequence lengths, having size <code>[batch_size]</code>.</li>
<li><b><code>beam_width</code></b>: An int scalar &gt;= 0 (beam search beam width).</li>
<li><b><code>top_paths</code></b>: An int scalar &gt;= 0, &lt;= beam_width (controls output size).</li>
<li><b><code>merge_repeated</code></b>: Boolean. Default: True.</li>
</ul>
<h5 id="returns-61">Returns:</h5>
<p>A tuple <code>(decoded, log_probabilities)</code> where</p>
<ul>
<li><b><code>decoded</code></b>: A list of length top_paths, where <code>decoded[j]</code> is a <code>SparseTensor</code> containing the decoded outputs: <code>decoded[j].indices</code>: Indices matrix <code>(total_decoded_outputs[j] x 2)</code> The rows store: [batch, time]. <code>decoded[j].values</code>: Values vector, size <code>(total_decoded_outputs[j])</code>. The vector stores the decoded classes for beam j. <code>decoded[j].shape</code>: Shape vector, size <code>(2)</code>. The shape values are: <code>[batch_size, max_decoded_length[j]]</code>.</li>
<li><b><code>log_probability</code></b>: A <code>float</code> matrix <code>(batch_size x top_paths)</code> containing sequence log-probabilities.</li>
</ul>
<h2 id="evaluation">Evaluation</h2>
<p>The evaluation ops are useful for measuring the performance of a network. They are typically used at evaluation time.</p>
<hr />
<h3 id="tf.nn.top_kinput-k1-sortedtrue-namenone"><a name="//apple_ref/cpp/Function/top_k" class="dashAnchor"></a><code id="top_k">tf.nn.top_k(input, k=1, sorted=True, name=None)</code></h3>
<p>Finds values and indices of the <code>k</code> largest entries for the last dimension.</p>
<p>If the input is a vector (rank-1), finds the <code>k</code> largest entries in the vector and outputs their values and indices as vectors. Thus <code>values[j]</code> is the <code>j</code>-th largest entry in <code>input</code>, and its index is <code>indices[j]</code>.</p>
<p>For matrices (resp. higher rank input), computes the top <code>k</code> entries in each row (resp. vector along the last dimension). Thus,</p>
<pre><code>values.shape = indices.shape = input.shape[:-1] + [k]</code></pre>
<p>If two elements are equal, the lower-index element appears first.</p>
<h5 id="args-62">Args:</h5>
<ul>
<li><b><code>input</code></b>: 1-D or higher <code>Tensor</code> with last dimension at least <code>k</code>.</li>
<li><b><code>k</code></b>: 0-D <code>int32</code> <code>Tensor</code>. Number of top elements to look for along the last dimension (along each row for matrices).</li>
<li><b><code>sorted</code></b>: If true the resulting <code>k</code> elements will be sorted by the values in descending order.</li>
<li><b><code>name</code></b>: Optional name for the operation.</li>
</ul>
<h5 id="returns-62">Returns:</h5>
<ul>
<li><b><code>values</code></b>: The <code>k</code> largest elements along each last dimensional slice.</li>
<li><b><code>indices</code></b>: The indices of <code>values</code> within the last dimension of <code>input</code>.</li>
</ul>
<hr />
<h3 id="tf.nn.in_top_kpredictions-targets-k-namenone"><a name="//apple_ref/cpp/Function/in_top_k" class="dashAnchor"></a><code id="in_top_k">tf.nn.in_top_k(predictions, targets, k, name=None)</code></h3>
<p>Says whether the targets are in the top <code>K</code> predictions.</p>
<p>This outputs a <code>batch_size</code> bool array, an entry <code>out[i]</code> is <code>true</code> if the prediction for the target class is among the top <code>k</code> predictions among all predictions for example <code>i</code>. Note that the behavior of <code>InTopK</code> differs from the <code>TopK</code> op in its handling of ties; if multiple classes have the same prediction value and straddle the top-<code>k</code> boundary, all of those classes are considered to be in the top <code>k</code>.</p>
<p>More formally, let</p>
<p>\(predictions_i\) be the predictions for all classes for example <code>i</code>, \(targets_i\) be the target class for example <code>i</code>, \(out_i\) be the output for example <code>i</code>,</p>
<p><br /><span class="math display"><em>o</em><em>u</em><em>t</em><sub><em>i</em></sub> = <em>p</em><em>r</em><em>e</em><em>d</em><em>i</em><em>c</em><em>t</em><em>i</em><em>o</em><em>n</em><em>s</em><sub><em>i</em>, <em>t</em><em>a</em><em>r</em><em>g</em><em>e</em><em>t</em><em>s</em><sub><em>i</em></sub></sub> ∈ <em>T</em><em>o</em><em>p</em><em>K</em><em>I</em><em>n</em><em>c</em><em>l</em><em>u</em><em>d</em><em>i</em><em>n</em><em>g</em><em>T</em><em>i</em><em>e</em><em>s</em>(<em>p</em><em>r</em><em>e</em><em>d</em><em>i</em><em>c</em><em>t</em><em>i</em><em>o</em><em>n</em><em>s</em><sub><em>i</em></sub>)</span><br /></p>
<h5 id="args-63">Args:</h5>
<ul>
<li><b><code>predictions</code></b>: A <code>Tensor</code> of type <code>float32</code>. A <code>batch_size</code> x <code>classes</code> tensor.</li>
<li><b><code>targets</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>int32</code>, <code>int64</code>. A <code>batch_size</code> vector of class ids.</li>
<li><b><code>k</code></b>: An <code>int</code>. Number of top elements to look at for computing precision.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-63">Returns:</h5>
<p>A <code>Tensor</code> of type <code>bool</code>. Computed Precision at <code>k</code> as a <code>bool Tensor</code>.</p>
<h2 id="candidate-sampling">Candidate Sampling</h2>
<p>Do you want to train a multiclass or multilabel model with thousands or millions of output classes (for example, a language model with a large vocabulary)? Training with a full Softmax is slow in this case, since all of the classes are evaluated for every training example. Candidate Sampling training algorithms can speed up your step times by only considering a small randomly-chosen subset of contrastive classes (called candidates) for each batch of training examples.</p>
<p>See our <a href="../../extras/candidate_sampling.pdf">Candidate Sampling Algorithms Reference</a></p>
<h3 id="sampled-loss-functions">Sampled Loss Functions</h3>
<p>TensorFlow provides the following sampled loss functions for faster training.</p>
<hr />
<h3 id="tf.nn.nce_lossweights-biases-labels-inputs-num_sampled-num_classes-num_true1-sampled_valuesnone-remove_accidental_hitsfalse-partition_strategymod-namence_loss"><a name="//apple_ref/cpp/Function/nce_loss" class="dashAnchor"></a><code id="nce_loss">tf.nn.nce_loss(weights, biases, labels, inputs, num_sampled, num_classes, num_true=1, sampled_values=None, remove_accidental_hits=False, partition_strategy='mod', name='nce_loss')</code></h3>
<p>Computes and returns the noise-contrastive estimation training loss.</p>
<p>See <a href="http://www.jmlr.org/proceedings/papers/v9/gutmann10a/gutmann10a.pdf">Noise-contrastive estimation: A new estimation principle for unnormalized statistical models</a>. Also see our <a href="../../extras/candidate_sampling.pdf">Candidate Sampling Algorithms Reference</a></p>
<p>Note: By default this uses a log-uniform (Zipfian) distribution for sampling, so your labels must be sorted in order of decreasing frequency to achieve good results. For more details, see <a href="#log_uniform_candidate_sampler">log_uniform_candidate_sampler</a>.</p>
<p>Note: In the case where <code>num_true</code> &gt; 1, we assign to each target class the target probability 1 / <code>num_true</code> so that the target probabilities sum to 1 per-example.</p>
<p>Note: It would be useful to allow a variable number of target classes per example. We hope to provide this functionality in a future release. For now, if you have a variable number of target classes, you can pad them out to a constant number by either repeating them or by padding with an otherwise unused class.</p>
<h5 id="args-64">Args:</h5>
<ul>
<li><b><code>weights</code></b>: A <code>Tensor</code> of shape <code>[num_classes, dim]</code>, or a list of <code>Tensor</code> objects whose concatenation along dimension 0 has shape [num_classes, dim]. The (possibly-partitioned) class embeddings.</li>
<li><b><code>biases</code></b>: A <code>Tensor</code> of shape <code>[num_classes]</code>. The class biases.</li>
<li><b><code>labels</code></b>: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,   num_true]</code>. The target classes.</li>
<li><b><code>inputs</code></b>: A <code>Tensor</code> of shape <code>[batch_size, dim]</code>. The forward activations of the input network.</li>
<li><b><code>num_sampled</code></b>: An <code>int</code>. The number of classes to randomly sample per batch.</li>
<li><b><code>num_classes</code></b>: An <code>int</code>. The number of possible classes.</li>
<li><b><code>num_true</code></b>: An <code>int</code>. The number of target classes per training example.</li>
<li><b><code>sampled_values</code></b>: a tuple of (<code>sampled_candidates</code>, <code>true_expected_count</code>, <code>sampled_expected_count</code>) returned by a <code>*_candidate_sampler</code> function. (if None, we default to <code>log_uniform_candidate_sampler</code>)</li>
<li><b><code>remove_accidental_hits</code></b>: A <code>bool</code>. Whether to remove &quot;accidental hits&quot; where a sampled class equals one of the target classes. If set to <code>True</code>, this is a &quot;Sampled Logistic&quot; loss instead of NCE, and we are learning to generate log-odds instead of log probabilities. See our [Candidate Sampling Algorithms Reference] (../../extras/candidate_sampling.pdf). Default is False.</li>
<li><b><code>partition_strategy</code></b>: A string specifying the partitioning strategy, relevant if <code>len(weights) &gt; 1</code>. Currently <code>&quot;div&quot;</code> and <code>&quot;mod&quot;</code> are supported. Default is <code>&quot;mod&quot;</code>. See <code>tf.nn.embedding_lookup</code> for more details.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-64">Returns:</h5>
<p>A <code>batch_size</code> 1-D tensor of per-example NCE losses.</p>
<hr />
<h3 id="tf.nn.sampled_softmax_lossweights-biases-labels-inputs-num_sampled-num_classes-num_true1-sampled_valuesnone-remove_accidental_hitstrue-partition_strategymod-namesampled_softmax_loss"><a name="//apple_ref/cpp/Function/sampled_softmax_loss" class="dashAnchor"></a><code id="sampled_softmax_loss">tf.nn.sampled_softmax_loss(weights, biases, labels, inputs, num_sampled, num_classes, num_true=1, sampled_values=None, remove_accidental_hits=True, partition_strategy='mod', name='sampled_softmax_loss')</code></h3>
<p>Computes and returns the sampled softmax training loss.</p>
<p>This is a faster way to train a softmax classifier over a huge number of classes.</p>
<p>This operation is for training only. It is generally an underestimate of the full softmax loss.</p>
<p>At inference time, you can compute full softmax probabilities with the expression <code>tf.nn.softmax(tf.matmul(inputs, tf.transpose(weights)) + biases)</code>.</p>
<p>See our [Candidate Sampling Algorithms Reference] (../../extras/candidate_sampling.pdf)</p>
<p>Also see Section 3 of <a href="http://arxiv.org/abs/1412.2007">Jean et al., 2014</a> (<a href="http://arxiv.org/pdf/1412.2007.pdf">pdf</a>) for the math.</p>
<h5 id="args-65">Args:</h5>
<ul>
<li><b><code>weights</code></b>: A <code>Tensor</code> of shape <code>[num_classes, dim]</code>, or a list of <code>Tensor</code> objects whose concatenation along dimension 0 has shape [num_classes, dim]. The (possibly-sharded) class embeddings.</li>
<li><b><code>biases</code></b>: A <code>Tensor</code> of shape <code>[num_classes]</code>. The class biases.</li>
<li><b><code>labels</code></b>: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size,   num_true]</code>. The target classes. Note that this format differs from the <code>labels</code> argument of <code>nn.softmax_cross_entropy_with_logits</code>.</li>
<li><b><code>inputs</code></b>: A <code>Tensor</code> of shape <code>[batch_size, dim]</code>. The forward activations of the input network.</li>
<li><b><code>num_sampled</code></b>: An <code>int</code>. The number of classes to randomly sample per batch.</li>
<li><b><code>num_classes</code></b>: An <code>int</code>. The number of possible classes.</li>
<li><b><code>num_true</code></b>: An <code>int</code>. The number of target classes per training example.</li>
<li><b><code>sampled_values</code></b>: a tuple of (<code>sampled_candidates</code>, <code>true_expected_count</code>, <code>sampled_expected_count</code>) returned by a <code>*_candidate_sampler</code> function. (if None, we default to <code>log_uniform_candidate_sampler</code>)</li>
<li><b><code>remove_accidental_hits</code></b>: A <code>bool</code>. whether to remove &quot;accidental hits&quot; where a sampled class equals one of the target classes. Default is True.</li>
<li><b><code>partition_strategy</code></b>: A string specifying the partitioning strategy, relevant if <code>len(weights) &gt; 1</code>. Currently <code>&quot;div&quot;</code> and <code>&quot;mod&quot;</code> are supported. Default is <code>&quot;mod&quot;</code>. See <code>tf.nn.embedding_lookup</code> for more details.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-65">Returns:</h5>
<p>A <code>batch_size</code> 1-D tensor of per-example sampled softmax losses.</p>
<h3 id="candidate-samplers">Candidate Samplers</h3>
<p>TensorFlow provides the following samplers for randomly sampling candidate classes when using one of the sampled loss functions above.</p>
<hr />
<h3 id="tf.nn.uniform_candidate_samplertrue_classes-num_true-num_sampled-unique-range_max-seednone-namenone"><a name="//apple_ref/cpp/Function/uniform_candidate_sampler" class="dashAnchor"></a><code id="uniform_candidate_sampler">tf.nn.uniform_candidate_sampler(true_classes, num_true, num_sampled, unique, range_max, seed=None, name=None)</code></h3>
<p>Samples a set of classes using a uniform base distribution.</p>
<p>This operation randomly samples a tensor of sampled classes (<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement (if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from the base distribution.</p>
<p>The base distribution for this operation is the uniform distribution over the range of integers <code>[0, range_max)</code>.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code> and <code>sampled_expected_count</code> representing the number of times each of the target classes (<code>true_classes</code>) and the sampled classes (<code>sampled_candidates</code>) is expected to occur in an average tensor of sampled classes. These values correspond to <code>Q(y|x)</code> defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this document</a>. If <code>unique=True</code>, then these are post-rejection probabilities and we compute them approximately.</p>
<h5 id="args-66">Args:</h5>
<ul>
<li><b><code>true_classes</code></b>: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size, num_true]</code>. The target classes.</li>
<li><b><code>num_true</code></b>: An <code>int</code>. The number of target classes per training example.</li>
<li><b><code>num_sampled</code></b>: An <code>int</code>. The number of classes to randomly sample per batch.</li>
<li><b><code>unique</code></b>: A <code>bool</code>. Determines whether all sampled classes in a batch are unique.</li>
<li><b><code>range_max</code></b>: An <code>int</code>. The number of possible classes.</li>
<li><b><code>seed</code></b>: An <code>int</code>. An operation-specific seed. Default is 0.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-66">Returns:</h5>
<ul>
<li><b><code>sampled_candidates</code></b>: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>. The sampled classes.</li>
<li><b><code>true_expected_count</code></b>: A tensor of type <code>float</code>. Same shape as <code>true_classes</code>. The expected counts under the sampling distribution of each of <code>true_classes</code>.</li>
<li><b><code>sampled_expected_count</code></b>: A tensor of type <code>float</code>. Same shape as <code>sampled_candidates</code>. The expected counts under the sampling distribution of each of <code>sampled_candidates</code>.</li>
</ul>
<hr />
<h3 id="tf.nn.log_uniform_candidate_samplertrue_classes-num_true-num_sampled-unique-range_max-seednone-namenone"><a name="//apple_ref/cpp/Function/log_uniform_candidate_sampler" class="dashAnchor"></a><code id="log_uniform_candidate_sampler">tf.nn.log_uniform_candidate_sampler(true_classes, num_true, num_sampled, unique, range_max, seed=None, name=None)</code></h3>
<p>Samples a set of classes using a log-uniform (Zipfian) base distribution.</p>
<p>This operation randomly samples a tensor of sampled classes (<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement (if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from the base distribution.</p>
<p>The base distribution for this operation is an approximately log-uniform or Zipfian distribution:</p>
<p><code>P(class) = (log(class + 2) - log(class + 1)) / log(range_max + 1)</code></p>
<p>This sampler is useful when the target classes approximately follow such a distribution - for example, if the classes represent words in a lexicon sorted in decreasing order of frequency. If your classes are not ordered by decreasing frequency, do not use this op.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code> and <code>sampled_expected_count</code> representing the number of times each of the target classes (<code>true_classes</code>) and the sampled classes (<code>sampled_candidates</code>) is expected to occur in an average tensor of sampled classes. These values correspond to <code>Q(y|x)</code> defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this document</a>. If <code>unique=True</code>, then these are post-rejection probabilities and we compute them approximately.</p>
<h5 id="args-67">Args:</h5>
<ul>
<li><b><code>true_classes</code></b>: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size, num_true]</code>. The target classes.</li>
<li><b><code>num_true</code></b>: An <code>int</code>. The number of target classes per training example.</li>
<li><b><code>num_sampled</code></b>: An <code>int</code>. The number of classes to randomly sample per batch.</li>
<li><b><code>unique</code></b>: A <code>bool</code>. Determines whether all sampled classes in a batch are unique.</li>
<li><b><code>range_max</code></b>: An <code>int</code>. The number of possible classes.</li>
<li><b><code>seed</code></b>: An <code>int</code>. An operation-specific seed. Default is 0.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-67">Returns:</h5>
<ul>
<li><b><code>sampled_candidates</code></b>: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>. The sampled classes.</li>
<li><b><code>true_expected_count</code></b>: A tensor of type <code>float</code>. Same shape as <code>true_classes</code>. The expected counts under the sampling distribution of each of <code>true_classes</code>.</li>
<li><b><code>sampled_expected_count</code></b>: A tensor of type <code>float</code>. Same shape as <code>sampled_candidates</code>. The expected counts under the sampling distribution of each of <code>sampled_candidates</code>.</li>
</ul>
<hr />
<h3 id="tf.nn.learned_unigram_candidate_samplertrue_classes-num_true-num_sampled-unique-range_max-seednone-namenone"><a name="//apple_ref/cpp/Function/learned_unigram_candidate_sampler" class="dashAnchor"></a><code id="learned_unigram_candidate_sampler">tf.nn.learned_unigram_candidate_sampler(true_classes, num_true, num_sampled, unique, range_max, seed=None, name=None)</code></h3>
<p>Samples a set of classes from a distribution learned during training.</p>
<p>This operation randomly samples a tensor of sampled classes (<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement (if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from the base distribution.</p>
<p>The base distribution for this operation is constructed on the fly during training. It is a unigram distribution over the target classes seen so far during training. Every integer in <code>[0, range_max)</code> begins with a weight of 1, and is incremented by 1 each time it is seen as a target class. The base distribution is not saved to checkpoints, so it is reset when the model is reloaded.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code> and <code>sampled_expected_count</code> representing the number of times each of the target classes (<code>true_classes</code>) and the sampled classes (<code>sampled_candidates</code>) is expected to occur in an average tensor of sampled classes. These values correspond to <code>Q(y|x)</code> defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this document</a>. If <code>unique=True</code>, then these are post-rejection probabilities and we compute them approximately.</p>
<h5 id="args-68">Args:</h5>
<ul>
<li><b><code>true_classes</code></b>: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size, num_true]</code>. The target classes.</li>
<li><b><code>num_true</code></b>: An <code>int</code>. The number of target classes per training example.</li>
<li><b><code>num_sampled</code></b>: An <code>int</code>. The number of classes to randomly sample per batch.</li>
<li><b><code>unique</code></b>: A <code>bool</code>. Determines whether all sampled classes in a batch are unique.</li>
<li><b><code>range_max</code></b>: An <code>int</code>. The number of possible classes.</li>
<li><b><code>seed</code></b>: An <code>int</code>. An operation-specific seed. Default is 0.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-68">Returns:</h5>
<ul>
<li><b><code>sampled_candidates</code></b>: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>. The sampled classes.</li>
<li><b><code>true_expected_count</code></b>: A tensor of type <code>float</code>. Same shape as <code>true_classes</code>. The expected counts under the sampling distribution of each of <code>true_classes</code>.</li>
<li><b><code>sampled_expected_count</code></b>: A tensor of type <code>float</code>. Same shape as <code>sampled_candidates</code>. The expected counts under the sampling distribution of each of <code>sampled_candidates</code>.</li>
</ul>
<hr />
<h3 id="tf.nn.fixed_unigram_candidate_samplertrue_classes-num_true-num_sampled-unique-range_max-vocab_file-distortion1.0-num_reserved_ids0-num_shards1-shard0-unigrams-seednone-namenone"><a name="//apple_ref/cpp/Function/fixed_unigram_candidate_sampler" class="dashAnchor"></a><code id="fixed_unigram_candidate_sampler">tf.nn.fixed_unigram_candidate_sampler(true_classes, num_true, num_sampled, unique, range_max, vocab_file='', distortion=1.0, num_reserved_ids=0, num_shards=1, shard=0, unigrams=(), seed=None, name=None)</code></h3>
<p>Samples a set of classes using the provided (fixed) base distribution.</p>
<p>This operation randomly samples a tensor of sampled classes (<code>sampled_candidates</code>) from the range of integers <code>[0, range_max)</code>.</p>
<p>The elements of <code>sampled_candidates</code> are drawn without replacement (if <code>unique=True</code>) or with replacement (if <code>unique=False</code>) from the base distribution.</p>
<p>The base distribution is read from a file or passed in as an in-memory array. There is also an option to skew the distribution by applying a distortion power to the weights.</p>
<p>In addition, this operation returns tensors <code>true_expected_count</code> and <code>sampled_expected_count</code> representing the number of times each of the target classes (<code>true_classes</code>) and the sampled classes (<code>sampled_candidates</code>) is expected to occur in an average tensor of sampled classes. These values correspond to <code>Q(y|x)</code> defined in <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">this document</a>. If <code>unique=True</code>, then these are post-rejection probabilities and we compute them approximately.</p>
<h5 id="args-69">Args:</h5>
<ul>
<li><b><code>true_classes</code></b>: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size, num_true]</code>. The target classes.</li>
<li><b><code>num_true</code></b>: An <code>int</code>. The number of target classes per training example.</li>
<li><b><code>num_sampled</code></b>: An <code>int</code>. The number of classes to randomly sample per batch.</li>
<li><b><code>unique</code></b>: A <code>bool</code>. Determines whether all sampled classes in a batch are unique.</li>
<li><b><code>range_max</code></b>: An <code>int</code>. The number of possible classes.</li>
<li><b><code>vocab_file</code></b>: Each valid line in this file (which should have a CSV-like format) corresponds to a valid word ID. IDs are in sequential order, starting from num_reserved_ids. The last entry in each line is expected to be a value corresponding to the count or relative probability. Exactly one of <code>vocab_file</code> and <code>unigrams</code> needs to be passed to this operation.</li>
<li><b><code>distortion</code></b>: The distortion is used to skew the unigram probability distribution. Each weight is first raised to the distortion's power before adding to the internal unigram distribution. As a result, <code>distortion = 1.0</code> gives regular unigram sampling (as defined by the vocab file), and <code>distortion = 0.0</code> gives a uniform distribution.</li>
<li><b><code>num_reserved_ids</code></b>: Optionally some reserved IDs can be added in the range <code>[0, num_reserved_ids]</code> by the users. One use case is that a special unknown word token is used as ID 0. These IDs will have a sampling probability of 0.</li>
<li><b><code>num_shards</code></b>: A sampler can be used to sample from a subset of the original range in order to speed up the whole computation through parallelism. This parameter (together with <code>shard</code>) indicates the number of partitions that are being used in the overall computation.</li>
<li><b><code>shard</code></b>: A sampler can be used to sample from a subset of the original range in order to speed up the whole computation through parallelism. This parameter (together with <code>num_shards</code>) indicates the particular partition number of the operation, when partitioning is being used.</li>
<li><b><code>unigrams</code></b>: A list of unigram counts or probabilities, one per ID in sequential order. Exactly one of <code>vocab_file</code> and <code>unigrams</code> should be passed to this operation.</li>
<li><b><code>seed</code></b>: An <code>int</code>. An operation-specific seed. Default is 0.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-69">Returns:</h5>
<ul>
<li><b><code>sampled_candidates</code></b>: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>. The sampled classes.</li>
<li><b><code>true_expected_count</code></b>: A tensor of type <code>float</code>. Same shape as <code>true_classes</code>. The expected counts under the sampling distribution of each of <code>true_classes</code>.</li>
<li><b><code>sampled_expected_count</code></b>: A tensor of type <code>float</code>. Same shape as <code>sampled_candidates</code>. The expected counts under the sampling distribution of each of <code>sampled_candidates</code>.</li>
</ul>
<h3 id="miscellaneous-candidate-sampling-utilities">Miscellaneous candidate sampling utilities</h3>
<hr />
<h3 id="tf.nn.compute_accidental_hitstrue_classes-sampled_candidates-num_true-seednone-namenone"><a name="//apple_ref/cpp/Function/compute_accidental_hits" class="dashAnchor"></a><code id="compute_accidental_hits">tf.nn.compute_accidental_hits(true_classes, sampled_candidates, num_true, seed=None, name=None)</code></h3>
<p>Compute the position ids in <code>sampled_candidates</code> matching <code>true_classes</code>.</p>
<p>In Candidate Sampling, this operation facilitates virtually removing sampled classes which happen to match target classes. This is done in Sampled Softmax and Sampled Logistic.</p>
<p>See our <a href="http://www.tensorflow.org/extras/candidate_sampling.pdf">Candidate Sampling Algorithms Reference</a>.</p>
<p>We presuppose that the <code>sampled_candidates</code> are unique.</p>
<p>We call it an 'accidental hit' when one of the target classes matches one of the sampled classes. This operation reports accidental hits as triples <code>(index, id, weight)</code>, where <code>index</code> represents the row number in <code>true_classes</code>, <code>id</code> represents the position in <code>sampled_candidates</code>, and weight is <code>-FLOAT_MAX</code>.</p>
<p>The result of this op should be passed through a <code>sparse_to_dense</code> operation, then added to the logits of the sampled classes. This removes the contradictory effect of accidentally sampling the true target classes as noise classes for the same example.</p>
<h5 id="args-70">Args:</h5>
<ul>
<li><b><code>true_classes</code></b>: A <code>Tensor</code> of type <code>int64</code> and shape <code>[batch_size, num_true]</code>. The target classes.</li>
<li><b><code>sampled_candidates</code></b>: A tensor of type <code>int64</code> and shape <code>[num_sampled]</code>. The sampled_candidates output of CandidateSampler.</li>
<li><b><code>num_true</code></b>: An <code>int</code>. The number of target classes per training example.</li>
<li><b><code>seed</code></b>: An <code>int</code>. An operation-specific seed. Default is 0.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-70">Returns:</h5>
<ul>
<li><b><code>indices</code></b>: A <code>Tensor</code> of type <code>int32</code> and shape <code>[num_accidental_hits]</code>. Values indicate rows in <code>true_classes</code>.</li>
<li><b><code>ids</code></b>: A <code>Tensor</code> of type <code>int64</code> and shape <code>[num_accidental_hits]</code>. Values indicate positions in <code>sampled_candidates</code>.</li>
<li><b><code>weights</code></b>: A <code>Tensor</code> of type <code>float</code> and shape <code>[num_accidental_hits]</code>. Each value is <code>-FLOAT_MAX</code>.</li>
</ul>
<h3 id="quantization-ops">Quantization ops</h3>
<hr />
<h3 id="tf.nn.quantized_conv2dinput-filter-min_input-max_input-min_filter-max_filter-strides-padding-out_typenone-namenone"><a name="//apple_ref/cpp/Function/quantized_conv2d" class="dashAnchor"></a><code id="quantized_conv2d">tf.nn.quantized_conv2d(input, filter, min_input, max_input, min_filter, max_filter, strides, padding, out_type=None, name=None)</code></h3>
<p>Computes a 2D convolution given quantized 4D input and filter tensors.</p>
<p>The inputs are quantized tensors where the lowest value represents the real number of the associated minimum, and the highest represents the maximum. This means that you can only interpret the quantized output in the same way, by taking the returned minimum and maximum values into account.</p>
<h5 id="args-71">Args:</h5>
<ul>
<li><b><code>input</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.</li>
<li><b><code>filter</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>. filter's input_depth dimension must match input's depth dimensions.</li>
<li><b><code>min_input</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized input value represents.</li>
<li><b><code>max_input</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized input value represents.</li>
<li><b><code>min_filter</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized filter value represents.</li>
<li><b><code>max_filter</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized filter value represents.</li>
<li><b><code>strides</code></b>: A list of <code>ints</code>. The stride of the sliding window for each dimension of the input tensor.</li>
<li><b><code>padding</code></b>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</li>
<li><b><code>out_type</code></b>: An optional <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>. Defaults to <code>tf.qint32</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-71">Returns:</h5>
<p>A tuple of <code>Tensor</code> objects (output, min_output, max_output).</p>
<ul>
<li><b><code>output</code></b>: A <code>Tensor</code> of type <code>out_type</code>.</li>
<li><b><code>min_output</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized output value represents.</li>
<li><b><code>max_output</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized output value represents.</li>
</ul>
<hr />
<h3 id="tf.nn.quantized_relu_xfeatures-max_value-min_features-max_features-out_typenone-namenone"><a name="//apple_ref/cpp/Function/quantized_relu_x" class="dashAnchor"></a><code id="quantized_relu_x">tf.nn.quantized_relu_x(features, max_value, min_features, max_features, out_type=None, name=None)</code></h3>
<p>Computes Quantized Rectified Linear X: <code>min(max(features, 0), max_value)</code></p>
<h5 id="args-72">Args:</h5>
<ul>
<li><b><code>features</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>.</li>
<li><b><code>max_value</code></b>: A <code>Tensor</code> of type <code>float32</code>.</li>
<li><b><code>min_features</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized value represents.</li>
<li><b><code>max_features</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized value represents.</li>
<li><b><code>out_type</code></b>: An optional <code>tf.DType</code> from: <code>tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32</code>. Defaults to <code>tf.quint8</code>.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-72">Returns:</h5>
<p>A tuple of <code>Tensor</code> objects (activations, min_activations, max_activations).</p>
<ul>
<li><b><code>activations</code></b>: A <code>Tensor</code> of type <code>out_type</code>. Has the same output shape as &quot;features&quot;.</li>
<li><b><code>min_activations</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized value represents.</li>
<li><b><code>max_activations</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized value represents.</li>
</ul>
<hr />
<h3 id="tf.nn.quantized_max_poolinput-min_input-max_input-ksize-strides-padding-namenone"><a name="//apple_ref/cpp/Function/quantized_max_pool" class="dashAnchor"></a><code id="quantized_max_pool">tf.nn.quantized_max_pool(input, min_input, max_input, ksize, strides, padding, name=None)</code></h3>
<p>Produces the max pool of the input tensor for quantized types.</p>
<h5 id="args-73">Args:</h5>
<ul>
<li><b><code>input</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>. The 4D (batch x rows x cols x depth) Tensor to MaxReduce over.</li>
<li><b><code>min_input</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized input value represents.</li>
<li><b><code>max_input</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized input value represents.</li>
<li><b><code>ksize</code></b>: A list of <code>ints</code>. The size of the window for each dimension of the input tensor. The length must be 4 to match the number of dimensions of the input.</li>
<li><b><code>strides</code></b>: A list of <code>ints</code>. The stride of the sliding window for each dimension of the input tensor. The length must be 4 to match the number of dimensions of the input.</li>
<li><b><code>padding</code></b>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-73">Returns:</h5>
<p>A tuple of <code>Tensor</code> objects (output, min_output, max_output).</p>
<ul>
<li><b><code>output</code></b>: A <code>Tensor</code>. Has the same type as <code>input</code>.</li>
<li><b><code>min_output</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized output value represents.</li>
<li><b><code>max_output</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized output value represents.</li>
</ul>
<hr />
<h3 id="tf.nn.quantized_avg_poolinput-min_input-max_input-ksize-strides-padding-namenone"><a name="//apple_ref/cpp/Function/quantized_avg_pool" class="dashAnchor"></a><code id="quantized_avg_pool">tf.nn.quantized_avg_pool(input, min_input, max_input, ksize, strides, padding, name=None)</code></h3>
<p>Produces the average pool of the input tensor for quantized types.</p>
<h5 id="args-74">Args:</h5>
<ul>
<li><b><code>input</code></b>: A <code>Tensor</code>. Must be one of the following types: <code>qint8</code>, <code>quint8</code>, <code>qint16</code>, <code>quint16</code>, <code>qint32</code>. 4-D with shape <code>[batch, height, width, channels]</code>.</li>
<li><b><code>min_input</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized input value represents.</li>
<li><b><code>max_input</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized input value represents.</li>
<li><b><code>ksize</code></b>: A list of <code>ints</code>. The size of the window for each dimension of the input tensor. The length must be 4 to match the number of dimensions of the input.</li>
<li><b><code>strides</code></b>: A list of <code>ints</code>. The stride of the sliding window for each dimension of the input tensor. The length must be 4 to match the number of dimensions of the input.</li>
<li><b><code>padding</code></b>: A <code>string</code> from: <code>&quot;SAME&quot;, &quot;VALID&quot;</code>. The type of padding algorithm to use.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-74">Returns:</h5>
<p>A tuple of <code>Tensor</code> objects (output, min_output, max_output).</p>
<ul>
<li><b><code>output</code></b>: A <code>Tensor</code>. Has the same type as <code>input</code>.</li>
<li><b><code>min_output</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the lowest quantized output value represents.</li>
<li><b><code>max_output</code></b>: A <code>Tensor</code> of type <code>float32</code>. The float value that the highest quantized output value represents.</li>
</ul>
<h2 id="other-functions-and-classes">Other Functions and Classes</h2>
<hr />
<h3 id="tf.nn.zero_fractionvalue-namenone"><a name="//apple_ref/cpp/Function/zero_fraction" class="dashAnchor"></a><code id="zero_fraction">tf.nn.zero_fraction(value, name=None)</code></h3>
<p>Returns the fraction of zeros in <code>value</code>.</p>
<p>If <code>value</code> is empty, the result is <code>nan</code>.</p>
<p>This is useful in summaries to measure and report sparsity. For example,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    z <span class="op">=</span> tf.Relu(...)
    summ <span class="op">=</span> tf.contrib.deprecated.scalar_summary(<span class="st">&#39;sparsity&#39;</span>,
    tf.nn.zero_fraction(z))</code></pre></div>
<h5 id="args-75">Args:</h5>
<ul>
<li><b><code>value</code></b>: A tensor of numeric type.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>
<h5 id="returns-75">Returns:</h5>
<p>The fraction of zeros in <code>value</code>, with type <code>float32</code>.</p>
